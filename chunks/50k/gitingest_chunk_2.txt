



================================================
FILE: src/bdd_test/java/com/coveros/training/math/AckermannStepDefs.java
================================================
package com.coveros.training.math;

import com.coveros.training.mathematics.Ackermann;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import org.junit.Assert;

import java.math.BigInteger;

public class AckermannStepDefs {

    private BigInteger result;

    @When("I calculate Ackermann's formula using {int} and {int}")
    public void i_calculate_ackermann_s_formula_using_and(int m, int n) {
        result = Ackermann.calculate(m, n);
    }

    @Then("the Ackermann result is {int}")
    public void i_get(int expected) {
        final BigInteger bigExpected = BigInteger.valueOf(expected);
        Assert.assertEquals(bigExpected, result);
    }

}



================================================
FILE: src/bdd_test/java/com/coveros/training/math/FibonacciStepDefs.java
================================================
package com.coveros.training.math;

import com.coveros.training.mathematics.Fibonacci;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import org.junit.Assert;

public class FibonacciStepDefs {

    private long result;

    @When("I calculate the {int} Fibonacci number")
    public void i_calculate_the(Integer nth_fibonacci_number) {
        result = Fibonacci.calculate(nth_fibonacci_number);
    }

    @Then("the Fibonacci result is {long}")
    public void iGetResult(long expected_result) {
        Assert.assertEquals(expected_result, result);
    }
}



================================================
FILE: src/bdd_test/java/com/coveros/training/math/MathStepDefs.java
================================================
package com.coveros.training.math;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import org.junit.Assert;

public class MathStepDefs {

    private int calculated_total;

    @Given("^my website is running and can do math$")
    public void myWebsiteIsRunningAndCanDoMath() {
        // just a comment.  No state to set up.
    }

    @When("I add {int} to {int}")
    public void i_add_to(int num1, int num2) {
        calculated_total = num1 + num2;
    }

    @Then("the result should be {int}")
    public void the_result_should_be(int total) {
        Assert.assertEquals(total, calculated_total);
    }

}



================================================
FILE: src/bdd_test/resources/authentication/login_user.feature
================================================
Feature: A user may login to the system.

    As a registered user of the system,
    I want to be able to login,
    so I can access the system's capabilities.

    # See register_user.feature for the registration portion of authentication

    Scenario: Entering proper credentials authenticates a user to the system.
        Given "adam" is registered in the system with the password "LpcVWwRkWSNVH"
        When when a user authenticates with "adam" and "LpcVWwRkWSNVH"
        Then The system decides that they are authenticated.

    Scenario Outline: Entering invalid credentials fails to authenticate a user to the system.
        Given "adam" is registered in the system with the password "LpcVWwRkWSNVH"
        When when a user authenticates with "<username>" and "<password>"
        Then The system decides that they are not authenticated, because <note>
        Examples:
            | username | password      | note                                        |
            | adam     | lpcvwwrkwsnvh | the password is correct, but all lower-case |
            | adamee   | LpcVWwRkWSNVH | we used an incorrect username               |
            | adam     | LpcVWwR       | we used a shortened version of the password |
            | ALICE    | LpcVWwRkWSNVH | the username was made all upper-case        |


================================================
FILE: src/bdd_test/resources/authentication/register_user.feature
================================================
Feature: A user may register themselves to the system.

    As a potential user of the system,
    I want to be able to register myself,
    so that I can subsequently login to the system

#    Narrative: A user wants to access the system, but they can only do it if they have
#    an account on it.  To register an account, they simply provide
#    a username and a password.  The password should be sufficiently complex, and the
#    username must not have already been registered.  Later, when they want to
#    authenticate themselves, they must enter that same username and password.

    Scenario: A user registers themselves to the system with a good password
        Given a user "adam" is not currently registered in the system
        When they register with that username and use the password "lpcvwwrkwsnvh"
        Then they become registered

    Scenario Outline: A user might try different passwords, but we are making sure they are excellent before we allow it.
        Given a user is in the midst of registering for an account
        When they try registering with the password <password>
        Then the system returns that the password has insufficient entropy
        Examples:
            | password                |
            | typical_password_123    |
            | aaaaaaaaaa              |
            | password123             |
            | really_totally_long     |

    Scenario Outline: A user is unable to register due to blatantly bad password
        Given a user "adam" is not currently registered in the system
        When they enter their username and provide a poor password of <password>
        Then they fail to register and the system indicates a response: <response>
        Examples:
            | password | response       |
            | a        | too short      |
            | 123      | too short      |
            | aaaaa    | too short      |

    Scenario: A user is unable to register due to the username already existing
        Given a username of "adam" is registered
        When a user tries to register with that same name
        Then the system indicates a failure to register



================================================
FILE: src/bdd_test/resources/cartesianproduct/cartesianproduct.feature
================================================
Feature: Allow a user to generate a cartesian product from lists

    As a tester
    I want to calculate all combinations of items from multiple lists
    so that I can create a decision table to test all inputs

#    Narrative: a testing technique is to come up with all combinations of inputs
#    to a system in order to verify that all possibilities are accounted for.  Once
#    you have more than a couple inputs to consider, calculating all the combinations
#    is a tedious practice, which could easily lead to missing certain combinations.
#    This calculator will produce the correct result.

    Scenario: happy path - a typical set of lists
        Given lists as follows:
            | list    |
            | a,b     |
            | 1,2,3,4 |
            | e,f     |
        When we calculate the combinations
        Then the resulting combinations should be as follows:
            """
            (a, 1, e), (a, 1, f), (a, 2, e), (a, 2, f),
            (a, 3, e), (a, 3, f), (a, 4, e), (a, 4, f),
            (b, 1, e), (b, 1, f), (b, 2, e), (b, 2, f),
            (b, 3, e), (b, 3, f), (b, 4, e), (b, 4, f)
            """


================================================
FILE: src/bdd_test/resources/expenses/alcohol.feature
================================================
Feature: calculating the portion of a restaurant check that is alcohol-related

    As someone entering an expense at a restaurant
    I want to be able to precisely calculate the amount of the check for the alcohol
    So that I can divide up the check as required when entering expenses

#    Narrative: When entering an expense at a restaurant, government guidelines require
#    that the expense is split up precisely between food and alcohol.  This is not
#    as straightforward as you might immediately think.  For example if the bill is
#    for $50 and you spent $7 on a beer, the expense isn't just $7 for the beer, it
#    also has to consider the alcohol portion of the tip and tax.

    Scenario: Ordering a beer with dinner
        Given a dinner with the following prices in dollars:
            | subtotal | food total | tip | tax  |
            | 33.47    | 24.48      | 7   | 3.99 |
        When I calculate the alcohol-related portion
        Then I get the following results:
            | total food price | total alcohol price | food ratio |
            | 32.52            | 11.94               | 0.7314     |



================================================
FILE: src/bdd_test/resources/library/add_and_delete_books.feature
================================================
Feature: Librarians may add and delete books

    As a librarian,
    I want to be able to add and delete books,
    So that I have control over the inventory of my library

    Scenario: Can successfully add a book
        Given a book, "The DevOps Handbook", is not currently registered in the system
        When a librarian registers that book
        Then the system has the book registered

    Scenario: Can successfully remove a book
        Given a book, "The DevOps Handbook", is currently registered in the system
        When a librarian deletes that book
        Then the system does not have the book registered

    Scenario: Cannot add a book that already exists
        Given a book, "The DevOps Handbook", is currently registered in the system
        When a librarian registers that book
        Then the system reports an error indicating that the book is already registered

    Scenario: Cannot remove a book that doesn't exist
        Given a book, "The DevOps Handbook", is not currently registered in the system
        When a librarian deletes that book
        Then the system reports an error indicating that the book cannot be deleted because it was never registered

    Scenario: Can delete a book that is loaned out
        Given a book, "The DevOps Handbook", is currently loaned out
        When a librarian deletes that book
        Then the system does not have the book registered

    Scenario: If a book is deleted, then related loans are as well
        Given a book, "The DevOps Handbook", is loaned out
        When a librarian deletes that book
        Then the loan is deleted as well






================================================
FILE: src/bdd_test/resources/library/add_and_delete_borrowers.feature
================================================
Feature: Librarians may add and delete borrowers

    As a librarian,
    I want to be able to add and delete borrowers,
    So that I have control over who is allowed to borrow from the library

    Scenario: Can successfully add a borrower
        Given a borrower, "alice", is not currently registered in the system
        When a librarian registers that borrower
        Then the system has the borrower registered

    Scenario: Can successfully remove a borrower
        Given a borrower, "alice", is currently registered in the system
        When a librarian deletes that borrower
        Then the system does not have the borrower registered

    Scenario: Cannot add a borrower that already exists
        Given a borrower, "alice", is currently registered in the system
        When a librarian registers that borrower
        Then the system reports an error indicating that the borrower is already registered

    Scenario: Cannot remove a borrower that doesn't exist
        Given a borrower, "alice", is not currently registered in the system
        When a librarian deletes that borrower
        Then the system reports an error indicating that the borrower cannot be deleted because he or she was never registered

    Scenario: Can delete a borrower that has a loan
        Given a book is currently loaned out to "alice"
        When a librarian deletes that borrower
        Then the system does not have the borrower registered

     Scenario: If a borrower is deleted, then their loan is too
         Given a book is loaned to "alice"
         When a librarian deletes that borrower
         Then the loan is deleted as well





================================================
FILE: src/bdd_test/resources/library/check_out_a_book.feature
================================================
Feature: A librarian may lend a book from the library

    As a librarian,
    I would like to lend a book
    so that patrons may enjoy it outside the library.

#    Narrative: A county library system has many books available for borrowing.  If you
#    live in that county, and you have registered for a library card, you are able
#    to borrow books.  The system shall provide the capability to lend out books.
#    The librarians are in control of lending out books.

    Scenario: A registered patron checks out a book
        Given a borrower, "alice", is registered
        And a book, "Specification By Example" is available for borrowing
        When they try to check out the book on "January 31, 2018"
        Then the system indicates the book is loaned to them on that date

    Scenario: A non-registered person should not be able to borrow a book
        Given an individual, "bob", is not registered
        When they try to check out a book, "BDD in Action" that is available
        Then the system indicates that they are not registered

    Scenario: A registered borrower cannot borrow a non-available book
        Given a borrower, "alice", is registered
        And and a book, "Specification By Example" is already checked out to "bob"
        When they try to check out the book
        Then the system indicates that the book is not available

    Scenario: a borrower can borrow more than one book
        Given a borrower, "alice", has one book, "The DevOps Handbook", already borrowed
        When they borrow another book
        Then they have two books currently borrowed

    Scenario: a book can only be loaned to one person
        Given a borrower, "alice", has one book, "The DevOps Handbook", already borrowed
        When another borrower, "bob" tries to borrow that book
        Then they cannot borrow it because it is already checked out




================================================
FILE: src/bdd_test/resources/library/list_and_search_books.feature
================================================
Feature: Librarians may list and search books

    As a librarian,
    I want to be able to list and search books,
    So that I can review the inventory of my library

    Scenario: Can list all the books
        Given a library with the following books registered: a, b, c
        When a librarian lists all the registered books
        Then the whole list of books is returned

    Scenario: Can search a book by title
        Given a book, "The DevOps Handbook", is currently registered in the system
        When a librarian searches by that title
        Then the system returns the book's full data

    Scenario: Can search a book by id
        Given a book, "The DevOps Handbook", is currently registered in the system
        When a librarian searches by its id
        Then the system returns the book's full data

    Scenario: Should return an empty result if search by id finds nothing
        Given no books are registered in the system
        When a librarian searches for a book by id 1
        Then the system returns an empty result for the book

    Scenario: Should return an empty result if search by title finds nothing
        Given no books are registered in the system
        When a librarian searches for a book by title of "The DevOps Handbook"
        Then the system returns an empty result for the book

    Scenario: Receive an appropriate message if listing all books, but no books in library
        Given no books are registered in the system
        When a librarian lists all the registered books
        Then the system reports that there are no books in the system

    Scenario: Can obtain a list of available books
        Given some books are checked out
        When a librarian lists the available books
        Then the system responds with only the available books






================================================
FILE: src/bdd_test/resources/library/list_and_search_borrowers.feature
================================================
Feature: Librarians may list and search borrowers

    As a librarian,
    I want to be able to list and search borrowers,
    So that I can review the borrowers of my library

    Scenario: Can list all the borrowers
        Given a library with the following borrowers registered: a, b, c
        When a librarian lists all the registered borrowers
        Then the whole list of borrowers is returned

    Scenario: Can search a borrower by name
        Given a borrower, "alice", is currently registered in the system
        When a librarian searches by that name
        Then the system returns the borrower's full data

    Scenario: Can search a borrower by id
        Given a borrower, "alice", is currently registered in the system
        When a librarian searches by that id
        Then the system returns the borrower's full data

    Scenario: Should return an empty result if search by id finds nothing
        Given no borrowers are registered in the system
        When a librarian searches for a borrower by id 1
        Then the system returns an empty result for the borrower

    Scenario: Should return an empty result if search by title finds nothing
        Given no borrowers are registered in the system
        When a librarian searches for a borrower by name of "alice"
        Then the system returns an empty result for the borrower

    Scenario: Receive an appropriate message if listing all borrowers, but no borrowers in library
        Given no borrowers are registered in the system
        When a librarian lists all the borrowers
        Then the system returns an empty list of borrowers




================================================
FILE: src/bdd_test/resources/math/ackerman.feature
================================================
Feature: Calculation of Ackermann's function

    As a cool computer kid
    I want to calculate the result of Ackermann's function for various values
    So that I can see an early example of a total computable function

    Narrative:
        from Wikipedia (https://en.wikipedia.org/wiki/Ackermann_function)
        In computability theory, the Ackermann function, named after Wilhelm Ackermann, is one of the simplest
        and earliest-discovered examples of a total computable function that is not primitive recursive. All primitive
        recursive functions are total and computable, but the Ackermann function illustrates that not all total
        computable functions are primitive recursive.

        After Ackermann's publication[2] of his function (which had three nonnegative integer arguments), many
        authors modified it to suit various purposes, so that today "the Ackermann function" may refer to any
        of numerous variants of the original function.

        from Rosetta Code (https://rosettacode.org/wiki/Ackermann_function)
        The Ackermann function is a classic example of a recursive function, notable especially because it
        is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.

    Scenario Outline: I should be able to calculate a few results per Ackermann's formula
        When I calculate Ackermann's formula using <m> and <n>
        Then the Ackermann result is <result>
        Examples:
          |  m    |    n        |     result    |
          |  0    |    0        |       1       |
          |  1    |    1        |       3       |
          |  1    |    2        |       4       |


================================================
FILE: src/bdd_test/resources/math/Fibonacci.feature
================================================
Feature: Calculation of Fibonacci numbers

    As an aspiring mathematically-oriented beekeeper
    I want to be able to calculate Fibonacci numbers
    So that I can count the idealized number of honeybees in my hive

    Narrative:
        from Wikipedia (https://en.wikipedia.org/wiki/Fibonacci_number)
        Fibonacci numbers are strongly related to the golden ratio: Binet's formula expresses the nth Fibonacci
        number in terms of n and the golden ratio, and implies that the ratio of two consecutive Fibonacci numbers
        tends to the golden ratio as n increases.

        Fibonacci numbers are named after Italian mathematician Leonardo of Pisa, later known as Fibonacci. They appear
        to have first arisen as early as 200 BC in work by Pingala on enumerating possible patterns of poetry formed
        from syllables of two lengths. In his 1202 book Liber Abaci, Fibonacci introduced the sequence to Western
        European mathematics,[6] although the sequence had been described earlier in Indian mathematics.[7][8][9]

        Fibonacci numbers appear unexpectedly often in mathematics, so much so that there is an entire journal
        dedicated to their study, the Fibonacci Quarterly. Applications of Fibonacci numbers include computer
        algorithms such as the Fibonacci search technique and the Fibonacci heap data structure, and graphs called
        Fibonacci cubes used for interconnecting parallel and distributed systems.

        They also appear in biological settings, such as branching in trees, the arrangement of leaves on a stem,
        the fruit sprouts of a pineapple, the flowering of an artichoke, an uncurling fern and the arrangement
        of a pine cone's bracts.

    Scenario Outline: Calculating some Fibonacci numbers
        When I calculate the <nth> Fibonacci number
        Then the Fibonacci result is <result>
        Examples:
        |   nth                    |    result       |
        |           0              |      0          |
        |           1              |      1          |
        |           2              |      1          |
        |           3              |      2          |
        |           20             |      6765       |


================================================
FILE: src/bdd_test/resources/math/math.feature
================================================
Feature: Adding of numbers

    As a user who has trouble with doing math in their head,
    I want to add some numbers
    so I know the sums

    Scenario Outline: Add two numbers <num1> and <num2>
        Given my website is running and can do math
        When I add <num1> to <num2>
        Then the result should be <total>
        Examples:
            | num1 | num2 | total |
            | 2    | 3    | 5     |
            | 9    | 6    | 15    |
            | 2    | -3   | -1    |




================================================
FILE: src/integration_test/java/com/coveros/training/persistence/PersistenceLayerTests.java
================================================
package com.coveros.training.persistence;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.library.domainobjects.Loan;
import com.coveros.training.authentication.domainobjects.User;
import org.h2.jdbcx.JdbcConnectionPool;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.sql.DataSource;
import java.sql.*;
import java.time.LocalDate;
import java.time.Month;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

/**
 * Test that we have a persistence layer that we can easily mock out.
 * This exists so we can have more control over the persistence process,
 * whether we want to mock those sections, and so on.
 */
public class PersistenceLayerTests {

    private final static String DEFAULT_NAME = "alice";
    private final static Date BORROW_DATE = Date.valueOf(LocalDate.of(2018, Month.JANUARY, 1));
    private static final Book DEFAULT_BOOK = new Book(1, "The DevOps Handbook");
    private static final Borrower DEFAULT_BORROWER = new Borrower(1, DEFAULT_NAME);
    private static final Loan DEFAULT_LOAN = new Loan(DEFAULT_BOOK, DEFAULT_BORROWER, 1, BORROW_DATE);
    private static final User DEFAULT_USER = new User(DEFAULT_NAME, 1);
    IPersistenceLayer pl;

    @Before
    public void initDatabase() {
        pl = new PersistenceLayer(getFileBasedDatabaseConnectionPool());
    }

    /**
     * assert that there is a way to store a borrower
     * in a database.  We don't actually care how this happens,
     * we just care that it exists.  Here we're adding a
     * brand-spanking-new borrower.
     */
    @Test
    public void testShouldSaveBorrowerToDatabase() {
        pl.cleanAndMigrateDatabase();

        long id = pl.saveNewBorrower(DEFAULT_BORROWER.name);

        assertEquals("The first row in a database gets an index of 1", 1, id);
    }

    /**
     * We ought to be able to update a borrower's details,
     * if we know that borrower's id and we have a detail we
     * want to change.
     */
    @Test
    public void testShouldUpdateBorrowerToDatabase() {
        // the borrower with id of 1 is "alice"
        runRestoreOneBookOneBorrower();
        final String newName = "bob";

        // change the borrower's name
        pl.updateBorrower(1, newName);

        String name = pl.getBorrowerName(1).orElseThrow();
        assertEquals(newName, name);
    }

    /**
     * If a borrower is in the database, we should be able
     * to find that person by their name
     */
    @Test
    public void testShouldBeAbleToSearchBorrowerByName() {
        runRestoreOneBookOneBorrower();

        Borrower borrower = pl.searchBorrowerDataByName(DEFAULT_BORROWER.name).orElseThrow();

        assertEquals(DEFAULT_BORROWER, borrower);
    }

    /**
     * If a book is in the database, we should be able to find it by title.
     */
    @Test
    public void testShouldBeAbleToSearchForBooksByTitle() {
        runRestoreOneBookOneBorrower();
        final Book expectedBook = new Book(1, DEFAULT_BOOK.title);

        Book book = pl.searchBooksByTitle(DEFAULT_BOOK.title).orElseThrow();

        assertEquals(expectedBook, book);
    }

    /**
     * If a book is in the database, we should be able to find it by id.
     */
    @Test
    public void testShouldBeAbleToSearchForBooksById() {
        // this will set the default book into the database
        runRestoreOneBookOneBorrower();
        final Book expectedBook = new Book(1, DEFAULT_BOOK.title);

        // search for it by id
        Book book = pl.searchBooksById(DEFAULT_BOOK.id).orElseThrow();

        assertEquals(expectedBook, book);
    }

    /**
     * If a borrower is in the database, we should be able to find it by id.
     */
    @Test
    public void testShouldBeAbleToSearchForBorrowersById() {
        runRestoreOneBookOneBorrower();

        Borrower borrower = pl.searchBorrowersById(DEFAULT_BORROWER.id).orElseThrow();

        assertEquals(DEFAULT_BORROWER, borrower);
    }

    @Test
    public void testShouldBeAbleToSearchAUserByName() {
        runRestoreOneUser();

        User user = pl.searchForUserByName(DEFAULT_USER.name).orElseThrow();

        assertEquals(DEFAULT_USER, user);
    }

    @Test
    public void testThatWeCanUpdateAUsersPassword() {
        runRestoreOneUser();
        final String newPassword = "abc123";

        pl.updateUserWithPassword(1, newPassword);
        final boolean result = pl.areCredentialsValid(DEFAULT_BORROWER.name, newPassword).orElseThrow();

        assertTrue(result);
    }

    @Test
    public void testWeCanCreateLoan() {
        runRestoreOneBookOneBorrower();

        final long loanId = pl.createLoan(DEFAULT_BOOK, DEFAULT_BORROWER, BORROW_DATE);

        assertEquals(1, loanId);
    }


    @Test
    public void testWeCanSearchForALoanByABook() {
        runRestoreOneLoan();

        Loan loan = pl.searchForLoanByBook(DEFAULT_BOOK).orElseThrow();

        assertEquals(DEFAULT_LOAN, loan);
    }

    @Test
    public void testWeCanSearchForALoanByABorrower() {
        runRestoreOneLoan();

        Loan loan = pl.searchForLoanByBorrower(DEFAULT_BORROWER).get().get(0);

        assertEquals(DEFAULT_LOAN, loan);
    }

    @Test
    public void testWeCanSaveANewUser() {
        pl.cleanAndMigrateDatabase();

        long id = pl.saveNewUser(DEFAULT_USER.name);

        assertEquals(DEFAULT_USER.id, id);
    }

    @Test
    public void testWeCanSaveABook() {
        pl.cleanAndMigrateDatabase();

        long id = pl.saveNewBook(DEFAULT_BOOK.title);

        assertEquals(DEFAULT_BOOK.id, id);
    }

    @Test
    public void testWeCanCreateALoan() {
        runRestoreOneBookOneBorrower();

        long id = pl.createLoan(DEFAULT_BOOK, DEFAULT_BORROWER, BORROW_DATE);

        assertEquals(DEFAULT_LOAN.id, id);
    }

    @Test
    public void testShouldBeAbleToDeleteBook() {
        runRestoreOneBookOneBorrower();

        pl.deleteBook(DEFAULT_BOOK.id);
        final Optional<Book> book = pl.searchBooksByTitle(DEFAULT_BOOK.title);

        assertTrue(book.isEmpty());
    }

    @Test
    public void testShouldBeAbleToDeleteBorrower() {
        runRestoreOneBookOneBorrower();

        pl.deleteBorrower(DEFAULT_BORROWER.id);
        final Optional<Borrower> borrower = pl.searchBorrowerDataByName(DEFAULT_BORROWER.name);

        assertTrue(borrower.isEmpty());
    }

    @Test
    public void testShouldListAllBooks() {
        runRestoreOneBookOneBorrower();
        List<Book> expectedList = Arrays.asList(DEFAULT_BOOK);

        final List<Book> books = pl.listAllBooks().orElseThrow();

        assertEquals(expectedList, books);
    }

    @Test
    public void testShouldListAvailableBooks() {
        runRestoreThreeBooksThreeBorrowers();
        // loan out a book
        pl.createLoan(pl.searchBooksByTitle("b").orElseThrow(), pl.searchBorrowerDataByName("alice").orElseThrow(), BORROW_DATE);

        // create expected book list
        final List<Book> expectedBooks = new ArrayList<>();
        expectedBooks.add(new Book(1, "a"));
        expectedBooks.add(new Book(3, "c"));

        // act
        final List<Book> books = pl.listAvailableBooks().orElseThrow();

        // assert
        assertEquals(expectedBooks, books);
    }


    /**
     * If you check them all out - you'll get nothing in the available list.
     */
    @Test
    public void testShouldListNoAvailableBooksIfAllCheckedOut() {
        runRestoreThreeBooksThreeBorrowers();
        // loan out a book
        pl.createLoan(pl.searchBooksByTitle("a").orElseThrow(), pl.searchBorrowerDataByName("alice").orElseThrow(), BORROW_DATE);
        pl.createLoan(pl.searchBooksByTitle("b").orElseThrow(), pl.searchBorrowerDataByName("alice").orElseThrow(), BORROW_DATE);
        pl.createLoan(pl.searchBooksByTitle("c").orElseThrow(), pl.searchBorrowerDataByName("alice").orElseThrow(), BORROW_DATE);

        // act
        final Optional<List<Book>> books = pl.listAvailableBooks();

        // assert
        assertTrue(books.isEmpty());
    }

    /**
     * If none are checked out - you'll get everything in the available list.
     */
    @Test
    public void testShouldListAllBooksIfNoneCheckedOut() {
        runRestoreThreeBooksThreeBorrowers();
        // create expected book list
        final List<Book> expectedBooks = new ArrayList<>();
        expectedBooks.add(new Book(1, "a"));
        expectedBooks.add(new Book(2, "b"));
        expectedBooks.add(new Book(3, "c"));

        // act
        final List<Book> books = pl.listAvailableBooks().orElseThrow();

        // assert
        assertEquals(expectedBooks, books);
    }

    @Test
    public void testShouldListAllBorrowers() {
        runRestoreOneBookOneBorrower();
        List<Borrower> expectedList = Arrays.asList(DEFAULT_BORROWER);

        final List<Borrower> borrowers = pl.listAllBorrowers().orElseThrow();

        assertEquals(expectedList, borrowers);
    }

    @Test(expected = SqlRuntimeException.class)
    public void testThatExecuteInsertOnPreparedStatementHandlesExceptions() throws SQLException {
        final PersistenceLayer persistenceLayer = new PersistenceLayer();
        final PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        final ResultSet resultSet = Mockito.mock(ResultSet.class);
        when(resultSet.next()).thenReturn(false);
        when(preparedStatement.getGeneratedKeys()).thenReturn(resultSet);

        persistenceLayer.executeInsertOnPreparedStatement(SqlData.createEmpty(), preparedStatement);
    }

    /**
     * Test what happens if no value is returned when we provide an
     * id to a particular user.
     */
    @Test
    public void testGetBorrowerName_WhenNoValueReturned() throws SQLException {
        final DataSource dataSource = Mockito.mock(DataSource.class);
        final PersistenceLayer persistenceLayer = new PersistenceLayer(dataSource);
        final Connection connection = Mockito.mock(Connection.class);
        final PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        when(connection.prepareStatement(Mockito.anyString())).thenReturn(preparedStatement);
        when(dataSource.getConnection()).thenReturn(connection);
        final ResultSet resultSet = Mockito.mock(ResultSet.class);
        when(resultSet.next()).thenReturn(false);
        when(preparedStatement.executeQuery()).thenReturn(resultSet);

        final Optional<String> borrowerName = persistenceLayer.getBorrowerName(1);

        assertTrue(borrowerName.isEmpty());
    }

    /**
     * Test what happens when an exception occurs in getBorrowerName
     */
    @Test(expected = SqlRuntimeException.class)
    public void testGetBorrowerName_WhenExceptionThrown() throws SQLException {
        final DataSource dataSource = Mockito.mock(DataSource.class);
        when(dataSource.getConnection()).thenThrow(new SQLException());
        final PersistenceLayer persistenceLayer = new PersistenceLayer(dataSource);

        persistenceLayer.getBorrowerName(1);
    }

    /**
     * An exception of the right type should be thrown
     * when an error occurs in the {@link PersistenceLayer#executeUpdateTemplate} method.
     */
    @Test(expected = SqlRuntimeException.class)
    public void testExecuteUpdateTemplate_ExceptionThrown() throws SQLException {
        final DataSource dataSource = Mockito.mock(DataSource.class);
        when(dataSource.getConnection()).thenThrow(new SQLException());
        final PersistenceLayer persistenceLayer = new PersistenceLayer(dataSource);

        persistenceLayer.executeUpdateTemplate("","");
    }

    /**
     * This can be run here, simply put @Test on top.
     */
    public void runBackup() {
        pl.runBackup("v2_three_books_three_borrowers.sql");
    }

    /**
     * This can be run here, simply put @Test on top.
     */
    public void setState() {
        runRestoreOneBookOneBorrower();
    }

    /**
     * this will set "alice" with id of 1 into the database as a borrower
     * and "The DevOps Handbook" with id of 1 as a book.
     */
    private void runRestoreOneBookOneBorrower() {
        runRestore("v2_one_book_one_borrower.sql");
    }

    private void runRestoreOneUser() {
        runRestore("v2_one_user.sql");
    }

    private void runRestoreOneLoan() {
        runRestore("v2_one_loan.sql");
    }

    /**
     * This backup has books: a, b, and c.  The borrowers are alice, bob, and carol
     */
    private void runRestoreThreeBooksThreeBorrowers() {
        runRestore("v2_three_books_three_borrowers.sql");
    }

    private void runRestore(String scriptName) {
        pl.runRestore(scriptName);
    }

    /**
     * Get a file-based {@link JdbcConnectionPool}, which makes it easier
     * to debug database tests when they are running.
     * <p>
     * Because we set AUTO_SERVER to true, we can access this database
     * from multiple places when it starts.
     * <p>
     * This method is solely meant to be used by database tests.
     */
    private static JdbcConnectionPool getFileBasedDatabaseConnectionPool() {
        return JdbcConnectionPool.create(
                "jdbc:h2:./build/db/training;AUTO_SERVER=TRUE;MODE=PostgreSQL", "", "");
    }


}



================================================
FILE: src/integration_test/resources/db_sample_files/README.txt
================================================
These are the backups of the library database, used during integration
testing.  Notice the naming scheme - each starts with the version of the
database, which originates from the Flyway scripts - see that folder.

We would always want to keep the version of our backups the same as the
version of the database migration scripts because our integration tests
assume a correct and current schema. That is, unless, however, we are specifically
testing that a database script successfully transitions the schema without
corrupting data, which is a valid and common concern during development.


================================================
FILE: src/integration_test/resources/db_sample_files/v2_empty_schema.sql
================================================
;             
CREATE USER IF NOT EXISTS SA SALT '7ab557eb69745223' HASH '8a3855f1eb198976108dae4d0d5cdf5eb907e73321db99c043737af0124852f6' ADMIN;           
CREATE SCHEMA IF NOT EXISTS ADMINISTRATIVE AUTHORIZATION SA;  
CREATE SCHEMA IF NOT EXISTS AUTH AUTHORIZATION SA;            
CREATE SCHEMA IF NOT EXISTS LIBRARY AUTHORIZATION SA;         
CREATE SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722 START WITH 1 BELONGS_TO_TABLE;      
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B START WITH 1 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0 START WITH 1 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E START WITH 1 BELONGS_TO_TABLE;   
CREATE CACHED TABLE ADMINISTRATIVE."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE ADMINISTRATIVE."flyway_schema_history" ADD CONSTRAINT ADMINISTRATIVE."flyway_schema_history_pk" PRIMARY KEY("installed_rank");    
-- 3 +/- SELECT COUNT(*) FROM ADMINISTRATIVE."flyway_schema_history";         
INSERT INTO ADMINISTRATIVE."flyway_schema_history"("installed_rank", "version", "description", "type", "script", "checksum", "installed_by", "installed_on", "execution_time", "success") VALUES
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, 'SA', TIMESTAMP '2019-01-31 17:35:59.667', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, 'SA', TIMESTAMP '2019-01-31 17:35:59.691', 3, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1767572289, 'SA', TIMESTAMP '2019-01-31 17:35:59.706', 9, TRUE);         
CREATE INDEX ADMINISTRATIVE."flyway_schema_history_s_idx" ON ADMINISTRATIVE."flyway_schema_history"("success");               
CREATE CACHED TABLE LIBRARY.BORROWER(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B,
    NAME VARCHAR(100) NOT NULL
);   
ALTER TABLE LIBRARY.BORROWER ADD CONSTRAINT LIBRARY.CONSTRAINT_A PRIMARY KEY(ID);             
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
CREATE CACHED TABLE LIBRARY.BOOK(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0,
    TITLE VARCHAR(100) NOT NULL
);      
ALTER TABLE LIBRARY.BOOK ADD CONSTRAINT LIBRARY.CONSTRAINT_1 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
CREATE CACHED TABLE LIBRARY.LOAN(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E,
    BOOK INT NOT NULL,
    BORROWER INT NOT NULL,
    BORROW_DATE DATE NOT NULL
);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_2 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
CREATE CACHED TABLE AUTH.USER(
    ID INT DEFAULT (NEXT VALUE FOR AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722) NOT NULL NULL_TO_DEFAULT SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722,
    NAME VARCHAR(100) NOT NULL,
    PASSWORD_HASH VARCHAR(100)
);               
ALTER TABLE AUTH.USER ADD CONSTRAINT AUTH.CONSTRAINT_2 PRIMARY KEY(ID);       
-- 0 +/- SELECT COUNT(*) FROM AUTH.USER;      
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23B FOREIGN KEY(BORROWER) REFERENCES LIBRARY.BORROWER(ID) NOCHECK; 
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23 FOREIGN KEY(BOOK) REFERENCES LIBRARY.BOOK(ID) NOCHECK;          



================================================
FILE: src/integration_test/resources/db_sample_files/v2_one_book_one_borrower.sql
================================================
;             
CREATE USER IF NOT EXISTS SA SALT '7ab557eb69745223' HASH '8a3855f1eb198976108dae4d0d5cdf5eb907e73321db99c043737af0124852f6' ADMIN;           
CREATE SCHEMA IF NOT EXISTS ADMINISTRATIVE AUTHORIZATION SA;  
CREATE SCHEMA IF NOT EXISTS AUTH AUTHORIZATION SA;            
CREATE SCHEMA IF NOT EXISTS LIBRARY AUTHORIZATION SA;         
CREATE SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722 START WITH 1 BELONGS_TO_TABLE;      
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B START WITH 2 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0 START WITH 2 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E START WITH 1 BELONGS_TO_TABLE;   
CREATE CACHED TABLE ADMINISTRATIVE."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE ADMINISTRATIVE."flyway_schema_history" ADD CONSTRAINT ADMINISTRATIVE."flyway_schema_history_pk" PRIMARY KEY("installed_rank");    
-- 3 +/- SELECT COUNT(*) FROM ADMINISTRATIVE."flyway_schema_history";         
INSERT INTO ADMINISTRATIVE."flyway_schema_history"("installed_rank", "version", "description", "type", "script", "checksum", "installed_by", "installed_on", "execution_time", "success") VALUES
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, 'SA', TIMESTAMP '2019-01-31 17:35:59.667', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, 'SA', TIMESTAMP '2019-01-31 17:35:59.691', 3, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1767572289, 'SA', TIMESTAMP '2019-01-31 17:35:59.706', 9, TRUE);         
CREATE INDEX ADMINISTRATIVE."flyway_schema_history_s_idx" ON ADMINISTRATIVE."flyway_schema_history"("success");               
CREATE CACHED TABLE LIBRARY.BORROWER(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B,
    NAME VARCHAR(100) NOT NULL
);   
ALTER TABLE LIBRARY.BORROWER ADD CONSTRAINT LIBRARY.CONSTRAINT_A PRIMARY KEY(ID);             
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
INSERT INTO LIBRARY.BORROWER(ID, NAME) VALUES
(1, 'alice');  
CREATE CACHED TABLE LIBRARY.BOOK(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0,
    TITLE VARCHAR(100) NOT NULL
);      
ALTER TABLE LIBRARY.BOOK ADD CONSTRAINT LIBRARY.CONSTRAINT_1 PRIMARY KEY(ID); 
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
INSERT INTO LIBRARY.BOOK(ID, TITLE) VALUES
(1, 'The DevOps Handbook');       
CREATE CACHED TABLE LIBRARY.LOAN(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E,
    BOOK INT NOT NULL,
    BORROWER INT NOT NULL,
    BORROW_DATE DATE NOT NULL
);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_2 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
CREATE CACHED TABLE AUTH.USER(
    ID INT DEFAULT (NEXT VALUE FOR AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722) NOT NULL NULL_TO_DEFAULT SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722,
    NAME VARCHAR(100) NOT NULL,
    PASSWORD_HASH VARCHAR(100)
);               
ALTER TABLE AUTH.USER ADD CONSTRAINT AUTH.CONSTRAINT_2 PRIMARY KEY(ID);       
-- 0 +/- SELECT COUNT(*) FROM AUTH.USER;      
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23B FOREIGN KEY(BORROWER) REFERENCES LIBRARY.BORROWER(ID) NOCHECK; 
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23 FOREIGN KEY(BOOK) REFERENCES LIBRARY.BOOK(ID) NOCHECK;          



================================================
FILE: src/integration_test/resources/db_sample_files/v2_one_loan.sql
================================================
;             
CREATE USER IF NOT EXISTS SA SALT '7ab557eb69745223' HASH '8a3855f1eb198976108dae4d0d5cdf5eb907e73321db99c043737af0124852f6' ADMIN;           
CREATE SCHEMA IF NOT EXISTS ADMINISTRATIVE AUTHORIZATION SA;  
CREATE SCHEMA IF NOT EXISTS AUTH AUTHORIZATION SA;            
CREATE SCHEMA IF NOT EXISTS LIBRARY AUTHORIZATION SA;         
CREATE SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722 START WITH 1 BELONGS_TO_TABLE;      
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B START WITH 2 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0 START WITH 2 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E START WITH 2 BELONGS_TO_TABLE;   
CREATE CACHED TABLE ADMINISTRATIVE."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE ADMINISTRATIVE."flyway_schema_history" ADD CONSTRAINT ADMINISTRATIVE."flyway_schema_history_pk" PRIMARY KEY("installed_rank");    
-- 3 +/- SELECT COUNT(*) FROM ADMINISTRATIVE."flyway_schema_history";         
INSERT INTO ADMINISTRATIVE."flyway_schema_history"("installed_rank", "version", "description", "type", "script", "checksum", "installed_by", "installed_on", "execution_time", "success") VALUES
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, 'SA', TIMESTAMP '2019-01-31 17:35:59.667', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, 'SA', TIMESTAMP '2019-01-31 17:35:59.691', 3, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1767572289, 'SA', TIMESTAMP '2019-01-31 17:35:59.706', 9, TRUE);         
CREATE INDEX ADMINISTRATIVE."flyway_schema_history_s_idx" ON ADMINISTRATIVE."flyway_schema_history"("success");               
CREATE CACHED TABLE LIBRARY.BORROWER(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B,
    NAME VARCHAR(100) NOT NULL
);   
ALTER TABLE LIBRARY.BORROWER ADD CONSTRAINT LIBRARY.CONSTRAINT_A PRIMARY KEY(ID);             
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
INSERT INTO LIBRARY.BORROWER(ID, NAME) VALUES
(1, 'alice');  
CREATE CACHED TABLE LIBRARY.BOOK(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0,
    TITLE VARCHAR(100) NOT NULL
);      
ALTER TABLE LIBRARY.BOOK ADD CONSTRAINT LIBRARY.CONSTRAINT_1 PRIMARY KEY(ID); 
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
INSERT INTO LIBRARY.BOOK(ID, TITLE) VALUES
(1, 'The DevOps Handbook');       
CREATE CACHED TABLE LIBRARY.LOAN(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E,
    BOOK INT NOT NULL,
    BORROWER INT NOT NULL,
    BORROW_DATE DATE NOT NULL
);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_2 PRIMARY KEY(ID); 
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
INSERT INTO LIBRARY.LOAN(ID, BOOK, BORROWER, BORROW_DATE) VALUES
(1, 1, 1, DATE '2018-01-01');               
CREATE CACHED TABLE AUTH.USER(
    ID INT DEFAULT (NEXT VALUE FOR AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722) NOT NULL NULL_TO_DEFAULT SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722,
    NAME VARCHAR(100) NOT NULL,
    PASSWORD_HASH VARCHAR(100)
);               
ALTER TABLE AUTH.USER ADD CONSTRAINT AUTH.CONSTRAINT_2 PRIMARY KEY(ID);       
-- 0 +/- SELECT COUNT(*) FROM AUTH.USER;      
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23B FOREIGN KEY(BORROWER) REFERENCES LIBRARY.BORROWER(ID) NOCHECK; 
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23 FOREIGN KEY(BOOK) REFERENCES LIBRARY.BOOK(ID) NOCHECK;          



================================================
FILE: src/integration_test/resources/db_sample_files/v2_one_user.sql
================================================
;             
CREATE USER IF NOT EXISTS SA SALT '7ab557eb69745223' HASH '8a3855f1eb198976108dae4d0d5cdf5eb907e73321db99c043737af0124852f6' ADMIN;           
CREATE SCHEMA IF NOT EXISTS ADMINISTRATIVE AUTHORIZATION SA;  
CREATE SCHEMA IF NOT EXISTS AUTH AUTHORIZATION SA;            
CREATE SCHEMA IF NOT EXISTS LIBRARY AUTHORIZATION SA;         
CREATE SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722 START WITH 2 BELONGS_TO_TABLE;      
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B START WITH 1 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0 START WITH 1 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E START WITH 1 BELONGS_TO_TABLE;   
CREATE CACHED TABLE ADMINISTRATIVE."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE ADMINISTRATIVE."flyway_schema_history" ADD CONSTRAINT ADMINISTRATIVE."flyway_schema_history_pk" PRIMARY KEY("installed_rank");    
-- 3 +/- SELECT COUNT(*) FROM ADMINISTRATIVE."flyway_schema_history";         
INSERT INTO ADMINISTRATIVE."flyway_schema_history"("installed_rank", "version", "description", "type", "script", "checksum", "installed_by", "installed_on", "execution_time", "success") VALUES
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, 'SA', TIMESTAMP '2019-01-31 17:35:59.667', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, 'SA', TIMESTAMP '2019-01-31 17:35:59.691', 3, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1767572289, 'SA', TIMESTAMP '2019-01-31 17:35:59.706', 9, TRUE);         
CREATE INDEX ADMINISTRATIVE."flyway_schema_history_s_idx" ON ADMINISTRATIVE."flyway_schema_history"("success");               
CREATE CACHED TABLE LIBRARY.BORROWER(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B,
    NAME VARCHAR(100) NOT NULL
);   
ALTER TABLE LIBRARY.BORROWER ADD CONSTRAINT LIBRARY.CONSTRAINT_A PRIMARY KEY(ID);             
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
CREATE CACHED TABLE LIBRARY.BOOK(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0,
    TITLE VARCHAR(100) NOT NULL
);      
ALTER TABLE LIBRARY.BOOK ADD CONSTRAINT LIBRARY.CONSTRAINT_1 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
CREATE CACHED TABLE LIBRARY.LOAN(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E,
    BOOK INT NOT NULL,
    BORROWER INT NOT NULL,
    BORROW_DATE DATE NOT NULL
);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_2 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
CREATE CACHED TABLE AUTH.USER(
    ID INT DEFAULT (NEXT VALUE FOR AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722) NOT NULL NULL_TO_DEFAULT SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722,
    NAME VARCHAR(100) NOT NULL,
    PASSWORD_HASH VARCHAR(100)
);               
ALTER TABLE AUTH.USER ADD CONSTRAINT AUTH.CONSTRAINT_2 PRIMARY KEY(ID);       
-- 1 +/- SELECT COUNT(*) FROM AUTH.USER;      
INSERT INTO AUTH.USER(ID, NAME, PASSWORD_HASH) VALUES
(1, 'alice', NULL);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23B FOREIGN KEY(BORROWER) REFERENCES LIBRARY.BORROWER(ID) NOCHECK; 
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23 FOREIGN KEY(BOOK) REFERENCES LIBRARY.BOOK(ID) NOCHECK;          



================================================
FILE: src/integration_test/resources/db_sample_files/v2_three_books_three_borrowers.sql
================================================
;             
CREATE USER IF NOT EXISTS "" SALT '' HASH '' ADMIN;           
CREATE SCHEMA IF NOT EXISTS "ADMINISTRATIVE" AUTHORIZATION "";
CREATE SCHEMA IF NOT EXISTS "AUTH" AUTHORIZATION "";          
CREATE SCHEMA IF NOT EXISTS "LIBRARY" AUTHORIZATION "";       
CREATE SEQUENCE "AUTH"."SYSTEM_SEQUENCE_6608652E_F4BC_46BC_A456_0FCA964E591D" START WITH 1 BELONGS_TO_TABLE;  
CREATE SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_A08E4C08_164A_4348_9A78_C229789BAEF3" START WITH 4 BELONGS_TO_TABLE;               
CREATE SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_A416DDFE_1291_4BF1_B8C0_7F3A8EC53F92" START WITH 4 BELONGS_TO_TABLE;               
CREATE SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_C4EA4E4C_FC2D_4DF9_9937_3D93A483B1EE" START WITH 1 BELONGS_TO_TABLE;               
CREATE CACHED TABLE "ADMINISTRATIVE"."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE "ADMINISTRATIVE"."flyway_schema_history" ADD CONSTRAINT "ADMINISTRATIVE"."flyway_schema_history_pk" PRIMARY KEY("installed_rank");
-- 4 +/- SELECT COUNT(*) FROM ADMINISTRATIVE.flyway_schema_history;           
INSERT INTO "ADMINISTRATIVE"."flyway_schema_history" VALUES
(-1, NULL, '<< Flyway Schema History table created >>', 'TABLE', '', NULL, '', TIMESTAMP '2020-04-14 22:19:07.888525', 0, TRUE),
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, '', TIMESTAMP '2020-04-14 22:19:07.888525', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, '', TIMESTAMP '2020-04-14 22:19:07.919772', 2, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1047360475, '', TIMESTAMP '2020-04-14 22:19:07.95102', 6, TRUE);          
CREATE INDEX "ADMINISTRATIVE"."flyway_schema_history_s_idx" ON "ADMINISTRATIVE"."flyway_schema_history"("success");           
CREATE CACHED TABLE "LIBRARY"."BORROWER"(
    "ID" INT DEFAULT (NEXT VALUE FOR "LIBRARY"."SYSTEM_SEQUENCE_A08E4C08_164A_4348_9A78_C229789BAEF3") NOT NULL NULL_TO_DEFAULT SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_A08E4C08_164A_4348_9A78_C229789BAEF3",
    "NAME" VARCHAR(100) NOT NULL
);   
ALTER TABLE "LIBRARY"."BORROWER" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_A" PRIMARY KEY("ID");   
-- 3 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
INSERT INTO "LIBRARY"."BORROWER" VALUES
(1, 'alice'),
(2, 'bob'),
(3, 'carol');            
CREATE CACHED TABLE "LIBRARY"."BOOK"(
    "ID" INT DEFAULT (NEXT VALUE FOR "LIBRARY"."SYSTEM_SEQUENCE_A416DDFE_1291_4BF1_B8C0_7F3A8EC53F92") NOT NULL NULL_TO_DEFAULT SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_A416DDFE_1291_4BF1_B8C0_7F3A8EC53F92",
    "TITLE" VARCHAR(100) NOT NULL
);      
ALTER TABLE "LIBRARY"."BOOK" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_1" PRIMARY KEY("ID");       
-- 3 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
INSERT INTO "LIBRARY"."BOOK" VALUES
(1, 'a'),
(2, 'b'),
(3, 'c');          
CREATE CACHED TABLE "LIBRARY"."LOAN"(
    "ID" INT DEFAULT (NEXT VALUE FOR "LIBRARY"."SYSTEM_SEQUENCE_C4EA4E4C_FC2D_4DF9_9937_3D93A483B1EE") NOT NULL NULL_TO_DEFAULT SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_C4EA4E4C_FC2D_4DF9_9937_3D93A483B1EE",
    "BOOK" INT NOT NULL,
    "BORROWER" INT NOT NULL,
    "BORROW_DATE" DATE NOT NULL
);
ALTER TABLE "LIBRARY"."LOAN" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_2" PRIMARY KEY("ID");       
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
CREATE CACHED TABLE "AUTH"."USER"(
    "ID" INT DEFAULT (NEXT VALUE FOR "AUTH"."SYSTEM_SEQUENCE_6608652E_F4BC_46BC_A456_0FCA964E591D") NOT NULL NULL_TO_DEFAULT SEQUENCE "AUTH"."SYSTEM_SEQUENCE_6608652E_F4BC_46BC_A456_0FCA964E591D",
    "NAME" VARCHAR(100) NOT NULL,
    "PASSWORD_HASH" VARCHAR(100)
);             
ALTER TABLE "AUTH"."USER" ADD CONSTRAINT "AUTH"."CONSTRAINT_2" PRIMARY KEY("ID");             
-- 0 +/- SELECT COUNT(*) FROM AUTH.USER;      
ALTER TABLE "LIBRARY"."LOAN" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_23B" FOREIGN KEY("BORROWER") REFERENCES "LIBRARY"."BORROWER"("ID") ON DELETE CASCADE NOCHECK;               
ALTER TABLE "LIBRARY"."LOAN" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_23" FOREIGN KEY("BOOK") REFERENCES "LIBRARY"."BOOK"("ID") ON DELETE CASCADE NOCHECK;        



================================================
FILE: src/main/java/com/coveros/training/README.txt
================================================
These different folders describe the different feature areas of the Demo application.

authentication   :  things like usernames, passwords, accouunts
cartesianproduct :  calculating the cartesian product of multiple sets
expenses         :  calculating restaurant expenses
helpers          :  cross-functional helper classes
library          :  books, borrowers, lending
mathematics      :  various math functionality
persistence      :  provides database access
tomcat           :  configures Tomcat


================================================
FILE: src/main/java/com/coveros/training/authentication/LoginServlet.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Provides an API endpoint for login.
 * <p>
 * A user (librarian) enters their username and password to authenticate.
 * </p>
 */
@WebServlet(name = "LoginServlet", urlPatterns = {"/login"}, loadOnStartup = 1)
public class LoginServlet extends HttpServlet {

    private static final long serialVersionUID = 7302828964216520580L;
    private static final Logger logger = LoggerFactory.getLogger(LoginServlet.class);
    static LoginUtils loginUtils = new LoginUtils();

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        String username = StringUtils.makeNotNullable(request.getParameter("username"));
        request.setAttribute("username", username);

        String password = StringUtils.makeNotNullable(request.getParameter("password"));
        request.setAttribute("password", password);

        String responseText;

        if (username.isEmpty()) {
            responseText = "no username provided";
        } else if (password.isEmpty()) {
            responseText = "no password provided";
        } else {
            logger.info("received request to authenticate a user, {}", username);

            final boolean userRegistered = loginUtils.isUserRegistered(username, password);
            responseText = userRegistered ? "access granted" : "access denied";
        }

        request.setAttribute("result", responseText);
        request.setAttribute("return_page", "library.html");
        ServletUtils.forwardToResult(request, response, logger);
    }

}




================================================
FILE: src/main/java/com/coveros/training/authentication/LoginUtils.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.helpers.CheckUtils;
import com.coveros.training.persistence.IPersistenceLayer;
import com.coveros.training.persistence.PersistenceLayer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Provides business-layer for determining if entered credentials qualify for authentication
 */
public class LoginUtils {

    private static final Logger logger = LoggerFactory.getLogger(LoginUtils.class);
    private final IPersistenceLayer persistenceLayer;

    public LoginUtils(IPersistenceLayer persistenceLayer) {
        this.persistenceLayer = persistenceLayer;
    }

    public LoginUtils() {
        this(new PersistenceLayer());
    }

    /**
     * Determine if input is correct credentials for a registered user.
     * @return true if the credentials are valid, false otherwise
     */
    public boolean isUserRegistered(String username, String password) {
        CheckUtils.StringMustNotBeNullOrEmpty(username, password);
        logger.info("checking if credentials for {} are valid for login", username);
        boolean isValid = persistenceLayer.areCredentialsValid(username, password).orElse(false);
        if (isValid) {
            logger.info("credentials for {} are valid - granting access", username);
        } else {
            logger.info("credentials for {} were invalid - denying access", username);
        }
        return isValid;
    }

    public static LoginUtils createEmpty() {
        return new LoginUtils(PersistenceLayer.createEmpty());
    }

    public boolean isEmpty() {
        return persistenceLayer.isEmpty();
    }

}



================================================
FILE: src/main/java/com/coveros/training/authentication/package-info.java
================================================
/**
 * Authentication mechanisms - usernames, passwords, etc.
 */
package com.coveros.training.authentication;


================================================
FILE: src/main/java/com/coveros/training/authentication/RegisterServlet.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.authentication.domainobjects.RegistrationResult;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Provides an API endpoint to register a new user, recording their username and (a hash of their) password
 */
@WebServlet(name = "RegisterServlet", urlPatterns = {"/register"}, loadOnStartup = 1)
public class RegisterServlet extends HttpServlet {

    private static final String PASSWORD_PARAM = "password";
    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(RegisterServlet.class);
    private static final String USERNAME_PARAM = "username";
    static RegistrationUtils registrationUtils = new RegistrationUtils();

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        String username = StringUtils.makeNotNullable(request.getParameter(USERNAME_PARAM));
        request.setAttribute(USERNAME_PARAM, username);

        String password = StringUtils.makeNotNullable(request.getParameter(PASSWORD_PARAM));
        request.setAttribute(PASSWORD_PARAM, password);

        String responseText;

        if (username.isEmpty()) {
            responseText = "no username provided";
        } else if (password.isEmpty()) {
            responseText = "no password provided";
        } else {

            logger.info("received request to register a user, {}", username);

            RegistrationResult registrationResult = registrationUtils.processRegistration(username, password);

            responseText = registrationResult.toPrettyString();
        }

        request.setAttribute("result", responseText);
        request.setAttribute("return_page", "library.html");
        forwardToResult(request, response, logger);
    }

    /**
     * Wrapping a static method call for testing.
     */
    private void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        ServletUtils.forwardToResult(request, response, logger);
    }

}




================================================
FILE: src/main/java/com/coveros/training/authentication/RegistrationUtils.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.authentication.domainobjects.PasswordResult;
import com.coveros.training.authentication.domainobjects.RegistrationResult;
import com.coveros.training.helpers.CheckUtils;
import com.coveros.training.persistence.IPersistenceLayer;
import com.coveros.training.persistence.PersistenceLayer;
import me.gosimple.nbvcxz.Nbvcxz;
import me.gosimple.nbvcxz.scoring.Result;
import me.gosimple.nbvcxz.scoring.TimeEstimate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.coveros.training.authentication.domainobjects.PasswordResultEnums.EMPTY_PASSWORD;
import static com.coveros.training.authentication.domainobjects.PasswordResultEnums.*;
import static com.coveros.training.authentication.domainobjects.RegistrationStatusEnums.*;
import static com.coveros.training.helpers.CheckUtils.StringMustNotBeNullOrEmpty;

/**
 * Provides logic for registering a new user
 */
public class RegistrationUtils {

    private static final Logger logger = LoggerFactory.getLogger(RegistrationUtils.class);

    private final IPersistenceLayer persistenceLayer;

    public RegistrationUtils(IPersistenceLayer persistenceLayer) {
        this.persistenceLayer = persistenceLayer;
    }

    public RegistrationUtils() {
        this(new PersistenceLayer());
    }

    /**
     * A business process to evaluate an attempt to register a new user.
     * <ol>
     *     <li>Make sure the username and password aren't null or empty</li>
     *     <li>Make sure the user isn't already in the database</li>
     *     <li>Check if the password is sufficiently complex to be secure</li>
     *     <li>Create a new account for this user, saving the user's credentials</li>
     * </ol>
     */
    public RegistrationResult processRegistration(String username, String password) {
        logger.info("Starting registration");
        StringMustNotBeNullOrEmpty(username);
        StringMustNotBeNullOrEmpty(password);

        if (isUserInDatabase(username)) {
            logger.info("cannot register this user - they are already registered");
            return new RegistrationResult(false, ALREADY_REGISTERED);
        }
        // at this point we know the user is not yet registered in the database

        // then we check if the password is good.
        final PasswordResult passwordResult = isPasswordGood(password);
        if (passwordResult.status != SUCCESS) {
            logger.info("user provided a bad password during registration");
            return new RegistrationResult(false, BAD_PASSWORD, passwordResult.toPrettyString());
        }

        // at this point, we feel assured it's ok to save to the database.
        saveToDatabase(username, password);
        logger.info("saving new user, {}, to database", username);
        return new RegistrationResult(true, SUCCESSFULLY_REGISTERED);
    }

    public static RegistrationUtils createEmpty() {
        return new RegistrationUtils(PersistenceLayer.createEmpty());
    }

    public boolean isEmpty() {
        return persistenceLayer.isEmpty();
    }

    /**
     * Whether we qualify a password as good.
     *
     * <p>
     *     To summarize - we check the following here:
     *  </p>
     *  <ol>
     *    <li>The password must not be empty</li>
     *    <li>it must not be too short (less than 6 characters)</li>
     *    <li>it cannot be too long (more than 100 characters - this is because the framework</li>
     *    <li>analysis slows to a crawl with more than 100 characters)</li>
     *    <li>Whether the entropy framework we're using considers the password good.</li>
     * </ol>
     *  <p>See {@link PasswordResult}</p>
     */
    public static PasswordResult isPasswordGood(String password) {
        if (password.isEmpty()) {
            logger.info("password was empty");
            return PasswordResult.createDefault(EMPTY_PASSWORD);
        }
        StringMustNotBeNullOrEmpty(password);

        final boolean isTooSmall = password.length() < 10;
        if (isTooSmall) {
            logger.info("password was too short");
            return PasswordResult.createDefault(TOO_SHORT);
        }
        CheckUtils.mustBeTrueAtThisPoint(isTooSmall == false,
                "At this point, the password cannot be too small");

        final boolean isTooLarge = password.length() > 100;
        if (isTooLarge) {
            logger.info("password was too long");
            return PasswordResult.createDefault(TOO_LONG);
        }
        CheckUtils.mustBeTrueAtThisPoint(isTooLarge == false,
                "At this point, the password cannot be too large");

        // Nbvcxz is a tool that tests entropy on passwords
        // See github.com/GoSimpleLLC/nbvcxz
        final Nbvcxz nbvcxz = new Nbvcxz();
        final Result result = nbvcxz.estimate(password);
        final String suggestions = String.join(";", result.getFeedback().getSuggestion());

        final Double entropy = result.getEntropy();
        CheckUtils.mustBeTrueAtThisPoint(entropy > 0d, "There must be *some* entropy at this point, more than 0");

        String timeToCrackOff = TimeEstimate.getTimeToCrackFormatted(result, "OFFLINE_BCRYPT_12");
        String timeToCrackOn = TimeEstimate.getTimeToCrackFormatted(result, "ONLINE_THROTTLED");
        if (!result.isMinimumEntropyMet()) {
            logger.info("minimum entropy for password was not met");
            return new PasswordResult(INSUFFICIENT_ENTROPY, entropy, timeToCrackOff, timeToCrackOn, suggestions);
        } else {
            logger.info("password met required entropy");
            return new PasswordResult(SUCCESS, entropy, timeToCrackOff, timeToCrackOn, result.getFeedback().getResult());
        }
    }

    public boolean isUserInDatabase(String username) {
        return persistenceLayer.searchForUserByName(username).isPresent();
    }

    private void saveToDatabase(String username, String password) {
        final long userId = persistenceLayer.saveNewUser(username);
        persistenceLayer.updateUserWithPassword(userId, password);
    }

}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/package-info.java
================================================
/**
 * Domain objects related to authentication
 */
package com.coveros.training.authentication.domainobjects;


================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/PasswordResult.java
================================================
package com.coveros.training.authentication.domainobjects;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


/**
 * This contains the results of checking the complexity of a given
 * password - that is, how good of a password, how secure, is it?
 * See {@link com.coveros.training.authentication.RegistrationUtils#isPasswordGood}
 * for the calculation that generates this.
 */
public final class PasswordResult {

    public final PasswordResultEnums status;
    private final Double entropy;
    public final String timeToCrackOffline;
    private final String timeToCrackOnline;
    private final String message;

    private static final String BASIC_PASSWORD_CHECKS_FAILED = "BASIC_PASSWORD_CHECKS_FAILED";

    public PasswordResult(PasswordResultEnums status,
                          Double entropy,
                          String timeToCrackOffline,
                          String timeToCrackOnline,
                          String message) {

        this.status = status;
        this.entropy = entropy;
        this.timeToCrackOffline = timeToCrackOffline;
        this.timeToCrackOnline = timeToCrackOnline;
        this.message = message;
    }

    /**
     * Return this if any of our very basic attempt to validate
     * the password field fail.  Like passing an empty string, for example.
     */
    public static PasswordResult createDefault(PasswordResultEnums resultStatus) {
        return new PasswordResult(resultStatus, 0d, "", "", BASIC_PASSWORD_CHECKS_FAILED);
    }

    @Override
    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        PasswordResult rhs = (PasswordResult) obj;
        return new EqualsBuilder()
                .append(status, rhs.status)
                .append(entropy, rhs.entropy)
                .append(timeToCrackOffline, rhs.timeToCrackOffline)
                .append(timeToCrackOnline, rhs.timeToCrackOnline)
                .append(message, rhs.message)
                .isEquals();
    }

    @Override
    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(15, 33).
                append(status).
                append(entropy).
                append(timeToCrackOffline).
                append(timeToCrackOnline).
                append(message).
                toHashCode();
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public final String toPrettyString() {
        return String.format("status: %s%n", status) +
                String.format("entropy: %s%n", entropy) +
                String.format("time to crack offline: %s%n", timeToCrackOffline) +
                String.format("time to crack online: %s%n", timeToCrackOnline) +
                String.format("Nbvcxz response: %s%n", message);
    }

    /**
     * Return this to represent an empty result.  Used primarily
     * when we are initializing a variable and don't want to use null.
     */
    public static PasswordResult createEmpty() {
        return new PasswordResult(PasswordResultEnums.NULL, 0d, "", "", "");
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }

}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/PasswordResultEnums.java
================================================
package com.coveros.training.authentication.domainobjects;

/**
 * All the values currently possible for our
 * assessment of a potential password
 */
public enum PasswordResultEnums {
    TOO_SHORT,

    /**
     * ironic, I know, but if it's too long we're open to DOS attacks.
     * It takes too long to process extremely long passwords.
     */
    TOO_LONG,
    EMPTY_PASSWORD,

    /**
     * as measured by a tool.  See implementation where this is used.
     */
    INSUFFICIENT_ENTROPY,
    SUCCESS,

    /**
     * This is only used for empty password results.  See {@link PasswordResult#createEmpty()}
     */
    NULL
}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/RegistrationResult.java
================================================
package com.coveros.training.authentication.domainobjects;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * This class holds detailed data on the results of
 * trying to register a new user.  See {@link com.coveros.training.authentication.RegistrationUtils#processRegistration}
 */
public final class RegistrationResult {

    public final boolean wasSuccessfullyRegistered;
    public final RegistrationStatusEnums status;
    private final String message;

    public RegistrationResult(boolean wasSuccessfullyRegistered, RegistrationStatusEnums status, String message) {
        this.wasSuccessfullyRegistered = wasSuccessfullyRegistered;
        this.status = status;
        this.message = message;
    }

    public RegistrationResult(boolean wasSuccessfullyRegistered, RegistrationStatusEnums status) {
        this(wasSuccessfullyRegistered, status, "");
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        RegistrationResult rhs = (RegistrationResult) obj;
        return new EqualsBuilder()
                .append(wasSuccessfullyRegistered, rhs.wasSuccessfullyRegistered)
                .append(status, rhs.status)
                .append(message, rhs.message)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(15, 33).
                append(wasSuccessfullyRegistered).
                append(status).
                append(message).
                toHashCode();
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public final String toPrettyString() {
        return String.format("successfully registered: %s%n", wasSuccessfullyRegistered) +
                String.format("status: %s%n", status) +
                String.format("message: %n%n%s%n", message);
    }

    public static RegistrationResult createEmpty() {
        return new RegistrationResult(false, RegistrationStatusEnums.EMPTY);
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }
}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/RegistrationStatusEnums.java
================================================
package com.coveros.training.authentication.domainobjects;

/**
 * All the values possible for the results of an
 * attempted registration
 */
public enum RegistrationStatusEnums {
    ALREADY_REGISTERED,
    EMPTY_USERNAME,
    EMPTY_PASSWORD,
    SUCCESSFULLY_REGISTERED,
    BAD_PASSWORD,
    EMPTY // represents the state of no status.  Used by the empty registration result.

}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/User.java
================================================
package com.coveros.training.authentication.domainobjects;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


/**
 * Represents the data that we consider full and complete to define
 * a particular user.  This coincides neatly with the details in the database.
 */
public final class User {

    /**
     * The username of the user
     */
    public final String name;

    /**
     * The identifier of the user in the database
     */
    public final long id;

    public User(String name, long id) {
        this.name = name;
        this.id = id;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        User rhs = (User) obj;
        return new EqualsBuilder()
                .append(id, rhs.id)
                .append(name, rhs.name)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(19, 3).
                append(name).
                append(id).
                toHashCode();
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public static User createEmpty() {
        return new User("", 0);
    }

    public boolean isEmpty() {
        return this.equals(User.createEmpty());
    }

}



================================================
FILE: src/main/java/com/coveros/training/cartesianproduct/CartesianProduct.java
================================================
package com.coveros.training.cartesianproduct;

import java.util.Set;

public class CartesianProduct {

    public static <T> String calculate(final Set<T> setOfSets) {
        return "";
    }
}



================================================
FILE: src/main/java/com/coveros/training/cartesianproduct/package-info.java
================================================
/**
 * Calculates the cartesian product of multiple sets.
 *<p>
 * See the feature file for more detail, in "cartesianproduct.feature"
 * </p>
 */
package com.coveros.training.cartesianproduct;


================================================
FILE: src/main/java/com/coveros/training/expenses/AlcoholCalculator.java
================================================
package com.coveros.training.expenses;

public class AlcoholCalculator {
    public static AlcoholResult calculate(DinnerPrices dinnerPrices) {
        return AlcoholResult.returnEmpty();
    }
}



================================================
FILE: src/main/java/com/coveros/training/expenses/AlcoholResult.java
================================================
package com.coveros.training.expenses;

public class AlcoholResult {
    private final Double foodPrice;
    private final Double alcoholPrice;
    private final Double foodRatio;

    public AlcoholResult(Double foodPrice, Double alcoholPrice, Double foodRatio) {
        this.foodPrice = foodPrice;
        this.alcoholPrice = alcoholPrice;
        this.foodRatio = foodRatio;
    }

    public static AlcoholResult returnEmpty() {
        return new AlcoholResult(0d,0d,0d);
    }
}



================================================
FILE: src/main/java/com/coveros/training/expenses/DinnerPrices.java
================================================
package com.coveros.training.expenses;

public class DinnerPrices {
    private final double subTotal;
    private final double foodTotal;
    private final double tip;
    private final double tax;

    public DinnerPrices(double subTotal, double foodTotal, double tip, double tax){
        this.subTotal = subTotal;
        this.foodTotal = foodTotal;
        this.tip = tip;
        this.tax = tax;
    }
}



================================================
FILE: src/main/java/com/coveros/training/expenses/package-info.java
================================================
/**
 * Calculates restaurant expenses that include alcohol, per government accounting rules.
 */
package com.coveros.training.expenses;


================================================
FILE: src/main/java/com/coveros/training/helpers/AssertionException.java
================================================
package com.coveros.training.helpers;

/**
 * This exception is thrown whenever something is
 * set to be true as an invariant, but isn't actually true.
 * See https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science
 */
public class AssertionException extends RuntimeException {

    public AssertionException(String message) {
        super(message);
    }
}



================================================
FILE: src/main/java/com/coveros/training/helpers/CheckUtils.java
================================================
package com.coveros.training.helpers;

/**
 * helper methods to assert that certain things in our code are true,
 * or else we throw an exception.
 */
public class CheckUtils {

    private CheckUtils() {
        // using a private constructor to hide the implicit public one.
    }

    /**
     * Asserts that the integer value received is 1 or above.
     * @param parameter a value to check for being positive
     * @throws IllegalArgumentException if the input isn't a positive integer
     */
    public static void IntParameterMustBePositive(long parameter) {
        if (parameter <= 0) {
            throw new IllegalArgumentException("int value must be 1 or above.");
        }
    }

    /**
     * Makes sure the input value is a valid string of length 1 or greater
     * @param values the strings to check
     * @throws IllegalArgumentException if the string is null or empty
     */
    public static void StringMustNotBeNullOrEmpty(String ... values) {
        for (String value: values) {
            if(value == null || value.isEmpty()) {
                throw new IllegalArgumentException("string must not be null or empty at this point");
            }
        }
    }

    /**
     * Used as a general invariant declaration in our code
     * @param mustBeTrue this is a predicate that must be true,
     *                   otherwise we'll throw an {@link AssertionException}
     * @param message the message to be passed along as part of the exception
     */
    public static void mustBeTrueAtThisPoint(boolean mustBeTrue, String message) {
        if (! mustBeTrue) {
            throw new AssertionException(message);
        }
    }

}



================================================
FILE: src/main/java/com/coveros/training/helpers/package-info.java
================================================
/**
 * Various helper classes that are used throughout the application.
 */
package com.coveros.training.helpers;


================================================
FILE: src/main/java/com/coveros/training/helpers/ServletUtils.java
================================================
package com.coveros.training.helpers;


import org.slf4j.Logger;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * These helper methods help to remove duplication in
 * the servlets.  See the methods for more detail on
 * what they do.
 */
public class ServletUtils {

    public static final String RESTFUL_RESULT_JSP = "restfulresult.jsp";
    public static final String RESULT_JSP = "result.jsp";

    private ServletUtils() {
        // using a private constructor to hide the implicit public one.
    }

    /**
     * A user posts information in the regular web application, and we react by forwarding them to another web page.
     * See result.jsp to get an idea.
     */
    public static void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        try {
            request.getRequestDispatcher(RESULT_JSP).forward(request, response);
        } catch (Exception ex) {
            logger.error(String.format("failed during forward: %s", ex));
        }
    }

    /**
     * A user has made a RESTful web API call, and we are responding with the minimal syntax.
     * See restfulresult.jsp to get an idea.
     */
    public static void forwardToRestfulResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        try {
            request.getRequestDispatcher(RESTFUL_RESULT_JSP).forward(request, response);
        } catch (Exception ex) {
            logger.error(String.format("failed during forward: %s", ex));
        }
    }
}



================================================
FILE: src/main/java/com/coveros/training/helpers/StringUtils.java
================================================
package com.coveros.training.helpers;


import org.apache.logging.log4j.core.util.JsonUtils;
import org.checkerframework.checker.nullness.qual.Nullable;



/**
 * Some simple helper methods for Strings.
 */
public class StringUtils {

    private StringUtils() {
        // using a private constructor to hide the implicit public one.
    }

    /**
     * checks the String you pass in; if it's null, return an empty String.
     * Otherwise, return the unchanged string.
     */
    public static String makeNotNullable(@Nullable String s) {
        return s == null ? "" : s;
    }


    // a table of some of the values that may need to be
    // escaped in JSON strings
    static final byte SINGLE_QUOTE    = 39;
    static final byte DOUBLE_QUOTE    = 34;
    static final byte BACKSLASH       = 92;
    static final byte NEW_LINE        = 10;
    static final byte CARRIAGE_RETURN = 13;
    static final byte TAB             = 9;
    static final byte BACKSPACE       = 8;
    static final byte FORM_FEED       = 12;

    /**
     * Given a string, replaces characters so that it is safe to use
     * as JSON
     * @param value String value to convert
     * @return a properly escaped string, usable in JSON
     */
    public static String escapeForJson(String value) {
        StringBuilder sb = new StringBuilder();
        JsonUtils.quoteAsString(value, sb);
        return sb.toString();
    }


}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryBookListAvailableServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.helpers.ServletUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Web API to list books available for borrowing.
 */
@MultipartConfig
@WebServlet(name = "LibraryBookListAvailableSearch", urlPatterns = {"/listavailable"}, loadOnStartup = 1)
public class LibraryBookListAvailableServlet extends HttpServlet {

    private static final long serialVersionUID = 3219972716578253134L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryBookListAvailableServlet.class);
    public static final String RESULT = "result";
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) {
        final List<Book> books = libraryUtils.listAvailableBooks();
        logger.info("Received request for all available books");
        String result;
        if (books.isEmpty()) {
            result = "No books exist in the database";
        } else {
            final String allBooks = books.stream().map(Book::toOutputString).collect(Collectors.joining(","));
            result = "[" + allBooks + "]";
        }
        request.setAttribute(RESULT, result);

        ServletUtils.forwardToRestfulResult(request, response, logger);
    }


}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryBookListSearchServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Web API to list all books or search books by id / title
 */
@MultipartConfig
@WebServlet(name = "LibraryBookListSearch", urlPatterns = {"/book"}, loadOnStartup = 1)
public class LibraryBookListSearchServlet extends HttpServlet {

    private static final long serialVersionUID = -56598540573518235L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryBookListSearchServlet.class);
    public static final String RESULT = "result";
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) {
        final String idString = StringUtils.makeNotNullable(request.getParameter("id"));
        final String title = StringUtils.makeNotNullable(request.getParameter("title"));

        String result;
        if (idString.isEmpty() && title.isEmpty()) {
            result = listAllBooks();
        } else if (! idString.isEmpty() && title.isEmpty()) {
            result = searchById(idString);
        } else if (idString.isEmpty() ) {
            result = searchByTitle(title);
        } else  {  // both id and title have an input
            logger.info("Received request for books, by title and id - id {} and title {}", idString, title);
            result = "Error: please search by either title or id, not both";
        }
        request.setAttribute(RESULT, result);

        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    private String searchByTitle(String title) {
        logger.info("Received request for books, name requested - searching for book by title {}", title);
        final Book book = libraryUtils.searchForBookByTitle(title);
        if (book.isEmpty()) {
            return "No books found with a title of " + title;
        }
        return "[" + book.toOutputString() + "]";
    }

    private String searchById(String idString) {
        logger.info("Received request for books, id requested - searching for book by id {}", idString);
        int id;
        try {
            id = Integer.parseInt(idString);
        } catch (NumberFormatException ex) {
            return "Error: could not parse the book id as an integer";
        }
        final Book book = libraryUtils.searchForBookById(id);
        if (book.isEmpty()) {
            return "No books found with an id of " + idString;
        }
        return "[" + book.toOutputString() + "]";
    }

    private String listAllBooks() {
        logger.info("Received request for books, no title or id requested - listing all books");
        final List<Book> books = libraryUtils.listAllBooks();
        final String allBooks = books.stream().map(Book::toOutputString).collect(Collectors.joining(","));
        if (allBooks.isEmpty()) {
            return "No books exist in the database";
        }
        return "[" + allBooks + "]";
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryBorrowerListSearchServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Web API to list all borrowers or search borrowers by id / name
 */
@MultipartConfig
@WebServlet(name = "LibraryBorrowerListSearch", urlPatterns = {"/borrower"}, loadOnStartup = 1)
public class LibraryBorrowerListSearchServlet extends HttpServlet {

    private static final long serialVersionUID = -7374339112812653844L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryBorrowerListSearchServlet.class);
    public static final String RESULT = "result";
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) {
        final String idString = StringUtils.makeNotNullable(request.getParameter("id"));
        final String name = StringUtils.makeNotNullable(request.getParameter("name"));

        String result;
        if (idString.isEmpty() && name.isEmpty()) {
            result = listAllBorrowers();
        } else if (! idString.isEmpty() && name.isEmpty()) {
            result = searchById(idString);
        } else if (idString.isEmpty() ) {
            result = searchByName(name);
        } else  {  // both id and name have an input
            logger.info("Received request for borrowers, by name and id - id {} and name {}", idString, name);
            result = "Error: please search by either name or id, not both";
        }
        request.setAttribute(RESULT, result);

        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    private String searchByName(final String name) {
        logger.info("Received request for borrowers, name requested - searching for borrower by name {}", name);
        final Borrower borrower = libraryUtils.searchForBorrowerByName(name);
        if (borrower.isEmpty()) {
            return "No borrowers found with a name of " + name;
        }
        return "["+borrower.toOutputString()+"]";
    }

    private String searchById(final String idString) {
        logger.info("Received request for borrowers, id requested - searching for borrower by id {}", idString);
        int id;
        try {
            id = Integer.parseInt(idString);
        } catch (final NumberFormatException ex) {
            return "Error: could not parse the borrower id as an integer";
        }
        final Borrower borrower = libraryUtils.searchForBorrowerById(id);
        if (borrower.isEmpty()) {
            return "No borrowers found with an id of " + idString;
        }
        return "["+borrower.toOutputString()+"]";
    }

    private String listAllBorrowers() {
        logger.info("Received request for borrowers, no name or id requested - listing all borrowers");
        final List<Borrower> borrowers = libraryUtils.listAllBorrowers();
        final String allBorrowers = borrowers.stream().map(Borrower::toOutputString).collect(Collectors.joining(","));
        if (allBorrowers.isEmpty()) {
            return "No borrowers exist in the database";
        }
        return "["+allBorrowers+"]";
    }


}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryLendServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.sql.Date;
import java.time.LocalDate;

/**
 * Web API to lend a book to a borrower
 */
@WebServlet(name = "LibraryLendServlet", urlPatterns = {"/lend"}, loadOnStartup = 1)
public class LibraryLendServlet extends HttpServlet {

    private static final long serialVersionUID = -6507483398690297645L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryLendServlet.class);
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        LibraryActionResults libraryActionResults;

        final String book = StringUtils.makeNotNullable(request.getParameter("book"));
        request.setAttribute("book", book);

        final String borrower = StringUtils.makeNotNullable(request.getParameter("borrower"));
        request.setAttribute("borrower", borrower);

        if (book.isEmpty()) {
            libraryActionResults = LibraryActionResults.NO_BOOK_TITLE_PROVIDED;
        } else if (borrower.isEmpty()) {
            libraryActionResults = LibraryActionResults.NO_BORROWER_PROVIDED;
        } else {
            final Date now = getDateNow();
            request.setAttribute("date", now.toString());

            logger.info("received request to lend a book, {}, to {}", book, borrower);

            libraryActionResults = libraryUtils.lendBook(book, borrower, now);
        }
        request.setAttribute("result", libraryActionResults.toString());
        request.setAttribute("return_page", "library.html");
        ServletUtils.forwardToResult(request, response, logger);
    }

    /**
     * Wrapping the call to get a date for now,
     * so it's easier to stub for testing.
     */
    Date getDateNow() {
        return Date.valueOf(LocalDate.now());
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryRegisterBookServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Web API to register a new book with the library
 */
@WebServlet(name = "LibraryRegisterBookServlet", urlPatterns = {"/registerbook"}, loadOnStartup = 1)
public class LibraryRegisterBookServlet extends HttpServlet {

    private static final long serialVersionUID = -6971471412293552088L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryRegisterBookServlet.class);
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doPost(final HttpServletRequest request, final HttpServletResponse response) {
        final String book = StringUtils.makeNotNullable(request.getParameter("book"));
        LibraryActionResults libraryActionResults;

        if (book.isEmpty()) {
            libraryActionResults = LibraryActionResults.NO_BOOK_TITLE_PROVIDED;
            logger.info("input for the book field was empty");
        } else {
            request.setAttribute("book", book);

            logger.info("received request to register a book, {}", book);

            libraryActionResults = libraryUtils.registerBook(book);
        }

        request.setAttribute("return_page", "library.html");
        request.setAttribute("result", libraryActionResults.toString());
        ServletUtils.forwardToResult(request, response, logger);
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryRegisterBorrowerServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Web API to register a new borrower with the library
 */
@WebServlet(name = "LibraryRegisterBorrowerServlet", urlPatterns = {"/registerborrower"}, loadOnStartup = 1)
public class LibraryRegisterBorrowerServlet extends HttpServlet {

    private static final long serialVersionUID = 3293380381170679010L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryRegisterBorrowerServlet.class);
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doPost(final HttpServletRequest request, final HttpServletResponse response) {
        final String borrower = StringUtils.makeNotNullable(request.getParameter("borrower"));
        LibraryActionResults libraryActionResults;

        if (borrower.isEmpty()) {
            libraryActionResults = LibraryActionResults.NO_BORROWER_PROVIDED;
            logger.info("input for the borrower field was empty");
        } else {
            request.setAttribute("borrower", borrower);

            logger.info("received request to register a borrower, {}", borrower);

            libraryActionResults = libraryUtils.registerBorrower(borrower);
        }

        request.setAttribute("return_page", "library.html");
        request.setAttribute("result", libraryActionResults.toString());
        ServletUtils.forwardToResult(request, response, logger);
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryUtils.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.library.domainobjects.Loan;
import com.coveros.training.persistence.IPersistenceLayer;
import com.coveros.training.persistence.PersistenceLayer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Date;
import java.util.ArrayList;
import java.util.List;

/**
 * Business logic for handling library needs.  For example, {@link #lendBook}
 */
public class LibraryUtils {

    private final IPersistenceLayer persistence;
    private static final Logger logger = LoggerFactory.getLogger(LibraryUtils.class);

    public LibraryUtils(IPersistenceLayer persistence) {
        this.persistence = persistence;
    }

    public LibraryUtils() {
        this(new PersistenceLayer());
    }

    /**
     * Lend a book to a borrower.
     * @param bookTitle The title of a registered book, e.g. see {@link #registerBook(String)}
     * @param borrowerName the name of a registered borrower, e.g. see {@link #registerBorrower(String)}
     * @param borrowDate the date the book is being lent out.
     * @return an enum {@link LibraryActionResults} indicating the resultant status
     */
    public LibraryActionResults lendBook(String bookTitle, String borrowerName, Date borrowDate) {
        logger.info("starting process to lend a book: {} to borrower: {}", bookTitle, borrowerName);
        final Book book = searchForBookByTitle(bookTitle);
        final Book foundBook = new Book(book.id, bookTitle);
        final Borrower borrower = searchForBorrowerByName(borrowerName);
        final Borrower foundBorrower = new Borrower(borrower.id, borrowerName);
        return lendBook(foundBook, foundBorrower, borrowDate);
    }

    public LibraryActionResults lendBook(Book book, Borrower borrower, Date borrowDate) {
        if (book.id == 0) {
            logger.info("book: {} was not registered.  Lending failed", book.title);
            return LibraryActionResults.BOOK_NOT_REGISTERED;
        }

        if (borrower.id == 0) {
            logger.info("borrower: {} was not registered.  Lending failed", borrower.name);
            return LibraryActionResults.BORROWER_NOT_REGISTERED;
        }

        final Loan loan = searchForLoanByBook(book);
        if (!loan.isEmpty()) {
            logger.info("book: {} was already checked out on {}.  Lending failed", book.title, loan.checkoutDate);
            return LibraryActionResults.BOOK_CHECKED_OUT;
        }

        logger.info("book: {} is available for borrowing by valid borrower: {}", book.title, borrower.name);
        createLoan(book, borrower, borrowDate);
        return LibraryActionResults.SUCCESS;
    }

    /**
     * This is here so we can extract out the portion of code
     * that calls to the persistence layer, making it easier to test.
     */
    void createLoan(Book book, Borrower borrower, Date borrowDate) {
        logger.info("creating loan for book: {} by borrower: {}", book.title, borrower.name);
        persistence.createLoan(book, borrower, borrowDate);
    }

    /**
     * Register a borrower with the library
     * @param borrower the name of a borrower
     * @return an enum, {@link LibraryActionResults} indicating the resultant status
     */
    public LibraryActionResults registerBorrower(String borrower) {
        logger.info("trying to register a borrower with name: {}", borrower);
        final Borrower borrowerDetails = searchForBorrowerByName(borrower);
        final boolean borrowerWasFound = !borrowerDetails.equals(Borrower.createEmpty());
        if (borrowerWasFound) {
            logger.info("borrower: {} was already registered", borrower);
            return LibraryActionResults.ALREADY_REGISTERED_BORROWER;
        }
        logger.info("borrower: {} was not found.  Registering new borrower...", borrower);
        saveNewBorrower(borrower);
        return LibraryActionResults.SUCCESS;
    }

    /**
     * This is here so we can extract out the portion of code
     * that calls to the persistence layer, making it easier to test.
     */
    void saveNewBorrower(String borrower) {
        logger.info("saving new borrower: {}", borrower);
        persistence.saveNewBorrower(borrower);
    }

    /**
     * Register a new book with the library
     * @param bookTitle the title of a book
     * @return an enum {@link LibraryActionResults} indicating the resultant status
     */
    public LibraryActionResults registerBook(String bookTitle) {
        if (bookTitle.isEmpty()) {
            throw new IllegalArgumentException("bookTitle was an empty string - disallowed when registering books");
        }
        logger.info("trying to register a book with title: {}", bookTitle);
        final Book book = searchForBookByTitle(bookTitle);
        if (!book.isEmpty()) {
            logger.info("book: {} was already registered", bookTitle);
            return LibraryActionResults.ALREADY_REGISTERED_BOOK;
        }
        logger.info("book: {} was not found.  Registering new book...", bookTitle);
        saveNewBook(bookTitle);
        return LibraryActionResults.SUCCESS;
    }

    /**
     * This is here so we can extract out the portion of code
     * that calls to the persistence layer, making it easier to test.
     */
    void saveNewBook(String bookTitle) {
        logger.info("saving a new book: {}", bookTitle);
        persistence.saveNewBook(bookTitle);
    }

    public Loan searchForLoanByBook(Book book) {
        logger.info("searching for loan by book with title: {}", book.title);
        return persistence.searchForLoanByBook(book).orElse(Loan.createEmpty());
    }


    public List<Loan> searchForLoanByBorrower(Borrower borrower) {
        logger.info("searching for loan by borrower with name: {}", borrower.name);
        return persistence.searchForLoanByBorrower(borrower).orElse(new ArrayList<>());
    }

    public Borrower searchForBorrowerByName(String borrowerName) {
        logger.info("searching for borrower by name: {}", borrowerName);
        return persistence.searchBorrowerDataByName(borrowerName).orElse(Borrower.createEmpty());
    }

    public Book searchForBookByTitle(String title) {
        if (title.isEmpty()) {
            throw new IllegalArgumentException("when searching for a book, must include a non-empty string for title");
        }
        logger.info("search for book with title: {}", title);
        final Book book = persistence.searchBooksByTitle(title).orElse(Book.createEmpty());
        if (book.isEmpty()) {
            logger.info("No book found with title of {}", title);
        } else {
            logger.info("book found with title of {}", title);
        }
        return book;
    }

    /**
     * The id has to be positive.  Exception will be thrown otherwise.
     */
    public Book searchForBookById(long id) {
        if (id < 1) {
            throw new IllegalArgumentException("when searching for a book, must include an id of one or greater");
        }
        logger.info("search for book with id: {}", id);
        final Book book = persistence.searchBooksById(id).orElse(Book.createEmpty());
        if (book.isEmpty()) {
            logger.info("No book found with id of {}", id);
        } else {
            logger.info("Book found with id of {}", id);
        }
        return book;
    }

    /**
     * The id has to be positive.  Exception will be thrown otherwise.
     */
    public Borrower searchForBorrowerById(long id) {
        if (id < 1) {
            throw new IllegalArgumentException("when searching for a borrower, must include an id of one or greater");
        }
        logger.info("search for borrower with id: {}", id);
        final Borrower borrower = persistence.searchBorrowersById(id).orElse(Borrower.createEmpty());
        if (borrower.isEmpty()) {
            logger.info("No borrower found with id of {}", id);
        } else {
            logger.info("borrower found with id of {}", id);
        }
        return borrower;
    }

    public static LibraryUtils createEmpty() {
        return new LibraryUtils(PersistenceLayer.createEmpty());
    }

    public boolean isEmpty() {
        return persistence.isEmpty();
    }

    public LibraryActionResults deleteBook(Book book) {
        logger.info("deleting a book.  id: {}, title: {}", book.id, book.title);
        final Book bookInDatabase = searchForBookByTitle(book.title);
        if (bookInDatabase.isEmpty()) {
            logger.info("book not found in database.  Therefore, obviously, cannot be deleted");
            return LibraryActionResults.NON_REGISTERED_BOOK_CANNOT_BE_DELETED;
        }
        persistence.deleteBook(book.id);
        logger.info("book with title: {} and id: {} was deleted", bookInDatabase.title, bookInDatabase.id);
        return LibraryActionResults.SUCCESS;
    }

    public LibraryActionResults deleteBorrower(Borrower borrower) {
        logger.info("deleting a borrower.  id: {}, name: {}", borrower.id, borrower.name);
        final Borrower borrowerInDatabase = searchForBorrowerByName(borrower.name);
        if (borrowerInDatabase.isEmpty()) {
            logger.info("borrower not found in database.  Therefore, obviously, cannot be deleted");
            return LibraryActionResults.NON_REGISTERED_BORROWER_CANNOT_BE_DELETED;
        }
        persistence.deleteBorrower(borrower.id);
        logger.info("borrower with name: {} and id: {} was deleted", borrowerInDatabase.name, borrowerInDatabase.id);
        return LibraryActionResults.SUCCESS;
    }

    public List<Book> listAllBooks() {
        logger.info("received request to list all books");
        return persistence.listAllBooks().orElse(new ArrayList<>());
    }


    public List<Borrower> listAllBorrowers() {
        logger.info("received request to list all borrowers");
        return persistence.listAllBorrowers().orElse(new ArrayList<>());
    }


    public List<Book> listAvailableBooks() {
        logger.info("received request to list available books");
        return persistence.listAvailableBooks().orElse(new ArrayList<>());
    }
}



================================================
FILE: src/main/java/com/coveros/training/library/package-info.java
================================================
/**
 * Books and borrowers and that sort of thing.
 */
package com.coveros.training.library;


================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/Book.java
================================================
package com.coveros.training.library.domainobjects;

import com.coveros.training.helpers.StringUtils;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Represents the data that we consider full and complete to define
 * a particular book in the library.  This coincides neatly with the details in the database.
 */
public final class Book {

    /**
     * The title of the book
     */
    public final String title;

    /**
     * The identifier number in our database
     */
    public final long id;

    public Book(long id, String title) {
        this.title = title;
        this.id = id;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        Book rhs = (Book) obj;
        return new EqualsBuilder()
                .append(id, rhs.id)
                .append(title, rhs.title)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(13, 33).
                append(id).
                append(title).
                toHashCode();
    }

    public final String toOutputString() {
        return String.format("{\"Title\": \"%s\", \"Id\": \"%s\"}", StringUtils.escapeForJson(title), id);
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public static Book createEmpty() {
        return new Book(0, "");
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/Borrower.java
================================================
package com.coveros.training.library.domainobjects;

import com.coveros.training.helpers.StringUtils;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


/**
 * An immutable data value representing the data for a borrower.
 * <p>
 * A borrower is a person who borrows a book from a library.
 * <p>
 * Note that we make our fields public because they are final,
 * so there's no need to have methods wrapping them.
 */
public final class Borrower {

    /**
     * The identifier for this borrower in the database.
     */
    public final long id;

    /**
     * The name of the borrower
     */
    public final String name;

    public Borrower(long id, String name) {
        this.id = id;
        this.name = name;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        Borrower rhs = (Borrower) obj;
        return new EqualsBuilder()
                .append(id, rhs.id)
                .append(name, rhs.name)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(17, 37).
                append(id).
                append(name).
                toHashCode();
    }

    public final String toOutputString() {
        return String.format("{\"Name\": \"%s\", \"Id\": \"%s\"}", StringUtils.escapeForJson(name), id);
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public static Borrower createEmpty() {
        return new Borrower(0, "");
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }
}



================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/LibraryActionResults.java
================================================
package com.coveros.training.library.domainobjects;

/**
 * These are the possible results of business functions
 * related to the library.  For example, you might
 * get ALREADY_REGISTERED_BOOK if you are trying to register
 * a book and it's already in the library.
 */
public enum LibraryActionResults {

    ALREADY_REGISTERED_BOOK,

    /**
     * if a book isn't registered, then of course we cannot delete it.
     */
    NON_REGISTERED_BOOK_CANNOT_BE_DELETED,

    /**
     * if a borrower isn't registered, then of course we cannot delete it.
     */
    NON_REGISTERED_BORROWER_CANNOT_BE_DELETED,
    ALREADY_REGISTERED_BORROWER,
    BOOK_NOT_REGISTERED,
    BORROWER_NOT_REGISTERED,
    /**
     * someone already has this book checked out.
     */
    BOOK_CHECKED_OUT,
    SUCCESS,
    /**
     * if a method needs a book and none is provided
     */
    NO_BOOK_TITLE_PROVIDED,
    /**
     * if a method needs a borrower and none is provided
     */
    NO_BORROWER_PROVIDED,
    /**
     * may be used when initializing a variable of this type
     */
    NULL
}



================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/Loan.java
================================================
package com.coveros.training.library.domainobjects;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


import java.sql.Date;

/**
 * Represents the data that we consider full and complete to define
 * a particular loan of a book to a borrower in the library.
 * This coincides neatly with the details in the database.
 */
public final class Loan {

    /**
     * The date the book was checked out.
     */
    public final java.sql.Date checkoutDate;

    /**
     * The book that is checked out
     */
    public final Book book;

    /**
     * The borrower that has this book
     */
    public final Borrower borrower;

    /**
     * The identifier of this loan in our database
     */
    public final long id;

    public Loan(Book book, Borrower borrower, long id, Date checkoutDate) {
        this.book = book;
        this.borrower = borrower;
        this.id = id;
        this.checkoutDate = checkoutDate;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        Loan rhs = (Loan) obj;
        return new EqualsBuilder()
                .append(id, rhs.id)
                .append(book, rhs.book)
                .append(borrower, rhs.borrower)
                .append(checkoutDate, rhs.checkoutDate)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(5, 21)
                .append(book)
                .append(borrower)
                .append(id)
                .append(checkoutDate)
                .toHashCode();
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public static Loan createEmpty() {
        return new Loan(Book.createEmpty(), Borrower.createEmpty(), 0, new Date(0));
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }
}



================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/package-info.java
================================================
/**
 * These represent concepts within the library domain, like books, borrowers, loans.
 */
package com.coveros.training.library.domainobjects;


================================================
FILE: src/main/java/com/coveros/training/mathematics/Ackermann.java
================================================
package com.coveros.training.mathematics;

import java.math.BigInteger;


public class Ackermann {

    private Ackermann() {
        throw new IllegalStateException("Utility class");
    }

    /**
     * Ackerman function.
     *
     * This version found at https://rosettacode.org/wiki/Ackermann_function#Java
     */
    public static BigInteger ack(BigInteger m, BigInteger n) {
        if (m.equals(BigInteger.ZERO)) {
            return n.add(BigInteger.ONE);
        }
        if (n.equals(BigInteger.ZERO)) {
            return ack(m.subtract(BigInteger.ONE), BigInteger.ONE);
        }
        return ack(m.subtract(BigInteger.ONE), ack(m, n.subtract(BigInteger.ONE)));
    }

    /**
     * A helper method to make it easy to call this with only integers
     * Calls to {@link #ack}
     */
    public static BigInteger calculate(int m, int n) {
        BigInteger bigM = BigInteger.valueOf(m);
        BigInteger bigN = BigInteger.valueOf(n);
        return ack(bigM, bigN);
    }
}



================================================
FILE: src/main/java/com/coveros/training/mathematics/AckermannIterative.java
================================================
package com.coveros.training.mathematics;

import java.math.BigInteger;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.function.BinaryOperator;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * From https://rosettacode.org/wiki/Ackermann_function#Java
 */
public interface AckermannIterative {
    static BigInteger calculate(int m, int n) {
        BigInteger bigM = BigInteger.valueOf(m);
        BigInteger bigN = BigInteger.valueOf(n);
        return $.main(bigM, bigN);
    }
    BigInteger number1();
    BigInteger number2();

    Deque<BigInteger> stack();

    boolean flag();

    enum $ {
        END;

        private static final BigInteger ZERO = BigInteger.ZERO;
        private static final BigInteger ONE = BigInteger.ONE;
        private static final BigInteger TWO = BigInteger.valueOf(2);
        private static final BigInteger THREE = BigInteger.valueOf(3);

        private static AckermannIterative tail(BigInteger number1, BigInteger number2, Deque<BigInteger> stack, boolean flag) {
            return (FunctionalAckermann) field -> {
                switch (field) {
                    case NUMBER_1: return number1;
                    case NUMBER_2: return number2;
                    case STACK: return stack;
                    case FLAG: return flag;
                    default: throw new UnsupportedOperationException(
                            field instanceof Field
                                    ? "Field checker has not been updated properly."
                                    : "Field is not of the correct type."
                    );
                }
            };
        }

        private static final BinaryOperator<BigInteger> ACKERMANN =
                TailRecursive.tailie(
                        (BigInteger number1, BigInteger number2) ->
                                tail(
                                        number1,
                                        number2,
                                        Stream.of(number1).collect(
                                                Collectors.toCollection(ArrayDeque::new)
                                        ),
                                        false
                                )
                        ,
                        ackermann -> {
                            BigInteger number1 = ackermann.number1();
                            BigInteger number2 = ackermann.number2();
                            Deque<BigInteger> stack = ackermann.stack();
                            if (!stack.isEmpty() && !ackermann.flag()) {
                                number1 = stack.pop();
                            }
                            switch (number1.intValue()) {
                                case 0:
                                    return tail(
                                            number1,
                                            number2.add(ONE),
                                            stack,
                                            false
                                    );
                                case 1:
                                    return tail(
                                            number1,
                                            number2.add(TWO),
                                            stack,
                                            false
                                    );
                                case 2:
                                    return tail(
                                            number1,
                                            number2.multiply(TWO).add(THREE),
                                            stack,
                                            false
                                    );
                                default:
                                    if (ZERO.equals(number2)) {
                                        return tail(
                                                number1.subtract(ONE),
                                                ONE,
                                                stack,
                                                true
                                        );
                                    } else {
                                        stack.push(number1.subtract(ONE));
                                        return tail(
                                                number1,
                                                number2.subtract(ONE),
                                                stack,
                                                true
                                        );
                                    }
                            }
                        },
                        ackermann -> ackermann.stack().isEmpty(),
                        AckermannIterative::number2
                )::apply
                ;

        private static BigInteger main(BigInteger m, BigInteger n) {
            return ACKERMANN.apply(m, n);
        }

        private enum Field {
            NUMBER_1,
            NUMBER_2,
            STACK,
            FLAG
        }

        @FunctionalInterface
        private interface FunctionalAckermann extends FunctionalField<Field>, AckermannIterative {
            @Override
            default BigInteger number1() {
                return field(Field.NUMBER_1);
            }

            @Override
            default BigInteger number2() {
                return field(Field.NUMBER_2);
            }

            @Override
            default Deque<BigInteger> stack() {
                return field(Field.STACK);
            }

            @Override
            default boolean flag() {
                return field(Field.FLAG);
            }
        }
    }
}


================================================
FILE: src/main/java/com/coveros/training/mathematics/AckServlet.java
================================================
package com.coveros.training.mathematics;

import com.coveros.training.helpers.ServletUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.math.BigInteger;

@MultipartConfig
@WebServlet(name = "AckServlet", urlPatterns = {"/ackermann"}, loadOnStartup = 1)
public class AckServlet extends HttpServlet {

    private static final long serialVersionUID = 5669410483481180165L;
    public static final String RESULT = "result";
    static Logger logger = LoggerFactory.getLogger(AckServlet.class);

    private int putNumberInRequest(String itemName, HttpServletRequest request) {
        int item = Integer.parseInt(request.getParameter(itemName));
        request.setAttribute(itemName, item);
        return item;
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        try {
            int ackParamM = putNumberInRequest("ack_param_m", request);
            int ackParamN = putNumberInRequest("ack_param_n", request);
            String algorithm = request.getParameter("ack_algorithm_choice");

            logger.info("received request to calculate Ackermann's with {} and {} and the {} algorithm", ackParamM, ackParamN, algorithm);

            if (algorithm.equals("tail_recursive")) {
                tailRecursive(request, ackParamM, ackParamN);
            } else {
                regularRecursive(request, ackParamM, ackParamN);
            }

        } catch (NumberFormatException ex) {
            request.setAttribute(RESULT, "Error: only accepts integers");
        }
        forwardToResult(request, response, logger);
    }

    /**
     * Wrapping a static method call for testing.
     */
    void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    /**
     * Wrapping a request set for easier testing and clarity.
     */
    void regularRecursive(HttpServletRequest request, int itemA, int itemB) {
        final BigInteger result = Ackermann.calculate(itemA, itemB);
        logger.info("Ackermann's result is {}", result);
        request.setAttribute(RESULT, result);
    }

    /**
     * Wrapping a request set for easier testing and clarity.
     */
    void tailRecursive(HttpServletRequest request, int itemA, int itemB) {
        final BigInteger result = AckermannIterative.calculate(itemA, itemB);
        logger.info("Ackermann's result is {}", result);
        request.setAttribute(RESULT, result);
    }

}



================================================
FILE: src/main/java/com/coveros/training/mathematics/Calculator.java
================================================
package com.coveros.training.mathematics;

import org.apache.commons.lang3.tuple.Pair;

/**
 * A simple class to do simple things.
 */
public class Calculator {

    private final Baz baz;

    public Calculator() {
        this.baz = new Baz();
    }

    public Calculator(Baz baz) {
        this.baz = baz;
    }


    /**
     * Simply add two integers
     */
    public static int add(int a, int b) {
        return a + b;
    }

    /**
     * Simply add two doubles.
     */
    public static double add(double a, double b) {
        return a + b;
    }

    /**
     * This method converts integers 0 to 10 into their
     * ordinals.  For example: 0 returns "zero"
     */
    public static String toStringZeroToTen(int i) {
        switch (i) {
            case 0: return "zero";
            case 1: return "one";
            case 2: return "two";
            case 3: return "three";
            case 4: return "four";
            case 5: return "five";
            case 6: return "six";
            case 7: return "seven";
            case 8: return "eight";
            case 9: return "nine";
            case 10: return "ten";
            default: return "dunno";
        }
    }

    /**
     * Add two pairs.
     */
    public static Pair<Integer, Integer> add(Pair<Integer, Integer> pair1, Pair<Integer, Integer> pair2) {
        int newLeftValue = pair1.getLeft() + pair2.getLeft();
        int newRightValue = pair1.getRight() + pair2.getRight();
        return Pair.of(newLeftValue, newRightValue);
    }

    /**
     * Used for teaching
     * testing stubs.
     */
    public static int calculateAndMore(int a, int b, iFoo foo, iBar bar) {
        int c = foo.doComplexThing(a);
        int d = bar.doOtherComplexThing(c);
        return a + b + c + d;
    }

    /**
     * Used for teaching
     * testing stubs.
     */
    public int calculateAndMorePart2(int a) {
        int b = baz.doThirdPartyThing(a);
        return a + b;
    }

    /**
     * Used for teaching
     * testing mocks.
     */
    public void calculateAndMorePart3(int a) {
        baz.doThirdPartyThing(a);
    }

    public interface iFoo {
        int doComplexThing(int a);
    }

    /**
     * An artificial class needed as a dependency
     */
    public static class Foo {
        public int doComplexThing(int a) {
            return a + 1;
        }
    }


    public interface iBar {
        int doOtherComplexThing(int c);
    }

    /**
     * An artificial class needed as a dependency
     */
    public static class Bar {
        public int doOtherComplexThing(int c) {
            return c - 1;
        }
    }

    /**
     * An artificial class needed as a dependency
     */
    public class Baz {

        public int doThirdPartyThing(int a) {
            return 42;
        }
    }
}



================================================
FILE: src/main/java/com/coveros/training/mathematics/Fibonacci.java
================================================
package com.coveros.training.mathematics;

public class Fibonacci {

    private Fibonacci() {
        // static utility class.  Do not construct.
    }

    public static long calculate(long n) {
        long result;

        if (n <= 1) {
            result = n;
        } else {
            result = calculate(n - 1) + calculate(n - 2);
        }

        return result;
    }
}




================================================
FILE: src/main/java/com/coveros/training/mathematics/FibonacciIterative.java
================================================
package com.coveros.training.mathematics;

import java.math.BigInteger;

/**
 * From https://rosettacode.org/wiki/Fibonacci_sequence#Iterative_35
 */
public class FibonacciIterative {

    private FibonacciIterative() {
        throw new IllegalStateException("Utility class");
    }

    /**
     * O(log(n))
     */
    public static BigInteger fibAlgo1(long n) {
        if (n <= 0)
            return BigInteger.ZERO;

        BigInteger i =  (BigInteger.valueOf(n).subtract(BigInteger.ONE));
        BigInteger a = BigInteger.ONE;
        BigInteger b = BigInteger.ZERO;
        BigInteger c = BigInteger.ZERO;
        BigInteger d = BigInteger.ONE;
        BigInteger tmp1;
        BigInteger tmp2;

        while (i.compareTo(BigInteger.ZERO) > 0) {
            if (!i.mod(BigInteger.valueOf(2)).equals(BigInteger.ZERO)) {
                tmp1 = d.multiply(b).add(c.multiply(a));
                tmp2 = d.multiply (b.add(a)).add(c.multiply(b));
                a = tmp1;
                b = tmp2;
            }

            tmp1 = c.pow(2).add(d.pow(2));
            tmp2 = d.multiply(c.multiply(BigInteger.valueOf(2)).add(d));

            c = tmp1;
            d = tmp2;

            i = i.divide(BigInteger.valueOf(2));
        }
        return a.add(b);
    }

    public static BigInteger fibAlgo2(int n)
    {
        if (n < 2)
            return BigInteger.valueOf(n);
        BigInteger ans = BigInteger.ZERO;
        BigInteger n1 =  BigInteger.ZERO;
        BigInteger n2 =  BigInteger.ONE;
        for(n--; n > 0; n--)
        {
            ans = n1.add(n2);
            n1 = n2;
            n2 = ans;
        }
        return ans;
    }

}



================================================
FILE: src/main/java/com/coveros/training/mathematics/FibServlet.java
================================================
package com.coveros.training.mathematics;

import com.coveros.training.helpers.ServletUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.math.BigInteger;

@MultipartConfig
@WebServlet(name = "FibServlet", urlPatterns = {"/fibonacci"}, loadOnStartup = 1)
public class FibServlet extends HttpServlet {

    private static final long serialVersionUID = 5290010004362186530L;
    public static final String RESULT = "result";
    public static final String FIBONACCI_VALUE_IS = "Fibonacci value is {}";
    static Logger logger = LoggerFactory.getLogger(FibServlet.class);

    private int putNumberInRequest(String itemName, HttpServletRequest request) {
        int item = Integer.parseInt(request.getParameter(itemName));
        request.setAttribute(itemName, item);
        return item;
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        try {
            int fibParamN = putNumberInRequest("fib_param_n", request);
            String algorithm = request.getParameter("fib_algorithm_choice");

            logger.info("received request to calculate the {}th fibonacci number by {}", fibParamN, algorithm);

            if (algorithm.equals("tail_recursive_1")) {
                tailRecursiveAlgo1Calc(request, fibParamN);
            } else if (algorithm.equals("tail_recursive_2")) {
                tailRecursiveAlgo2Calc(request, fibParamN);
            } else {
                defaultRecursiveCalculation(request, fibParamN);
            }
        } catch (NumberFormatException ex) {
            request.setAttribute(RESULT, "Error: only accepts integers");
        }
        forwardToResult(request, response, logger);
    }

    void tailRecursiveAlgo2Calc(HttpServletRequest request, int fibParamN) {
        final BigInteger result = FibonacciIterative.fibAlgo2(fibParamN);
        logger.info(FIBONACCI_VALUE_IS, result);
        request.setAttribute(RESULT, result);
    }

    void tailRecursiveAlgo1Calc(HttpServletRequest request, int fibParamN) {
        final BigInteger result = FibonacciIterative.fibAlgo1(fibParamN);
        logger.info(FIBONACCI_VALUE_IS, result);
        request.setAttribute(RESULT, result);
    }

    /**
     * Wrapping a static method call for testing.
     */
    void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    /**
     * Wrapping a request set for easier testing and clarity.
     */
    void defaultRecursiveCalculation(HttpServletRequest request, int itemA) {
        final long result = Fibonacci.calculate(itemA);
        logger.info(FIBONACCI_VALUE_IS, result);
        request.setAttribute(RESULT, result);
    }

}



================================================
FILE: src/main/java/com/coveros/training/mathematics/FunctionalField.java
================================================
package com.coveros.training.mathematics;

@FunctionalInterface
public interface FunctionalField<F extends Enum<?>> {
    Object untypedField(F field);

    @SuppressWarnings("unchecked")
    default <V> V field(F field) {
        return (V) untypedField(field);
    }
}



================================================
FILE: src/main/java/com/coveros/training/mathematics/MathServlet.java
================================================
package com.coveros.training.mathematics;

import com.coveros.training.helpers.ServletUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

// Multipart config is necessary so that we can properly receive data when
// sending via the "FormData" API.  Using FormData is part of the modern
// API and also allows sending files.
@MultipartConfig
@WebServlet(name = "MathServlet", urlPatterns = {"/math"}, loadOnStartup = 1)
public class MathServlet extends HttpServlet {

    private static final long serialVersionUID = 1766696864489619658L;
    static org.slf4j.Logger logger = LoggerFactory.getLogger(MathServlet.class);

    private int putNumberInRequest(String itemName, HttpServletRequest request) {
        int item = Integer.parseInt(request.getParameter(itemName));
        request.setAttribute(itemName, item);
        return item;
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        try {
            int itemA = putNumberInRequest("item_a", request);
            int itemB = putNumberInRequest("item_b", request);

            logger.info("received request to add two numbers, {} and {}", itemA, itemB);

            setResultToSum(request, itemA, itemB);
        } catch (NumberFormatException ex) {
            request.setAttribute("result", "Error: only accepts integers");
        }
        forwardToResult(request, response, logger);
    }

    /**
     * Wrapping a static method call for testing.
     */
    void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    /**
     * Wrapping a request set for easier testing and clarity.
     */
    void setResultToSum(HttpServletRequest request, int itemA, int itemB) {
        final int result = Calculator.add(itemA, itemB);
        request.setAttribute("result", result);
    }

}



================================================
FILE: src/main/java/com/coveros/training/mathematics/package-info.java
================================================
/**
 * Interesting mathematics - adding things, Fibonacci sequence, Ackermann's formula, etc.
 */
package com.coveros.training.mathematics;


================================================
FILE: src/main/java/com/coveros/training/mathematics/TailRecursive.java
================================================
package com.coveros.training.mathematics;

import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;

public interface TailRecursive {

    static <M, N, I, O> BiFunction<M, N, O> tailie(BiFunction<M, N, I> toIntermediary, UnaryOperator<I> unaryOperator, Predicate<I> predicate, Function<I, O> toOutput) {
        return (input1, input2) ->
                $.epsilon(
                        Stream.iterate(
                                toIntermediary.apply(input1, input2),
                                unaryOperator
                        ),
                        predicate,
                        toOutput
                )
                ;
    }

    enum $ {
        END;

        private static <I, O> O epsilon(Stream<I> stream, Predicate<I> predicate, Function<I, O> function) {
            return stream
                    .filter(predicate)
                    .map(function)
                    .findAny()
                    .orElseThrow(RuntimeException::new)
                    ;
        }
    }
}



================================================
FILE: src/main/java/com/coveros/training/persistence/DbServlet.java
================================================
package com.coveros.training.persistence;

import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(name = "DbServlet", urlPatterns = {"/flyway"}, loadOnStartup = 1)
public class DbServlet extends HttpServlet {

    private static final long serialVersionUID = 1960160729302133928L;
    private final IPersistenceLayer pl;

    public DbServlet() {
        pl = new PersistenceLayer();
    }

    public DbServlet(IPersistenceLayer pl) {
        this.pl = pl;
    }

    private static final String RESULT = "result";
    private static final Logger logger = LoggerFactory.getLogger(DbServlet.class);

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) {
        final String action = StringUtils.makeNotNullable(request.getParameter("action"));
        switch (action) {
            case "clean":
                logger.info("received request to clean the database - i.e. remove all data and schema");
                pl.cleanDatabase();
                request.setAttribute(RESULT, "cleaned");
                break;
            case "migrate":
                logger.info("received request to migrate the database - i.e. add schema, but no data");
                pl.migrateDatabase();
                request.setAttribute(RESULT, "migrated");
                break;
            default:
                logger.info("received request to clean, then migrate the database - i.e. putting it a fresh state with no data");
                pl.cleanAndMigrateDatabase();
                request.setAttribute(RESULT, "cleaned and migrated");
        }
        request.setAttribute("return_page", "library.html");

        ServletUtils.forwardToResult(request, response, logger);
    }


}



================================================
FILE: src/main/java/com/coveros/training/persistence/EmptyDataSource.java
================================================
package com.coveros.training.persistence;

import javax.sql.DataSource;
import java.io.PrintWriter;
import java.sql.Connection;
import java.util.logging.Logger;

/**
 * This class only exists because we want no nulls in our
 * system.  In order to do this, we have to be able to create
 * "empty" versions of our classes.  To create an empty String, for
 * example, is simply "".  But an empty DataSource would look like this.
 */
class EmptyDataSource implements DataSource {
    @Override
    public Connection getConnection() {
        throw new NotImplementedException();
    }

    @Override
    public Connection getConnection(String username, String password) {
        throw new NotImplementedException();
    }

    @Override
    public <T> T unwrap(Class<T> iface) {
        throw new NotImplementedException();
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) {
        throw new NotImplementedException();
    }

    @Override
    public PrintWriter getLogWriter() {
        throw new NotImplementedException();
    }

    @Override
    public void setLogWriter(PrintWriter out) {
        throw new NotImplementedException();
    }

    @Override
    public void setLoginTimeout(int seconds) {
        throw new NotImplementedException();
    }

    @Override
    public int getLoginTimeout() {
        throw new NotImplementedException();
    }

    @Override
    public Logger getParentLogger() {
        throw new NotImplementedException();
    }

}



================================================
FILE: src/main/java/com/coveros/training/persistence/IPersistenceLayer.java
================================================
package com.coveros.training.persistence;

import com.coveros.training.authentication.domainobjects.User;
import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.library.domainobjects.Loan;

import java.sql.Date;
import java.util.List;
import java.util.Optional;

/**
 * This is the only place in our application allowed to speak
 * directly to the database.  All business functionality that
 * requires database access must go through here.
 */
public interface IPersistenceLayer {


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Library Persistence Functions
     *
     * ==========================================================
     * ==========================================================
     */


    /**
     * Creates a new borrower in the database
     *
     * @param borrowerName the name of the borrower
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long saveNewBorrower(String borrowerName);


    /**
     * Creates a new loan of a book in the database.
     *
     * @param book       a book we have to loan out
     * @param borrower   a person who is borrowing the book
     * @param borrowDate the date this book was borrowed
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long createLoan(Book book, Borrower borrower, Date borrowDate);


    /**
     * Creates a new book in the database
     *
     * @param bookTitle the String title of a book
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long saveNewBook(String bookTitle);


    /**
     * If we already have a borrower, this command allows us to change
     * their values (except for their id)
     *
     * @param id           the id of a borrower (a constant)
     * @param borrowerName the name of a borrower, which we can change.
     */
    void updateBorrower(long id, String borrowerName);


    /**
     * Delete a book from the database
     * @param id the identifier for a book
     */
    void deleteBook(long id);


    /**
     * Delete a borrower from the database
     * @param id the identifier for a borrower
     */
    void deleteBorrower(long id);


    /**
     * Given the id for a borrower, this command returns their name.
     *
     * @param id a borrower's id.
     * @return the borrower's name, or empty
     */
    Optional<String> getBorrowerName(long id);


    /**
     * Searches for a borrower by name.  Returns full details
     * if found.  return empty borrower data if not found.
     *
     * @param borrowerName the name of a borrower
     * @return a valid borrower, or empty
     */
    Optional<Borrower> searchBorrowerDataByName(String borrowerName);


    /**
     * Find a book by its title
     * @param bookTitle the title of a book
     * @return a valid book, or empty
     */
    Optional<Book> searchBooksByTitle(String bookTitle);


    /**
     * Find a book by its id
     * @param id the database id for a book
     * @return a valid book, or empty
     */
    Optional<Book> searchBooksById(long id);


    /**
     * Find a borrower by their id
     * @param id the database id of a borrower
     * @return a borrower, or empty
     */
    Optional<Borrower> searchBorrowersById(long id);


    /**
     * List all the books in the library
     * @return all the books, or empty
     */
    Optional<List<Book>> listAllBooks();


    /**
     * List all the books currently available for borrowing
     * @return all the available books, or empty
     */
    Optional<List<Book>> listAvailableBooks();


    /**
     * List all the borrowers registered in the library
     * @return a list of all the borrowers, or empty
     */
    Optional<List<Borrower>> listAllBorrowers();


    /**
     * Search for book loans by borrower
     *
     * A borrower may have more than one loan.  But a book
     * can only be loaned to one borrower.  That is why when we
     * search for loans by borrower, we may get multiple loans
     * back, but when we search by book, we only get one back.
     * A book cannot be loaned to two people at the same time!
     *
     * @param borrower a given borrower registered with the library
     * @return a list of loans, or empty
     */
    Optional<List<Loan>> searchForLoanByBorrower(Borrower borrower);


    /**
     * A book can only be loaned to one person.  Find that loan
     * @param book the book used to search for the loan
     * @return a loan, or empty
     */
    Optional<Loan> searchForLoanByBook(Book book);


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Authentication Persistence Functions
     *
     * ==========================================================
     * ==========================================================
     */


    /**
     * Save a new user to the database
     *
     * @param username a String name of a user
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long saveNewUser(String username);


    /**
     * Change the password for a user.
     *
     * We store the user's hash, not their password.  This method
     * first hashes the password, then stores that.
     * @param id the database id for a given user
     * @param password the new password, which we'll hash first before storing
     */
    void updateUserWithPassword(long id, String password);


    /**
     * Search the database for a given borrower by their name
     * @param username a borrower's name
     * @return a user, or empty
     */
    Optional<User> searchForUserByName(String username);


    /**
     * Check whether the credentials are valid
     * @param username a user's chosen username
     * @param password a user's chosen password
     * @return true if the credentials match something we have, empty otherwise
     */
    Optional<Boolean> areCredentialsValid(String username, String password);


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Utility Persistence Functions
     *      General functions related to database persistence
     *
     * ==========================================================
     * ==========================================================
     */


    /**
     * Records the current state of the database as a SQL script,
     * used later for restoring by something like {@link #runRestore(String)}
     *
     * @param backupFileName the path to the sql script, based in the project home directory.
     */
    void runBackup(String backupFileName);


    /**
     * Runs a database restore script.
     *
     * @param backupFileName the path to the sql script, based in the project home directory.
     */
    void runRestore(String backupFileName);


    /**
     * Cleans the database and runs the scripts to update it
     * to the most current version.
     */
    void cleanAndMigrateDatabase();


    /**
     * Cleans the database and runs the scripts to update it
     * to the most current version.
     */
    void cleanDatabase();


    /**
     * Cleans the database and runs the scripts to update it
     * to the most current version.
     */
    void migrateDatabase();


    /**
     * Used to indicate that a persistence layer object is
     * using an empty datasource.  See {@link EmptyDataSource}
     * @return true if the object is "empty"
     */
    boolean isEmpty();
}



================================================
FILE: src/main/java/com/coveros/training/persistence/NotImplementedException.java
================================================
package com.coveros.training.persistence;

class NotImplementedException extends RuntimeException {

    private static final long serialVersionUID = -7063829616868098428L;
}



================================================
FILE: src/main/java/com/coveros/training/persistence/package-info.java
================================================
/**
 * Classes that provide communication with the database
 */
package com.coveros.training.persistence;


================================================
FILE: src/main/java/com/coveros/training/persistence/ParameterObject.java
================================================
package com.coveros.training.persistence;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


/**
 * a POJO container for the parameters for the {@link SqlData} object.
 */
public final class ParameterObject<T> {

    /**
     * The data we are injecting into the SQL statement
     */
    final Object data;

    /**
     * The type of the data we are injecting into the SQL statement (e.g. Integer, String, etc.)
     */
    final Class<T> type;

    ParameterObject(Object data, Class<T> type) {
        this.data = data;
        this.type = type;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        ParameterObject<?> rhs = (ParameterObject<?>) obj;
        return new EqualsBuilder()
                .append(data, rhs.data)
                .append(type, rhs.type)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(63, 7).
                append(data).
                append(type).
                toHashCode();
    }

    public static ParameterObject<Void> createEmpty() {
        return new ParameterObject<>("", Void.class);
    }

    public boolean isEmpty() {
        return this.equals(ParameterObject.createEmpty());
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

}



================================================
FILE: src/main/java/com/coveros/training/persistence/PersistenceLayer.java
================================================
package com.coveros.training.persistence;

import com.coveros.training.helpers.CheckUtils;
import com.coveros.training.helpers.StringUtils;
import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.library.domainobjects.Loan;
import com.coveros.training.authentication.domainobjects.User;
import org.flywaydb.core.Flyway;
import org.h2.jdbcx.JdbcConnectionPool;

import javax.sql.DataSource;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;


public class PersistenceLayer implements IPersistenceLayer {

    /*
     * ==========================================================
     * ==========================================================
     *
     *  Class construction - details of making this class
     *
     * ==========================================================
     * ==========================================================
     */

    private final DataSource dataSource;

    public PersistenceLayer() {
        this(obtainConnectionPool());
    }

    PersistenceLayer(DataSource ds) {
        dataSource = ds;
    }

    private static JdbcConnectionPool obtainConnectionPool() {
        return JdbcConnectionPool.create(
                "jdbc:h2:mem:training;MODE=PostgreSQL", "", "");
    }

    /*
     * ==========================================================
     * ==========================================================
     *
     *  Micro ORM
     *    Demo has a simplistic Object Relational Mapper (ORM)
     *    implementation.  These are the methods that comprise
     *    the mechanisms for that.
     *
     *    In comparison, a gargantuan project like Hibernate
     *    would consist of a heckuva-lot-more than this.  That's
     *    why this one is termed, "micro"
     *
     * ==========================================================
     * ==========================================================
     */


    /**
     * This command provides a template to execute updates (including inserts) on the database
     */
    void executeUpdateTemplate(String description, String preparedStatement, Object ... params) {
        final SqlData<Object> sqlData = new SqlData<>(description, preparedStatement, params);
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st = prepareStatementWithKeys(sqlData, connection)) {
                executeUpdateOnPreparedStatement(sqlData, st);
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }


    public long executeInsertTemplate(
            String description,
            String preparedStatement,
            Object ... params) {
        final SqlData<Object> sqlData = new SqlData<>(description, preparedStatement, params);
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st = prepareStatementWithKeys(sqlData, connection)) {
                return executeInsertOnPreparedStatement(sqlData, st);
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }


    <T> long executeInsertOnPreparedStatement(SqlData<T> sqlData, PreparedStatement st) throws SQLException {
        sqlData.applyParametersToPreparedStatement(st);
        st.executeUpdate();
        try (ResultSet generatedKeys = st.getGeneratedKeys()) {
            long newId;
            if (generatedKeys.next()) {
                newId = generatedKeys.getLong(1);
                assert (newId > 0);
            } else {
                throw new SqlRuntimeException("failed Sql.  Description: " + sqlData.description + " SQL code: " + sqlData.preparedStatement);
            }
            return newId;
        }
    }


    private <T> void executeUpdateOnPreparedStatement(SqlData<T> sqlData, PreparedStatement st) throws SQLException {
        sqlData.applyParametersToPreparedStatement(st);
        st.executeUpdate();
    }


    /**
     * A helper method.  Simply creates a prepared statement that
     * always returns the generated keys from the database, like
     * when you insert a new row of data in a table with auto-generating primary key.
     *
     * @param sqlData    see {@link SqlData}
     * @param connection a typical {@link Connection}
     */
    private <T> PreparedStatement prepareStatementWithKeys(SqlData<T> sqlData, Connection connection) throws SQLException {
        return connection.prepareStatement(
                sqlData.preparedStatement,
                Statement.RETURN_GENERATED_KEYS);
    }


    <R> Optional<R> runQuery(SqlData<R> sqlData) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st =
                         connection.prepareStatement(sqlData.preparedStatement)) {
                sqlData.applyParametersToPreparedStatement(st);
                try (ResultSet resultSet = st.executeQuery()) {
                    return sqlData.extractor.apply(resultSet);
                }
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }

    }


    /**
     * This is an interface to a wrapper around {@link Function} so we can catch exceptions
     * in the generic function.
     *
     * @param <R> The return type
     * @param <E> The type of the exception
     */
    @FunctionalInterface
    private interface ThrowingFunction<R, E extends Exception> {
        R apply(ResultSet resultSet) throws E;
    }


    /**
     * This wraps the throwing function, so that we are not forced to
     * catch an exception in our ordinary code - it's caught and handled
     * here.
     * @param throwingFunction a lambda that throws a checked exception we have to handle.
     *                         specifically in this case that's a SqlRuntimeException
     * @param <R> the type of value returned
     * @return returns a function that runs and returns a function wrapped with an exception handler
     */
    static <R> Function<ResultSet, R> throwingFunctionWrapper(
            ThrowingFunction<R, Exception> throwingFunction) {

        return resultSet -> {
            try {
                return throwingFunction.apply(resultSet);
            } catch (Exception ex) {
                throw new SqlRuntimeException(ex);
            }
        };
    }


    /**
     * Accepts a function to extract data from a {@link ResultSet} and
     * removes some boilerplate with handling its response.
     * Works in conjunction with {@link #throwingFunctionWrapper}
     * @param extractorFunction a function that extracts data from a {@link ResultSet}
     * @param <T> the type of data we'll retrieve from the {@link ResultSet}
     * @return either the type of data wrapped with an optional, or {@link Optional#empty}
     */
    private <T> Function<ResultSet, Optional<T>> createExtractor(
            ThrowingFunction<Optional<T>, Exception> extractorFunction) {
        return throwingFunctionWrapper(rs -> {
            if (rs.next()) {
                return extractorFunction.apply(rs);
            } else {
                return Optional.empty();
            }
        });
    }


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Business functions
     *     loaning out books, registering users, etc
     *
     * ==========================================================
     * ==========================================================
     */


    // Library functions

    @Override
    public long saveNewBorrower(String borrowerName) {
        CheckUtils.StringMustNotBeNullOrEmpty(borrowerName);
        return executeInsertTemplate(
                "adds a new library borrower",
                "INSERT INTO library.borrower (name) VALUES (?);", borrowerName);
    }


    @Override
    public long createLoan(Book book, Borrower borrower, Date borrowDate) {
        return executeInsertTemplate(
                "Creates a new loan of a book to a borrower",
                "INSERT INTO library.loan (book, borrower, borrow_date) VALUES (?, ?, ?);", book.id, borrower.id, borrowDate);
    }


    @Override
    public long saveNewBook(String bookTitle) {
        CheckUtils.StringMustNotBeNullOrEmpty(bookTitle);
        return executeInsertTemplate(
                "Creates a new book in the database",
                "INSERT INTO library.book (title) VALUES (?);", bookTitle);
    }


    @Override
    public void updateBorrower(long id, String borrowerName) {
        CheckUtils.IntParameterMustBePositive(id);
        CheckUtils.StringMustNotBeNullOrEmpty(borrowerName);
        executeUpdateTemplate(
                "Updates the borrower's data",
                "UPDATE library.borrower SET name = ? WHERE id = ?;", borrowerName, id);
    }


    @Override
    public void deleteBook(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        executeUpdateTemplate(
                "Deletes a book from the database",
                "DELETE FROM library.book WHERE id = ?;", id);
    }


    @Override
    public void deleteBorrower(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        executeUpdateTemplate(
                "Deletes a borrower from the database",
                "DELETE FROM library.borrower WHERE id = ?;", id);
    }


    @Override
    public Optional<String> getBorrowerName(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        Function<ResultSet, Optional<String>> extractor =
                createExtractor(rs -> Optional.of(StringUtils.makeNotNullable(rs.getString(1))));

        return runQuery(new SqlData<>(
                        "get a borrower's name by their id",
                        "SELECT name FROM library.borrower WHERE id = ?;",
                        extractor, id));
    }


    @Override
    public Optional<Borrower> searchBorrowerDataByName(String borrowerName) {
        CheckUtils.StringMustNotBeNullOrEmpty(borrowerName);
        Function<ResultSet, Optional<Borrower>> extractor = createExtractor(rs -> {
            long id = rs.getLong(1);
            String name = StringUtils.makeNotNullable(rs.getString(2));
            return Optional.of(new Borrower(id, name));
        });

        return runQuery(new SqlData<>(
                        "search for details on a borrower by name",
                        "SELECT id, name FROM library.borrower WHERE name = ?;",
                        extractor, borrowerName));
    }


    @Override
    public Optional<Book> searchBooksByTitle(String bookTitle) {
        CheckUtils.StringMustNotBeNullOrEmpty(bookTitle);
        Function<ResultSet, Optional<Book>> extractor = createExtractor(rs -> {
            long id = rs.getLong(1);
            return Optional.of(new Book(id, bookTitle));
        });

        return runQuery(new SqlData<>(
                        "search for a book by title",
                        "SELECT id FROM library.book WHERE title = ?;",
                        extractor, bookTitle));
    }


    @Override
    public Optional<Book> searchBooksById(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        Function<ResultSet, Optional<Book>> extractor = createExtractor(rs -> {
            long bookId = rs.getLong(1);
            String title = StringUtils.makeNotNullable(rs.getString(2));
            return Optional.of(new Book(bookId, title));
        });

        return runQuery(new SqlData<>(
                        "search for a book by title",
                        "SELECT id, title FROM library.book WHERE id = ?;",
                        extractor, id));
    }


    @Override
    public Optional<Borrower> searchBorrowersById(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        Function<ResultSet, Optional<Borrower>> extractor = createExtractor(rs -> {
            long borrowerId = rs.getLong(1);
            String name = StringUtils.makeNotNullable(rs.getString(2));
            return Optional.of(new Borrower(borrowerId, name));
        });

        return runQuery(new SqlData<>(
                        "search for a borrower by name",
                        "SELECT id, name FROM library.borrower WHERE id = ?;",
                        extractor, id));
    }


    @Override
    public Optional<List<Book>> listAllBooks() {
        return listBooks("get all books", "SELECT id, title FROM library.book;");
    }


    @Override
    public Optional<List<Book>> listAvailableBooks() {
        return listBooks("get all available books", "SELECT b.id, b.title FROM library.book b LEFT JOIN library.loan l ON b.id = l.book WHERE l.borrow_date IS NULL;");
    }


    private Optional<List<Book>> listBooks(String description, String sqlCode) {
        Function<ResultSet, Optional<List<Book>>> extractor = createExtractor(rs -> {
            List<Book> bookList = new ArrayList<>();
            do {
                long id = rs.getLong(1);
                String title = StringUtils.makeNotNullable(rs.getString(2));
                bookList.add(new Book(id, title));
            } while (rs.next());
            return Optional.of(bookList);
        });

        return runQuery(new SqlData<>(
                        description,
                        sqlCode,
                        extractor));
    }


    @Override
    public Optional<List<Borrower>> listAllBorrowers() {
        Function<ResultSet, Optional<List<Borrower>>> extractor = createExtractor(rs -> {
            List<Borrower> borrowerList = new ArrayList<>();
            do {
                long id = rs.getLong(1);
                String name = StringUtils.makeNotNullable(rs.getString(2));
                borrowerList.add(new Borrower(id, name));
            } while (rs.next());
            return Optional.of(borrowerList);
        });

        return runQuery(new SqlData<>(
                        "get all borrowers",
                        "SELECT id, name FROM library.borrower;",
                        extractor));
    }


    @Override
    public Optional<List<Loan>> searchForLoanByBorrower(Borrower borrower) {
        Function<ResultSet, Optional<List<Loan>>> extractor = createExtractor(rs -> {
            List<Loan> loans = new ArrayList<>();
            do {
                final long loanId = rs.getLong(1);
                final Date borrowDate = rs.getDate(2);
                final long bookId = rs.getLong(3);
                final String bookTitle = StringUtils.makeNotNullable(rs.getString(4));
                final Date borrowDateNotNullable = borrowDate == null ? Date.valueOf("0000-01-01") : borrowDate;
                loans.add(new Loan(new Book(bookId, bookTitle), borrower, loanId, borrowDateNotNullable));
            } while (rs.next());
            return Optional.of(loans);
        });

        return runQuery(new SqlData<>(
                "search for all loans by borrower",
                "SELECT loan.id, loan.borrow_date, loan.book, book.title " +
                        "FROM library.loan loan " +
                        "JOIN library.book book ON book.id = loan.book " +
                        "WHERE loan.borrower = ?;",
                extractor, borrower.id));
    }


    @Override
    public Optional<Loan> searchForLoanByBook(Book book) {
        Function<ResultSet, Optional<Loan>> extractor = createExtractor(rs -> {
            final long loanId = rs.getLong(1);
            final Date borrowDate = rs.getDate(2);
            final long borrowerId = rs.getLong(3);
            final String borrowerName = StringUtils.makeNotNullable(rs.getString(4));
            final Date borrowDateNotNullable = borrowDate == null ? Date.valueOf("0000-01-01") : borrowDate;
            return Optional.of(new Loan(book, new Borrower(borrowerId, borrowerName), loanId, borrowDateNotNullable));
        });

        return runQuery(new SqlData<>(
                "search for a loan by book",
                "SELECT loan.id, loan.borrow_date, loan.borrower, bor.name " +
                        "FROM library.loan loan " +
                        "JOIN library.borrower bor ON bor.id = loan.borrower " +
                        "WHERE loan.book = ?;",
                extractor, book.id));
    }


    // authentication functions


    @Override
    public long saveNewUser(String username) {
        CheckUtils.StringMustNotBeNullOrEmpty(username);
        return executeInsertTemplate(
                "Creates a new user in the database",
                "INSERT INTO auth.user (name) VALUES (?);", username);
    }


    @Override
    public Optional<User> searchForUserByName(String username) {
        CheckUtils.StringMustNotBeNullOrEmpty(username);
        Function<ResultSet, Optional<User>> extractor = createExtractor(rs -> {
            final long id = rs.getLong(1);
            return Optional.of(new User(username, id));
        });

        return runQuery(new SqlData<>(
                "search for a user by id, return that user if found, otherwise return an empty user",
                "SELECT id  FROM auth.user WHERE name = ?;",
                extractor, username));
    }


    @Override
    public Optional<Boolean> areCredentialsValid(String username, String password) {
        Function<ResultSet, Optional<Boolean>> extractor = createExtractor(rs -> {
            final long id = rs.getLong(1);
            assert (id > 0);
            return Optional.of(true);
        });

        final String hexHash = createHashedValueFromPassword(password);
        return runQuery(new SqlData<>(
                "check to see if the credentials for a user are valid",
                "SELECT id FROM auth.user WHERE name = ? AND password_hash = ?;",
                extractor, username, hexHash));
    }


    @Override
    public void updateUserWithPassword(long id, String password) {
        CheckUtils.IntParameterMustBePositive(id);
        String hashedPassword = createHashedValueFromPassword(password);
        executeUpdateTemplate(
                "Updates the user's password field with a new hash",
                "UPDATE auth.user SET password_hash = ? WHERE id = ?;", hashedPassword, id);
    }


    /**
     * Given a password (for example, "password123"), return a
     * hash of that.
     * @param password a user's password
     * @return a hash of the password value.  a one-way function that returns a unique value,
     *          but different than the original, cannot be converted back to its original value.
     */
    private String createHashedValueFromPassword(String password) {
        CheckUtils.StringMustNotBeNullOrEmpty(password);
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] encodedhash = digest.digest(
                    password.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(encodedhash);
        } catch (NoSuchAlgorithmException e) {
            throw new SqlRuntimeException(e);
        }
    }


    /**
     * Converts an array of bytes to their corresponding hex string
     * @param bytes an array of bytes
     * @return a hex string of that array
     */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }


    /*
     * ==========================================================
     * ==========================================================
     *
     *  General utility methods
     *
     * ==========================================================
     * ==========================================================
     */


    public static IPersistenceLayer createEmpty() {
        return new PersistenceLayer(new EmptyDataSource());
    }


    @Override
    public boolean isEmpty() {
        return this.dataSource.getClass().equals(EmptyDataSource.class);
    }

    @Override
    public void runBackup(String backupFileName) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st = connection.prepareStatement("SCRIPT TO ?")) {
                st.setString(1, backupFileName);
                st.execute();
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }

    @Override
    public void runRestore(String backupFileName) {
        String dbScriptsDirectory="src/integration_test/resources/db_sample_files/";
        String fullPathToBackup = dbScriptsDirectory + backupFileName;
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st = connection.prepareStatement(
                    "DROP SCHEMA IF EXISTS ADMINISTRATIVE CASCADE;" +
                            "DROP SCHEMA IF EXISTS AUTH CASCADE;" +
                            "DROP SCHEMA IF EXISTS LIBRARY CASCADE;")) {
                st.execute();
            }
            try (PreparedStatement st = connection.prepareStatement("RUNSCRIPT FROM ?")) {
                st.setString(1, fullPathToBackup);
                st.execute();
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Database migration code - using FlywayDb
     *
     * ==========================================================
     * ==========================================================
     */


    @Override
    public void cleanAndMigrateDatabase() {
        cleanDatabase();
        migrateDatabase();
    }

    @Override
    public void cleanDatabase() {
        Flyway flyway = configureFlyway();
        flyway.clean();
    }

    @Override
    public void migrateDatabase() {
        Flyway flyway = configureFlyway();
        flyway.migrate();
    }

    private Flyway configureFlyway() {
        return Flyway.configure()
                .schemas("ADMINISTRATIVE", "LIBRARY", "AUTH")
                .dataSource(this.dataSource)
                .load();
    }

}



================================================
FILE: src/main/java/com/coveros/training/persistence/SqlData.java
================================================
package com.coveros.training.persistence;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;

import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;

/**
 * This class encapsulates some of the actions related to
 * injecting data into a prepared SQL statement, so that
 * we are able to summarize what we want done without
 * all the annoying boilerplate.  See examples like {@link PersistenceLayer#saveNewBorrower}
 * <p>
 * Was necessary to suppress the nullness warnings on this class due to its
 * use of generics.
 * The generic R is the result type - if we ask for a string, R would be a String.
 * On the other hand if R might be a compound type, like Employee.
 */
final class SqlData<R> {

    /**
     * A summary description of what this SQL is doing.
     */
    final String description;

    /**
     * This is the String text of the SQL prepared statement.  We're using PostgreSQL,
     * see https://jdbc.postgresql.org/documentation/81/server-prepare.html
     */
    final String preparedStatement;

    /**
     * The data that we will inject to the SQL statement.
     */
    private final List<ParameterObject<?>> params;

    /**
     * A generic function - takes a {@link ResultSet} straight from the database,
     * and then carries out actions on it, per the user's intentions, to convert it
     * into something of type {@link R}.
     */
    public final Function<ResultSet, Optional<R>> extractor;

    SqlData(String description, String preparedStatement, Object ... params) {
        this(description, preparedStatement, (resultSet -> Optional.empty()), params);
    }

    /**
     * Creates an object that is used to avoid some of the boilerplate
     * in running database CRUD operations.
     *
     * @param description       A string that describes in plain English what this SQL does.
     * @param preparedStatement The SQL that is run on the database
     * @param extractor         see {@link #extractor} a function that is run to convert the returned {@link ResultSet} into whatever we want
     */
    SqlData(String description, String preparedStatement, Function<ResultSet, Optional<R>> extractor, Object ... params) {
        this.description = description;
        this.preparedStatement = preparedStatement;
        this.params = new ArrayList<>();
        if (params.length > 0) {
            generateParams(params);
        }
        this.extractor = extractor;
    }

    /**
     * Loads the parameters for this SQL
     * @param params
     */
    private void generateParams(Object[] params) {
        for (Object param:params) {
            addParameter(param, param.getClass());
        }
    }


    /**
     * A list of the parameters to a particular SQL statement.
     * Add to this list in the order of the statement.
     * For example,
     * for SELECT * FROM USERS WHERE a = ? and b = ?
     * <p>
     * first add the parameter for a, then for b.
     *
     * @param data  a particular item of data.  Any object will do.  Look at {@link #applyParametersToPreparedStatement(PreparedStatement)}
     *              to see what we can process.
     * @param clazz the class of the thing.  I would rather not use reflection, let's keep it above board for now.
     */
    <T> void addParameter(Object data, Class<T> clazz) {
        params.add(new ParameterObject<>(data, clazz));
    }

    /**
     * Loop through the parameters that have been added and
     * serially add them to the prepared statement.
     *
     * @param st a prepared statement
     */
    void applyParametersToPreparedStatement(PreparedStatement st) {
        try {
            for (int i = 1; i <= params.size(); i++) {
                ParameterObject<?> p = params.get(i - 1);
                if (p.type == String.class) {
                    st.setString(i, (String) p.data);
                } else if (p.type == Integer.class) {
                    st.setInt(i, (Integer) p.data);
                } else if (p.type == Long.class) {
                    st.setLong(i, (Long) p.data);
                } else if (p.type == Date.class) {
                    st.setDate(i, (Date) p.data);
                }
            }
        } catch (SQLException e) {
            throw new SqlRuntimeException(e);
        }
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        SqlData<?> rhs = (SqlData<?>) obj;
        return new EqualsBuilder()
                .append(description, rhs.description)
                .append(preparedStatement, rhs.preparedStatement)
                .append(params, rhs.params)
                .append(extractor, rhs.extractor)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(53, 97)
                .append(description)
                .append(preparedStatement)
                .append(params)
                .append(extractor)
                .toHashCode();
    }

    public final String toString() {
        StringBuilder paramsString = new StringBuilder();
        for(ParameterObject<?> p : params) {
            paramsString.append(p);
        }

        return new ToStringBuilder(this).
                append("description", description).
                append("params", paramsString.toString()).
                append("prepared statement", preparedStatement).
                toString();
    }

    public static <T> SqlData<T> createEmpty() {
        return new SqlData<>("", "");
    }

    public boolean isEmpty() {
        return this.equals(SqlData.createEmpty());
    }

}



================================================
FILE: src/main/java/com/coveros/training/persistence/SqlRuntimeException.java
================================================
package com.coveros.training.persistence;

class SqlRuntimeException extends RuntimeException {

    public SqlRuntimeException(Exception ex) {
        super(ex);
    }

    public SqlRuntimeException(String message) {
        super(message);
    }
}



================================================
FILE: src/main/java/com/coveros/training/tomcat/package-info.java
================================================
/**
 * Classes that configure Tomcat server, specifically.
 * For example, WebAppListner - Tomcat uses that to know
 * what commands to run at server start.
 */
package com.coveros.training.tomcat;


================================================
FILE: src/main/java/com/coveros/training/tomcat/WebAppListener.java
================================================
package com.coveros.training.tomcat;

import com.coveros.training.persistence.IPersistenceLayer;
import com.coveros.training.persistence.PersistenceLayer;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;

/**
 * The purpose of this class is to run certain commands at the
 * start-up of the application.
 */
@WebListener
public class WebAppListener implements ServletContextListener {

    private final IPersistenceLayer pl;

    public WebAppListener() {
        pl = new PersistenceLayer();
    }

    public WebAppListener(IPersistenceLayer pl) {
        this.pl = pl;
    }

    /**
     * Cleans and migrates the database using Flyway.
     * See database migration files like V2__Rest_of_tables_for_auth_and_library.sql
     */
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        //  clean the database and configure the schema
        pl.cleanAndMigrateDatabase();
    }

    /**
     * This does nothing, but it's required to implement per the interface.
     */
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        // do nothing.
    }

}


================================================
FILE: src/main/javadoc/overview.html
================================================
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
    <TITLE>API Overview</TITLE>
</HEAD>
<BODY>
<p>
    This is the Demo application by <a href="https://www.coveros.com">Coveros</a>.  You can find
    plenty of documentation in the docs/ directory.  It is listed on <a href="https://github.com/7ep/demo">Github</a>
</p>
<p>
    When looking into each class, the following patterns may aid in your understanding.
</p>
<ul>
<li>Files that
    end with "Servlet" are the code that makes the application available to the outside world, that
    is, it is the definition of web API
</li>
<li>Files that end with "Utils" are the business logic for a particular domain</li>
</ul>
</BODY>
</HTML>


================================================
FILE: src/main/resources/README.txt
================================================
The resources consist of:

log4j2.xml      :    configuration for the logging mechanism when Demo runs
db              :    database files


================================================
FILE: src/main/resources/log4j2.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Configuration monitorinterval="30" status="info" strict="true">

    <Appenders>
        <!-- configure the logging output for the console.  See https://logging.apache.org/log4j/2.x/manual/layouts.html -->
        <Appender type="Console" name="Console">
            <Layout type="PatternLayout" pattern="%d %p %m%n"/>
        </Appender>
    </Appenders>


    <Loggers>
        <!-- set the logging to the INFO level - meaning it will show INFO and up (INFO, WARN, FATAL, etc) -->
        <Root level="INFO">
            <AppenderRef ref="Console"/>
        </Root>
    </Loggers>

</Configuration>



================================================
FILE: src/main/resources/db/README.txt
================================================
The database files consist of:

migration           :  Flyway scripts to manipulate the schema of the database.  For example,
                       one thing they do, among others, is to create a user table.


================================================
FILE: src/main/resources/db/migration/V1__Create_person_table.sql
================================================
-- Maybe we'll create a person table - something to hold our librarians and borrowers
create table library.PERSON (
    id serial PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);



================================================
FILE: src/main/resources/db/migration/V2__Rest_of_tables_for_auth_and_library.sql
================================================
-- eh, instead of one table for both librarians and borrowers,
-- we'll create a borrower table for borrowers and a
-- separate auth.USER table for librarians
drop table library.person;

-- here's our borrower table
create table library.BORROWER (
    id serial PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

-- books, obviously - it's a library
create table library.BOOK (
    id serial PRIMARY KEY,
    title VARCHAR(100) NOT NULL
);

-- this tracks which books have been lent to borrowers
create table library.LOAN (
    id serial PRIMARY KEY,
    book int NOT NULL REFERENCES library.BOOK (id) ON DELETE CASCADE,
    borrower int NOT NULL REFERENCES library.BORROWER (id) ON DELETE CASCADE,
    borrow_date date NOT NULL
);

-- this holds the list of librarians, mainly their name and their
-- password hash (used during authentication)
create table auth.USER (
    id serial PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    password_hash VARCHAR(100)
);



================================================
FILE: src/main/webapp/catalog.css
================================================
[Empty file]


================================================
FILE: src/main/webapp/catalog.js
================================================
window.addEventListener( "load", function () {
  function sendData(formObject) {
    const XHR = new XMLHttpRequest();

    // Bind the FormData object and the form element
    const FD = new FormData( formObject );

    // Define what happens on successful data submission
    XHR.addEventListener( "load", function(event) {
      var responseArea = formObject.getElementsByClassName("responsearea")[0];
      responseArea.innerText = event.target.responseText;
    } );

    // Define what happens in case of error
    XHR.addEventListener( "error", function( event ) {
      alert( 'Oops! Something went wrong.' );
    } );


    let queryString = '';
    if (formObject.method == "get") {
        entries = [];
        for(var pair of FD.entries()) {
           entries.push(pair[0]+ '='+ pair[1]);
        }
        queryString = '?'+entries.join('&');
    }

    // Set up our request
    XHR.open( formObject.method, formObject.action + queryString);

    // The data sent is what the user provided in the form
    XHR.send( FD );
  }

  let forms = document.querySelectorAll("form");
  for (let j = 0; j < forms.length; j++){
    // Access the form element...
    let form = forms[j];

    // ...and take over its submit event.
    form.addEventListener( "submit", function ( event ) {
      event.preventDefault();
      sendData(form);
    } );
  }
} );


================================================
FILE: src/main/webapp/dbhelp.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Database help</title>
</head>
<body>
<p>To log in, username and password is empty and this is the URL:</p>
<p>jdbc:h2:mem:training;MODE=PostgreSQL;DB_CLOSE_DELAY=-1</p>
</body>
</html>


================================================
FILE: src/main/webapp/endpointcatalog.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8">
    <title>Catalog of endpoints for Demo</title>
    <link rel="stylesheet" href="catalog.css">
    <script type="text/javascript" src="catalog.js"></script>
</head>
<body>

<form id="post_math_form" method="POST" action="math" autocomplete="off">
    <fieldset>
        <legend class="title" id="math_title">The "math" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Simply adds two integers where the integers are each
                between -2147483648 and 2147483647, and their sum also does
                not exceed that range</span>
        </p>
        <p>
            <label for="math_param_item_a">item_a</label>
            <input type="number" id="math_param_item_a" name="item_a">
        </p>
        <p>
            <label for="math_param_item_b">item_b</label>
            <input type="number" id="math_param_item_b" name="item_b">
        </p>
        <p>
            <label for="math_response">Response:</label>
            <textarea class="responsearea" id="math_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoMathButton">POST</button>
        </p>
    </fieldset>
</form>

<form id="post_fibonacci_form" method="POST" action="fibonacci" autocomplete="off">
    <fieldset>
        <legend class="title" id="fibonacci_title">The "fibonacci" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Calculates the nth value in the Fibonacci sequence, per one of three algorithms.  The
            default, naive, recursive approach is "default recursive".  The other two use more sophisticated
            tail-recursive techniques.</span>
        </p>
        <p>
            <label for="fibonacci_param_fib_param_n">fib_param_n</label>
            <input type="number" id="fibonacci_param_fib_param_n" name="fib_param_n">
        </p>
        <p>
            <label for="fibonacci_param_fib_algorithm_choice">fib_algorithm_choice</label>
            <select id="fibonacci_param_fib_algorithm_choice" name="fib_algorithm_choice">
                <option value="default_recursive">default_recursive</option>
                <option value="tail_recursive_1">tail_recursive_1</option>
                <option value="tail_recursive_2">tail_recursive_2</option>
            </select>
        </p>
        <p>
            <label for="fibonacci_response">Response:</label>
            <textarea class="responsearea" id="fibonacci_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoFibonacciButton">POST</button>
        </p>
    </fieldset>
</form>

<form id="post_ackermann_form" method="POST" action="ackermann" autocomplete="off">
    <fieldset>
        <legend class="title" id="ackermann_title">The "ackermann" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Calculates the nth value in the Ackermann sequence, per one of two algorithms.  The
            default, naive, recursive approach is "default recursive".  The other one uses a sophisticated
            tail-recursive technique.</span>
        </p>
        <p>
            <label for="ackermann_param_ack_param_m">ack_param_m</label>
            <input type="number" id="ackermann_param_ack_param_m" name="ack_param_m">
        </p>
        <p>
            <label for="ackermann_param_ack_param_n">ack_param_n</label>
            <input type="number" id="ackermann_param_ack_param_n" name="ack_param_n">
        </p>
        <p>
            <label for="ackermann_param_ack_algorithm_choice">ack_algorithm_choice</label>
            <select id="ackermann_param_ack_algorithm_choice" name="ack_algorithm_choice">
                <option value="default_recursive">default_recursive</option>
                <option value="tail_recursive">tail_recursive</option>
            </select>
        </p>
        <p>
            <label for="ackermann_response">Response:</label>
            <textarea class="responsearea" id="ackermann_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoAckermannButton">POST</button>
        </p>
    </fieldset>
</form>

<form id="get_book_form" method="GET" action="book" autocomplete="off">
    <fieldset>
        <legend class="title" id="book_title">The "book" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Lists and searches books.  If you provide no input, it will list all books.  If you provide
            an identifier number or a title, it will search by those.  If you provide both an identifier
            and a title, it will return an error message.</span>
        </p>
        <p>
            <label for="book_param_id">id</label>
            <input type="number" id="book_param_id" name="id">
        </p>
        <p>
            <label for="book_param_title">title</label>
            <input type="text" id="book_param_title" name="title">
        </p>
        <p>
            <label for="book_response">Response:</label>
            <textarea class="responsearea" id="book_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoBookButton">POST</button>
        </p>
    </fieldset>
</form>

<form id="get_borrower_form" method="GET" action="borrower" autocomplete="off">
    <fieldset>
        <legend class="title" id="borrower_title">The "borrower" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Lists and searches borrowers.  If you provide no input, it will list all borrowers.  If you provide
            an identifier number or a name, it will search by those.  If you provide both an identifier
            and a name, it will return an error message.</span>
        </p>
        <p>
            <label for="borrower_param_id">id</label>
            <input type="number" id="borrower_param_id" name="id">
        </p>
        <p>
            <label for="borrower_param_name">name</label>
            <input type="text" id="borrower_param_name" name="name">
        </p>
        <p>
            <label for="borrower_response">Response:</label>
            <textarea class="responsearea" id="borrower_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoBorrowerButton">POST</button>
        </p>
    </fieldset>
</form>

</body>

</html>


================================================
FILE: src/main/webapp/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8">
    <title>Demo Index</title>
</head>
<body>
<ul>
    <li><a href="library.html">Library</a></li>
    <li><a href="endpointcatalog.html">Endpoint catalog</a></li>
    <li><a href="commit.html">Current commit</a></li>
</ul>
</body>
</html>


================================================
FILE: src/main/webapp/library.html
================================================
<html>
<head>
    <title>Library</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css">

</head>
<body>

<form method="post" action="login" autocomplete="off" class="regular-form">

    <h2>Librarian login</h2>
    <label for="login_username">Name:</label>
    <p><input type="text" id="login_username" name="username" placeholder="name"/></p>

    <label for="login_password">Password:</label>
    <p><input type="password" id="login_password" name="password" placeholder="password123"/></p>

    <p><input type="submit" id="login_submit" value="login"/></p>
</form>

<form method="post" action="register" autocomplete="off" class="regular-form">

    <h2>Register librarian</h2>
    <label for="register_username">Name:</label>
    <p><input type="text" id="register_username" name="username" placeholder="name"/></p>

    <label for="register_password">Password:</label>
    <p><input type="password" id="register_password" name="password" placeholder="password123"/></p>
    <p><input type="submit" id="register_submit" value="register"/></p>
</form>

<form method="post" action="lend" autocomplete="off" class="regular-form">

    <h2>Borrow a book</h2>

    <label for="lend_book">Book:</label>
    <p><input type="text" id="lend_book" name="book" placeholder="book"/></p>

    <label for="lend_borrower">Borrower:</label>
    <p><input type="text" id="lend_borrower" name="borrower" placeholder="borrower"/></p>

    <p><input type="submit" id="lend_book_submit" value="lend"/></p>
</form>


<form method="post" action="registerbook" autocomplete="off" class="regular-form">

    <h2>Register a book</h2>

    <label for="register_book">Book:</label>
    <p><input type="text" id="register_book" name="book" placeholder="book"/></p>

    <p><input type="submit" id="register_book_submit" value="register"/></p>
</form>


<form method="post" action="registerborrower" autocomplete="off" class="regular-form">

    <h2>Register a borrower</h2>

    <label for="book">Borrower:</label>
    <p><input type="text" id="register_borrower" name="borrower" placeholder="borrower"/></p>

    <p><input type="submit" id="register_borrower_submit" value="register"/></p>
</form>

<div class="buttons">
  <h2>Database versioning</h2>
  <form action="flyway" class="button-form">
      <input type="hidden" name="action" value="clean"/>
      <input type="submit" value="Clean"/>
  </form>
  <form action="flyway" class="button-form">
      <input type="hidden" name="action" value="migrate"/>
      <input type="submit" value="Migrate"/>
  </form>
  <form action="flyway" class="button-form">
      <input type="submit" value="Clean / Migrate"/>
  </form>
    <p><a href="console">Database console</a></p>
    <p><a href="dbhelp.html">Console help</a></p>
</div>

</body>
</html>
<script src="library.js"></script>


================================================
FILE: src/main/webapp/library.js
================================================
/**
  * This code enables us to keep track of which listeners we
  * have added to elements.  For example, if we add a "click"
  * listener, this code adds a new method, getEventListeners,
  * to get the list of event listeners.
  */
var ListenerTracker=new function(){
    // a variable to track whether this has been run already.
    // is set to true after the initial run of this code, so follow-up
    // calls will do nothing.
    var is_active=false;

    // listener tracking datas

    // the web elements (also known as "nodes")
    var _elements_  =[];

    //
    var _listeners_ =[];

    this.init=function(){
        if(!is_active){//avoid duplicate call
            intercep_events_listeners();
        }
        is_active=true;
    };

    // register individual element and returns its corresponding listeners
    var register_element=function(element){
        if(_elements_.indexOf(element)==-1){
            // NB : split by useCapture to make listener easier to find when removing
            var elt_listeners=[{/*useCapture=false*/},{/*useCapture=true*/}];
            _elements_.push(element);
            _listeners_.push(elt_listeners);
        }
        return _listeners_[_elements_.indexOf(element)];
    };
    var intercep_events_listeners = function(){
        // backup overrided methods
        var _super_={
            "addEventListener"      : HTMLElement.prototype.addEventListener,
            "removeEventListener"   : HTMLElement.prototype.removeEventListener
        };

        Element.prototype["addEventListener"]=function(type, listener, useCapture){
            var listeners=register_element(this);
            // add event before to avoid registering if an error is thrown
            _super_["addEventListener"].apply(this,arguments);
            // adapt to 'elt_listeners' index
            useCapture=useCapture?1:0;

            if(!listeners[useCapture][type])listeners[useCapture][type]=[];
            listeners[useCapture][type].push(listener);
        };

        Element.prototype["removeEventListener"]=function(type, listener, useCapture){
            var listeners=register_element(this);
            // add event before to avoid registering if an error is thrown
            _super_["removeEventListener"].apply(this,arguments);
            // adapt to 'elt_listeners' index
            useCapture=useCapture?1:0;
            if(!listeners[useCapture][type])return;
            var lid = listeners[useCapture][type].indexOf(listener);
            if(lid>-1)listeners[useCapture][type].splice(lid,1);
        };

        Element.prototype["getEventListeners"]=function(type){
            var listeners=register_element(this);
            // convert to listener datas list
            var result=[];
            for(var useCapture=0,list;list=listeners[useCapture];useCapture++){
                if(typeof(type)=="string"){// filtered by type
                    if(list[type]){
                        for(var id in list[type]){
                            result.push({"type":type,"listener":list[type][id],"useCapture":!!useCapture});
                        }
                    }
                }else{// all
                    for(var _type in list){
                        for(var id in list[_type]){
                            result.push({"type":_type,"listener":list[_type][id],"useCapture":!!useCapture});
                        }
                    }
                }
            }
            return result;
        };
    };
}();
ListenerTracker.init();

/**
  * Creates a list item. see https://www.w3.org/TR/REC-html40/struct/lists.html#edef-LI
  * Adds an attribute, "data", that holds the text data, and also
  * puts the text in as the inner text node
  */
function createItemForList(text) {
    let item = document.createElement('li');
    item.setAttribute("data",text);
    item.appendChild(document.createTextNode(text));
    return item;
}

/**
  * Adds the behavior that takes place when a user clicks on 
  * an item in the autocomplete search box.  That behavior
  * is to put the item in the text input field
  * @param item an item in the autocomplete list, like a book for example
  * @param the base id on which to select parts of the searchbox
  */
function addItemClickBehavior(item, input_id) {
    console.assert(item.getEventListeners('click').length == 0)
    // if the user clicks, put the value in the input field
    item.addEventListener('click', function(event) {
      let input_field = document.getElementById(input_id);
      input_field.value = event.target.innerText;
      deleteSearchBox(input_id);
    });
    console.assert(item.getEventListeners('click').length == 1)
}

/**
  * given an id, find and remove a searchbox from the page
  */
function deleteSearchBox(input_id) {
  let searchbox = document.getElementById(input_id+"_searchbox");
  if (searchbox != null) {
    searchbox.remove();
  }
}

/**
  * creates a unordered list to contain the autocomplete items
  */
function createList(input_id) {
    var innerList = document.createElement('ul');
    innerList.setAttribute("id", input_id+"_searchlist");
    return innerList;
}

/**
  * creates a div that sits under a given input, as a
  * container to the autocomplete functionality
  */
function createSearchBox(input_id) {
    let searchbox = document.createElement('div');
    searchbox.setAttribute("id", input_id+"_searchbox");
    searchbox.setAttribute("class", "searchbox");
    return searchbox;
}

/**
  * Add a dropdown, a <select> to choose amongst the available books.
  */
function addDropdown(id, getdata) {
    let element = document.getElementById(id);
    let nameOfElement = element.getAttribute("name");
    let parent = element.parentNode;
    parent.removeChild(element);
    let select = document.createElement('select');
    select.setAttribute("id", id);
    select.setAttribute("name", nameOfElement);
    let option;

    getdata().forEach(function( item ) {
        option = document.createElement('option');
        option.value = option.textContent = item;
        select.appendChild( option );
    });
    let defaultOption = document.createElement('option');
    defaultOption.textContent = "Choose here";
    defaultOption.setAttribute("selected", "");
    defaultOption.setAttribute("disabled", "");
    defaultOption.setAttribute("hidden", "");
    select.appendChild(defaultOption)

    parent.appendChild(select);
}

/**
  * adds an autocomplete functionality to a given input.
  * this allows a nicer user experience for the user - as they type,
  * the possibilties are narrowed down, and they click on an item to 
  * select it.
  */
function addAutoComplete(id, getdata) {

    let element = document.getElementById(id);

    /**
      * If the autocomplete searchbox is open and the user presses
      * the escape key, remove the searchbox
      */
    function considerRemovingSearchBoxOnPressingEscape(event) {
        if (event.key === "Escape") {
            deleteSearchBox(id);
        }
    }

    function handleBlurEvent(event) {
        // if we tab from this input to another, we'll get a "relatedTarget", and that's
        // the only situation where we would want to close the searchbox - tabbing to another field.
        // so if it's null, ignore the blur event.
        if (event.relatedTarget === null) {
            return;
        } else {
            deleteSearchBox(id);
        }

    }

    function considerKillingThisModalIfOutsideClick(event) {
      if (event.target != document.getElementById(id+"searchbox")) {
        deleteSearchBox(id);
      }
    }

    document.addEventListener('keydown', considerRemovingSearchBoxOnPressingEscape);
    document.addEventListener('click', considerKillingThisModalIfOutsideClick);
    element.addEventListener('blur', handleBlurEvent);

    function openAutoComplete(event) {
        if (event.key === "Escape") return;
        // as the user presses keys, we keep checking what is current
        // and we provide a search box for that.

        let currentContent = element.value;
        if (currentContent.length == 0) {
            // if there's no text in the input box, don't show a searchbox.

            // delete it if it exists
             deleteSearchBox(id);
        } else {
            // if there's more than one item in the input...
             
           let list = createList(id);

            // if the searchbox doesn't exist, create it...
            if (document.getElementById(id+"_searchbox") == null) {
                let searchbox = createSearchBox(id);
                element.insertAdjacentElement('afterend',searchbox);
                searchbox.appendChild(list);
            }

            // get data for the list.
            let mydata = getdata();

            addFilteredData(list, mydata, currentContent, id);

        }
    }

    // if the user clicks, open the autocomplete
    element.addEventListener('keyup', openAutoComplete);
    element.addEventListener('click', openAutoComplete);

}

/**
  * fills the list with data depending on what the user has typed into 
  * the input field.  
  * @param list the list in the searchbox which holds the results
  * @param data the whole set of data from which to filter
  * @param currentContent what the user has currently typed into the input field
  * @param id the core identifier passed around.  other components build off that,
  *        e.g. if the id is abc, then the list item might be 
  */
function addFilteredData(list, data, currentContent, id) {
    let maxSearchListSize = 5;
    let filteredList = 
        data.filter(text => text.includes(currentContent))
            .slice(0,maxSearchListSize);
    for (var i = 0; i < filteredList.length; i++) {
        let item = createItemForList(filteredList[i]);
        // if the user clicks, put the value in the input field
        addItemClickBehavior(item, id);
        list.appendChild(item);
    }
    return list;
}

/**
  * disables an input if there's no data for it.  I mean, there's 
  * no point then, is there?
  */
function lockInput(id) {
    let input = document.getElementById(id);
    input.placeholder = "locked - no data";
    input.disabled = true;
}

/**
  * Communicates with the server.  
  * @param verb - GET or POST
  * @param path - the "action", the route to the endpoint.  e.g. "fib" or "math"
  * @param data - if posting, the data to send to the server.
  */ 
function talk(verb, path, data) {
  return new Promise((resolve, reject) => {
    let r = new XMLHttpRequest();
    r.open(verb, path, true);
    //Send the proper header information along with the request
    r.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    r.onreadystatechange = function () {
      if (r.readyState != 4 || r.status != 200) {
        return;
      } else {
          resolve(r.responseText);
      }

    }
    r.send(data);
  });
}

/**
  *  converts a json object to an array of strings
  *  given a lambda (extractor) to use in the map function
  *  to extract the string desired.  if parsing fails, do nothing.
  */
let extractData = function(value, extractor) {
  try {
    return JSON.parse(value).map(extractor).sort();
  } catch (error) {
    // do nothing
    // console.log("unable to parse the following as JSON: " + value);
  }
}

// Add an autocomplete to the book input for lending
talk("GET", "listavailable")
.then(function(v){
  betterUserExperienceForInput(v, book => book.Title, "lend_book");
});

// Add an autocomplete to the borrower input for lending
talk("GET", "borrower")
.then(function(v) {
    betterUserExperienceForInput(v, borrower => borrower.Name, "lend_borrower");
});

/**
  * Adding this to an input field will provide a better UX experience
  * in certain cases.
  *
  * This is used on the "lend book" fields, to provide a better experience.
  * specifically, if there are no values to select from on a field, lock
  * the field.  If there are between 1 and 9 values, create a dropdown.
  * otherwise, create an autocommplete mechanism - as the user types values,
  * a searchbox below the input is populated with potential values that fit.
  *
  * @param v data received from XHR in JSON format
  * @param extractor a lambda used in a map across JSON elements to extract a string per item
  * @param the id to a particular text input on the page
  */
function betterUserExperienceForInput(v, extractor, input_id) {
  let receivedData = extractData(v, extractor);
  if (receivedData == null) {
    lockInput(input_id);
  } else if (receivedData && receivedData.length > 0 && receivedData.length < 10) {
    addDropdown(input_id, function() {return receivedData});
  } else {
    addAutoComplete(input_id, function() {return receivedData});
  }
}



function integration_tests() {
console.log("WARNING: integration tests running - these affect state");

// clean the database to begin
talk("GET", "flyway")
.then(function(v){
  return talk("POST", "registerborrower", "borrower=alice");
})
.then(function(v){
  return talk("GET", "borrower");  
})
.then(function(v){
  console.assert(v === '[{"Name": "alice", "Id": "1"}]', 'result was ' + v);  
  return JSON.parse(v).map(borrower => borrower.Name);
})
.then(function(v) {
    console.assert(v[0] === "alice", "result was " + v[0])
    return v;
})
.then(function(v) {
    talk("GET", "flyway");
});
}
// uncomment the function below to run integration tests
// integration_tests();

function unit_tests() {
// testing the createItemForList basics
let item = createItemForList("abc");
console.assert(item.getAttribute("data") === "abc", "data attribute was " + item.getAttribute("data") );
console.assert(item.innerText === "abc", "the inner text was " + item.innerText )

// testing createList
let list = createList("abc")
console.assert(list.id === "abc_searchlist", "list id was " + list.id);

// testing createSearchBox
let searchbox = createSearchBox("abc");
console.assert(searchbox.id === "abc_searchbox")

// testing addFilteredData
let mydata = ['a','b','c'];
let currentContent = 'a';
let filteredDataList = addFilteredData(list, mydata, currentContent, "abc");

}
// uncomment the function below to run unit tests
// unit_tests();


   


================================================
FILE: src/main/webapp/main.css
================================================

  * {
    font-family: sans-serif;
  }

  form {
    margin: 0;
    padding: 0;
  }

  div.buttons, form.regular-form {
    border: 2px black solid;
    width: 165px;
    height: 175px;
    margin: 2px;
    padding: 5px;
    float: left;
    background: #c9d0ce;
   }

   div.searchbox > ul {
    margin: 0;
    padding: 0;
    list-style: none;
   }

   div.searchbox {
    width: 162px;
    height: auto;
    position: absolute;
    background: white;
    border: solid 1px;

   }

   li:hover {
    background: black;
    color: white;
   }

  label {
     font-size: 0.8em;
  }

  p {
    margin: 0px;
    padding: 0px;
  }

  h2 {
    font-size: 1.0em;
    margin: 0;
    padding: 0;
  }

   input[type="text"],
   input[type="number"],
   input[type="password"],
   select {
    background: white;
    width: 100%;
   }

   input[type=submit] {
     font-size: 1.0em;
     margin-top: 15px;
     width: 100%;
   }

    @media all and (max-width: 500px) {

      div.buttons, form.regular-form {
        border: 5px black solid;
        width: 87%;
        height: auto;
        margin: auto;
        float: none;
        background: #c9d0ce;
       }

       input {
        padding: 10px;
       }

        /* the following is necessary on iphone to stop
        the browser from zooming in on a text element when
        it gains focus */
       input[type="color"],
       input[type="date"],
       input[type="datetime"],
       input[type="datetime-local"],
       input[type="email"],
       input[type="month"],
       input[type="number"],
       input[type="password"],
       input[type="search"],
       input[type="tel"],
       input[type="text"],
       input[type="time"],
       input[type="url"],
       input[type="week"],
       select:focus,
       textarea {
         font-size: 16px;
       }

    }


================================================
FILE: src/main/webapp/restfulresult.jsp
================================================
${result}


================================================
FILE: src/main/webapp/result.jsp
================================================
<%@ page contentType="text/html;charset=UTF-8" language="java" session="false" %>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Result Page</title>
    </head>
    <body>
        <h2>Result</h2>
        <p><pre id="result">${result}</pre></p>
    </body>
    <p>
    <a href="${return_page}">Return</a>
    </p>
</html>



================================================
FILE: src/main/webapp/WEB-INF/web.xml
================================================
<web-app
        xmlns="http://java.sun.com/xml/ns/j2ee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
        version="2.4">

    <description>Demo App for Training</description>

    <jsp-config>
        <jsp-property-group>
            <url-pattern>*.jsp</url-pattern>
            <page-encoding>UTF-8</page-encoding>
        </jsp-property-group>
    </jsp-config>

    <servlet>
        <servlet-name>H2Console</servlet-name>
        <servlet-class>org.h2.server.web.WebServlet</servlet-class>
        <init-param>
            <param-name>webAllowOthers</param-name>
            <param-value>true</param-value>
        </init-param>
        <!--
        <init-param>
            <param-name>trace</param-name>
            <param-value></param-value>
        </init-param>
        -->
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>H2Console</servlet-name>
        <url-pattern>/console/*</url-pattern>
    </servlet-mapping>

    <session-config>
        <!-- Disables URL-based sessions (no more 'jsessionid' in the URL using Tomcat) -->
        <tracking-mode>COOKIE</tracking-mode>
    </session-config>

</web-app>


================================================
FILE: src/selenified_tests/java/com/coveros/training/selenified/SelenifiedSample.java
================================================
package com.coveros.training.selenified;

import com.coveros.selenified.Locator;
import com.coveros.selenified.Selenified;
import com.coveros.selenified.application.App;
import com.coveros.selenified.element.Element;
import org.junit.Assert;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.testng.ITestContext;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

public class SelenifiedSample extends Selenified {

    static final String BASE_URL =  "http://localhost:8080/demo/";
    static final String LIBRARY_URL = BASE_URL + "library.html";
    static final String RESET_DATABASE_URL = BASE_URL + "flyway";

    @BeforeClass(alwaysRun = true)
    public void beforeClass(ITestContext test) {
        // set the base URL for the tests here
        setAppURL(this, test, LIBRARY_URL);
    }

    @Test(groups = {"sample"}, description = "Check that the title on the page is as expected")
    public void sampleTest() {
        // use this object to manipulate the app
        App app = this.apps.get();
        // verify the correct page title
        app.azzert().titleEquals("Library");
        // verify no issues
        finish();
    }

    @Test(groups = {"sample"}, description = "Make sure we can successfully register a user")
    public void sampleTest2() {
        String username = "fakeuser";
        String password = "asdfpoiasefaslfaje";

        // use this object to manipulate the app
        App app = this.apps.get();

        app.goToURL(RESET_DATABASE_URL);
        app.goToURL(LIBRARY_URL);

        // find the register user field and enter a username to register
        Element register_username = app.newElement(Locator.ID, "register_username");
        register_username.type(username);

        // find the register password field and enter a password
        Element register_password = app.newElement(Locator.ID, "register_password");
        register_password.type(password);

        // click to register the user
        Element register_submit = app.newElement(Locator.ID, "register_submit");
        register_submit.click();

        // assert we find the proper response in the result
        app.azzert().textPresent("successfully registered: true");

        // verify no issues
        finish();
    }

    /**
     *  This is a test to do whatever blah blah blah
     *
     */
    @Test
    public void sampleTest3() {
        // arrange
        App app = this.apps.get();

        final WebDriver driver = app.getDriver();
        String username = "someuser";
        String password = "passworsdosjfasldf";

        app.goToURL(LIBRARY_URL);

        final WebElement login_username = driver.findElement(By.id("login_username"));
        login_username.sendKeys(username);

        final WebElement login_password = driver.findElement(By.id("login_password"));
        login_password.sendKeys(password);

        // act
        final WebElement login_submit = driver.findElement(By.id("login_submit"));
        login_submit.click();

        // assert
        final WebElement result = driver.findElement(By.id("result"));
        Assert.assertEquals("access denied", result.getText());
    }

    /**
     * Testing out logging in with invalid credentials
     *
     * This uses basic Selenium, not Selenified.
     */
    @Test
    public void sampleTest4() {
        App app = this.apps.get();
        final WebDriver driver = app.getDriver();
        String username = "someuser";
        String password = "passworsdosjfasldf";

        app.goToURL(LIBRARY_URL);

        final WebElement register_username = driver.findElement(By.id("register_username"));
        register_username.sendKeys(username);

        final WebElement register_password = driver.findElement(By.id("register_password"));
        register_password.sendKeys(password);

        final WebElement register_submit = driver.findElement(By.id("register_submit"));
        register_submit.click();

        driver.get(LIBRARY_URL);

        final WebElement login_username = driver.findElement(By.id("login_username"));
        login_username.sendKeys(username);

        final WebElement login_password = driver.findElement(By.id("login_password"));
        login_password.sendKeys(password);

        final WebElement login_submit = driver.findElement(By.id("login_submit"));
        login_submit.click();

        final WebElement result = driver.findElement(By.id("result"));
        Assert.assertEquals("access granted", result.getText());

        finish();
    }

}







  


================================================
FILE: src/selenified_tests/resources/selenified.properties
================================================
# connection
#hub=http://localhost:4444
hub=
proxy=
appURL=
# browser
browser=Chrome
headless=false
options=
# logging
defaultWait=5
defaultPoll=50
generatePDF=false
packageResults=false