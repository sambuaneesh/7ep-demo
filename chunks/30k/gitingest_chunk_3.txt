




================================================
FILE: src/integration_test/java/com/coveros/training/persistence/PersistenceLayerTests.java
================================================
package com.coveros.training.persistence;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.library.domainobjects.Loan;
import com.coveros.training.authentication.domainobjects.User;
import org.h2.jdbcx.JdbcConnectionPool;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.sql.DataSource;
import java.sql.*;
import java.time.LocalDate;
import java.time.Month;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

/**
 * Test that we have a persistence layer that we can easily mock out.
 * This exists so we can have more control over the persistence process,
 * whether we want to mock those sections, and so on.
 */
public class PersistenceLayerTests {

    private final static String DEFAULT_NAME = "alice";
    private final static Date BORROW_DATE = Date.valueOf(LocalDate.of(2018, Month.JANUARY, 1));
    private static final Book DEFAULT_BOOK = new Book(1, "The DevOps Handbook");
    private static final Borrower DEFAULT_BORROWER = new Borrower(1, DEFAULT_NAME);
    private static final Loan DEFAULT_LOAN = new Loan(DEFAULT_BOOK, DEFAULT_BORROWER, 1, BORROW_DATE);
    private static final User DEFAULT_USER = new User(DEFAULT_NAME, 1);
    IPersistenceLayer pl;

    @Before
    public void initDatabase() {
        pl = new PersistenceLayer(getFileBasedDatabaseConnectionPool());
    }

    /**
     * assert that there is a way to store a borrower
     * in a database.  We don't actually care how this happens,
     * we just care that it exists.  Here we're adding a
     * brand-spanking-new borrower.
     */
    @Test
    public void testShouldSaveBorrowerToDatabase() {
        pl.cleanAndMigrateDatabase();

        long id = pl.saveNewBorrower(DEFAULT_BORROWER.name);

        assertEquals("The first row in a database gets an index of 1", 1, id);
    }

    /**
     * We ought to be able to update a borrower's details,
     * if we know that borrower's id and we have a detail we
     * want to change.
     */
    @Test
    public void testShouldUpdateBorrowerToDatabase() {
        // the borrower with id of 1 is "alice"
        runRestoreOneBookOneBorrower();
        final String newName = "bob";

        // change the borrower's name
        pl.updateBorrower(1, newName);

        String name = pl.getBorrowerName(1).orElseThrow();
        assertEquals(newName, name);
    }

    /**
     * If a borrower is in the database, we should be able
     * to find that person by their name
     */
    @Test
    public void testShouldBeAbleToSearchBorrowerByName() {
        runRestoreOneBookOneBorrower();

        Borrower borrower = pl.searchBorrowerDataByName(DEFAULT_BORROWER.name).orElseThrow();

        assertEquals(DEFAULT_BORROWER, borrower);
    }

    /**
     * If a book is in the database, we should be able to find it by title.
     */
    @Test
    public void testShouldBeAbleToSearchForBooksByTitle() {
        runRestoreOneBookOneBorrower();
        final Book expectedBook = new Book(1, DEFAULT_BOOK.title);

        Book book = pl.searchBooksByTitle(DEFAULT_BOOK.title).orElseThrow();

        assertEquals(expectedBook, book);
    }

    /**
     * If a book is in the database, we should be able to find it by id.
     */
    @Test
    public void testShouldBeAbleToSearchForBooksById() {
        // this will set the default book into the database
        runRestoreOneBookOneBorrower();
        final Book expectedBook = new Book(1, DEFAULT_BOOK.title);

        // search for it by id
        Book book = pl.searchBooksById(DEFAULT_BOOK.id).orElseThrow();

        assertEquals(expectedBook, book);
    }

    /**
     * If a borrower is in the database, we should be able to find it by id.
     */
    @Test
    public void testShouldBeAbleToSearchForBorrowersById() {
        runRestoreOneBookOneBorrower();

        Borrower borrower = pl.searchBorrowersById(DEFAULT_BORROWER.id).orElseThrow();

        assertEquals(DEFAULT_BORROWER, borrower);
    }

    @Test
    public void testShouldBeAbleToSearchAUserByName() {
        runRestoreOneUser();

        User user = pl.searchForUserByName(DEFAULT_USER.name).orElseThrow();

        assertEquals(DEFAULT_USER, user);
    }

    @Test
    public void testThatWeCanUpdateAUsersPassword() {
        runRestoreOneUser();
        final String newPassword = "abc123";

        pl.updateUserWithPassword(1, newPassword);
        final boolean result = pl.areCredentialsValid(DEFAULT_BORROWER.name, newPassword).orElseThrow();

        assertTrue(result);
    }

    @Test
    public void testWeCanCreateLoan() {
        runRestoreOneBookOneBorrower();

        final long loanId = pl.createLoan(DEFAULT_BOOK, DEFAULT_BORROWER, BORROW_DATE);

        assertEquals(1, loanId);
    }


    @Test
    public void testWeCanSearchForALoanByABook() {
        runRestoreOneLoan();

        Loan loan = pl.searchForLoanByBook(DEFAULT_BOOK).orElseThrow();

        assertEquals(DEFAULT_LOAN, loan);
    }

    @Test
    public void testWeCanSearchForALoanByABorrower() {
        runRestoreOneLoan();

        Loan loan = pl.searchForLoanByBorrower(DEFAULT_BORROWER).get().get(0);

        assertEquals(DEFAULT_LOAN, loan);
    }

    @Test
    public void testWeCanSaveANewUser() {
        pl.cleanAndMigrateDatabase();

        long id = pl.saveNewUser(DEFAULT_USER.name);

        assertEquals(DEFAULT_USER.id, id);
    }

    @Test
    public void testWeCanSaveABook() {
        pl.cleanAndMigrateDatabase();

        long id = pl.saveNewBook(DEFAULT_BOOK.title);

        assertEquals(DEFAULT_BOOK.id, id);
    }

    @Test
    public void testWeCanCreateALoan() {
        runRestoreOneBookOneBorrower();

        long id = pl.createLoan(DEFAULT_BOOK, DEFAULT_BORROWER, BORROW_DATE);

        assertEquals(DEFAULT_LOAN.id, id);
    }

    @Test
    public void testShouldBeAbleToDeleteBook() {
        runRestoreOneBookOneBorrower();

        pl.deleteBook(DEFAULT_BOOK.id);
        final Optional<Book> book = pl.searchBooksByTitle(DEFAULT_BOOK.title);

        assertTrue(book.isEmpty());
    }

    @Test
    public void testShouldBeAbleToDeleteBorrower() {
        runRestoreOneBookOneBorrower();

        pl.deleteBorrower(DEFAULT_BORROWER.id);
        final Optional<Borrower> borrower = pl.searchBorrowerDataByName(DEFAULT_BORROWER.name);

        assertTrue(borrower.isEmpty());
    }

    @Test
    public void testShouldListAllBooks() {
        runRestoreOneBookOneBorrower();
        List<Book> expectedList = Arrays.asList(DEFAULT_BOOK);

        final List<Book> books = pl.listAllBooks().orElseThrow();

        assertEquals(expectedList, books);
    }

    @Test
    public void testShouldListAvailableBooks() {
        runRestoreThreeBooksThreeBorrowers();
        // loan out a book
        pl.createLoan(pl.searchBooksByTitle("b").orElseThrow(), pl.searchBorrowerDataByName("alice").orElseThrow(), BORROW_DATE);

        // create expected book list
        final List<Book> expectedBooks = new ArrayList<>();
        expectedBooks.add(new Book(1, "a"));
        expectedBooks.add(new Book(3, "c"));

        // act
        final List<Book> books = pl.listAvailableBooks().orElseThrow();

        // assert
        assertEquals(expectedBooks, books);
    }


    /**
     * If you check them all out - you'll get nothing in the available list.
     */
    @Test
    public void testShouldListNoAvailableBooksIfAllCheckedOut() {
        runRestoreThreeBooksThreeBorrowers();
        // loan out a book
        pl.createLoan(pl.searchBooksByTitle("a").orElseThrow(), pl.searchBorrowerDataByName("alice").orElseThrow(), BORROW_DATE);
        pl.createLoan(pl.searchBooksByTitle("b").orElseThrow(), pl.searchBorrowerDataByName("alice").orElseThrow(), BORROW_DATE);
        pl.createLoan(pl.searchBooksByTitle("c").orElseThrow(), pl.searchBorrowerDataByName("alice").orElseThrow(), BORROW_DATE);

        // act
        final Optional<List<Book>> books = pl.listAvailableBooks();

        // assert
        assertTrue(books.isEmpty());
    }

    /**
     * If none are checked out - you'll get everything in the available list.
     */
    @Test
    public void testShouldListAllBooksIfNoneCheckedOut() {
        runRestoreThreeBooksThreeBorrowers();
        // create expected book list
        final List<Book> expectedBooks = new ArrayList<>();
        expectedBooks.add(new Book(1, "a"));
        expectedBooks.add(new Book(2, "b"));
        expectedBooks.add(new Book(3, "c"));

        // act
        final List<Book> books = pl.listAvailableBooks().orElseThrow();

        // assert
        assertEquals(expectedBooks, books);
    }

    @Test
    public void testShouldListAllBorrowers() {
        runRestoreOneBookOneBorrower();
        List<Borrower> expectedList = Arrays.asList(DEFAULT_BORROWER);

        final List<Borrower> borrowers = pl.listAllBorrowers().orElseThrow();

        assertEquals(expectedList, borrowers);
    }

    @Test(expected = SqlRuntimeException.class)
    public void testThatExecuteInsertOnPreparedStatementHandlesExceptions() throws SQLException {
        final PersistenceLayer persistenceLayer = new PersistenceLayer();
        final PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        final ResultSet resultSet = Mockito.mock(ResultSet.class);
        when(resultSet.next()).thenReturn(false);
        when(preparedStatement.getGeneratedKeys()).thenReturn(resultSet);

        persistenceLayer.executeInsertOnPreparedStatement(SqlData.createEmpty(), preparedStatement);
    }

    /**
     * Test what happens if no value is returned when we provide an
     * id to a particular user.
     */
    @Test
    public void testGetBorrowerName_WhenNoValueReturned() throws SQLException {
        final DataSource dataSource = Mockito.mock(DataSource.class);
        final PersistenceLayer persistenceLayer = new PersistenceLayer(dataSource);
        final Connection connection = Mockito.mock(Connection.class);
        final PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        when(connection.prepareStatement(Mockito.anyString())).thenReturn(preparedStatement);
        when(dataSource.getConnection()).thenReturn(connection);
        final ResultSet resultSet = Mockito.mock(ResultSet.class);
        when(resultSet.next()).thenReturn(false);
        when(preparedStatement.executeQuery()).thenReturn(resultSet);

        final Optional<String> borrowerName = persistenceLayer.getBorrowerName(1);

        assertTrue(borrowerName.isEmpty());
    }

    /**
     * Test what happens when an exception occurs in getBorrowerName
     */
    @Test(expected = SqlRuntimeException.class)
    public void testGetBorrowerName_WhenExceptionThrown() throws SQLException {
        final DataSource dataSource = Mockito.mock(DataSource.class);
        when(dataSource.getConnection()).thenThrow(new SQLException());
        final PersistenceLayer persistenceLayer = new PersistenceLayer(dataSource);

        persistenceLayer.getBorrowerName(1);
    }

    /**
     * An exception of the right type should be thrown
     * when an error occurs in the {@link PersistenceLayer#executeUpdateTemplate} method.
     */
    @Test(expected = SqlRuntimeException.class)
    public void testExecuteUpdateTemplate_ExceptionThrown() throws SQLException {
        final DataSource dataSource = Mockito.mock(DataSource.class);
        when(dataSource.getConnection()).thenThrow(new SQLException());
        final PersistenceLayer persistenceLayer = new PersistenceLayer(dataSource);

        persistenceLayer.executeUpdateTemplate("","");
    }

    /**
     * This can be run here, simply put @Test on top.
     */
    public void runBackup() {
        pl.runBackup("v2_three_books_three_borrowers.sql");
    }

    /**
     * This can be run here, simply put @Test on top.
     */
    public void setState() {
        runRestoreOneBookOneBorrower();
    }

    /**
     * this will set "alice" with id of 1 into the database as a borrower
     * and "The DevOps Handbook" with id of 1 as a book.
     */
    private void runRestoreOneBookOneBorrower() {
        runRestore("v2_one_book_one_borrower.sql");
    }

    private void runRestoreOneUser() {
        runRestore("v2_one_user.sql");
    }

    private void runRestoreOneLoan() {
        runRestore("v2_one_loan.sql");
    }

    /**
     * This backup has books: a, b, and c.  The borrowers are alice, bob, and carol
     */
    private void runRestoreThreeBooksThreeBorrowers() {
        runRestore("v2_three_books_three_borrowers.sql");
    }

    private void runRestore(String scriptName) {
        pl.runRestore(scriptName);
    }

    /**
     * Get a file-based {@link JdbcConnectionPool}, which makes it easier
     * to debug database tests when they are running.
     * <p>
     * Because we set AUTO_SERVER to true, we can access this database
     * from multiple places when it starts.
     * <p>
     * This method is solely meant to be used by database tests.
     */
    private static JdbcConnectionPool getFileBasedDatabaseConnectionPool() {
        return JdbcConnectionPool.create(
                "jdbc:h2:./build/db/training;AUTO_SERVER=TRUE;MODE=PostgreSQL", "", "");
    }


}



================================================
FILE: src/integration_test/resources/db_sample_files/README.txt
================================================
These are the backups of the library database, used during integration
testing.  Notice the naming scheme - each starts with the version of the
database, which originates from the Flyway scripts - see that folder.

We would always want to keep the version of our backups the same as the
version of the database migration scripts because our integration tests
assume a correct and current schema. That is, unless, however, we are specifically
testing that a database script successfully transitions the schema without
corrupting data, which is a valid and common concern during development.


================================================
FILE: src/integration_test/resources/db_sample_files/v2_empty_schema.sql
================================================
;             
CREATE USER IF NOT EXISTS SA SALT '7ab557eb69745223' HASH '8a3855f1eb198976108dae4d0d5cdf5eb907e73321db99c043737af0124852f6' ADMIN;           
CREATE SCHEMA IF NOT EXISTS ADMINISTRATIVE AUTHORIZATION SA;  
CREATE SCHEMA IF NOT EXISTS AUTH AUTHORIZATION SA;            
CREATE SCHEMA IF NOT EXISTS LIBRARY AUTHORIZATION SA;         
CREATE SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722 START WITH 1 BELONGS_TO_TABLE;      
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B START WITH 1 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0 START WITH 1 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E START WITH 1 BELONGS_TO_TABLE;   
CREATE CACHED TABLE ADMINISTRATIVE."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE ADMINISTRATIVE."flyway_schema_history" ADD CONSTRAINT ADMINISTRATIVE."flyway_schema_history_pk" PRIMARY KEY("installed_rank");    
-- 3 +/- SELECT COUNT(*) FROM ADMINISTRATIVE."flyway_schema_history";         
INSERT INTO ADMINISTRATIVE."flyway_schema_history"("installed_rank", "version", "description", "type", "script", "checksum", "installed_by", "installed_on", "execution_time", "success") VALUES
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, 'SA', TIMESTAMP '2019-01-31 17:35:59.667', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, 'SA', TIMESTAMP '2019-01-31 17:35:59.691', 3, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1767572289, 'SA', TIMESTAMP '2019-01-31 17:35:59.706', 9, TRUE);         
CREATE INDEX ADMINISTRATIVE."flyway_schema_history_s_idx" ON ADMINISTRATIVE."flyway_schema_history"("success");               
CREATE CACHED TABLE LIBRARY.BORROWER(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B,
    NAME VARCHAR(100) NOT NULL
);   
ALTER TABLE LIBRARY.BORROWER ADD CONSTRAINT LIBRARY.CONSTRAINT_A PRIMARY KEY(ID);             
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
CREATE CACHED TABLE LIBRARY.BOOK(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0,
    TITLE VARCHAR(100) NOT NULL
);      
ALTER TABLE LIBRARY.BOOK ADD CONSTRAINT LIBRARY.CONSTRAINT_1 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
CREATE CACHED TABLE LIBRARY.LOAN(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E,
    BOOK INT NOT NULL,
    BORROWER INT NOT NULL,
    BORROW_DATE DATE NOT NULL
);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_2 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
CREATE CACHED TABLE AUTH.USER(
    ID INT DEFAULT (NEXT VALUE FOR AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722) NOT NULL NULL_TO_DEFAULT SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722,
    NAME VARCHAR(100) NOT NULL,
    PASSWORD_HASH VARCHAR(100)
);               
ALTER TABLE AUTH.USER ADD CONSTRAINT AUTH.CONSTRAINT_2 PRIMARY KEY(ID);       
-- 0 +/- SELECT COUNT(*) FROM AUTH.USER;      
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23B FOREIGN KEY(BORROWER) REFERENCES LIBRARY.BORROWER(ID) NOCHECK; 
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23 FOREIGN KEY(BOOK) REFERENCES LIBRARY.BOOK(ID) NOCHECK;          



================================================
FILE: src/integration_test/resources/db_sample_files/v2_one_book_one_borrower.sql
================================================
;             
CREATE USER IF NOT EXISTS SA SALT '7ab557eb69745223' HASH '8a3855f1eb198976108dae4d0d5cdf5eb907e73321db99c043737af0124852f6' ADMIN;           
CREATE SCHEMA IF NOT EXISTS ADMINISTRATIVE AUTHORIZATION SA;  
CREATE SCHEMA IF NOT EXISTS AUTH AUTHORIZATION SA;            
CREATE SCHEMA IF NOT EXISTS LIBRARY AUTHORIZATION SA;         
CREATE SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722 START WITH 1 BELONGS_TO_TABLE;      
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B START WITH 2 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0 START WITH 2 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E START WITH 1 BELONGS_TO_TABLE;   
CREATE CACHED TABLE ADMINISTRATIVE."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE ADMINISTRATIVE."flyway_schema_history" ADD CONSTRAINT ADMINISTRATIVE."flyway_schema_history_pk" PRIMARY KEY("installed_rank");    
-- 3 +/- SELECT COUNT(*) FROM ADMINISTRATIVE."flyway_schema_history";         
INSERT INTO ADMINISTRATIVE."flyway_schema_history"("installed_rank", "version", "description", "type", "script", "checksum", "installed_by", "installed_on", "execution_time", "success") VALUES
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, 'SA', TIMESTAMP '2019-01-31 17:35:59.667', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, 'SA', TIMESTAMP '2019-01-31 17:35:59.691', 3, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1767572289, 'SA', TIMESTAMP '2019-01-31 17:35:59.706', 9, TRUE);         
CREATE INDEX ADMINISTRATIVE."flyway_schema_history_s_idx" ON ADMINISTRATIVE."flyway_schema_history"("success");               
CREATE CACHED TABLE LIBRARY.BORROWER(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B,
    NAME VARCHAR(100) NOT NULL
);   
ALTER TABLE LIBRARY.BORROWER ADD CONSTRAINT LIBRARY.CONSTRAINT_A PRIMARY KEY(ID);             
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
INSERT INTO LIBRARY.BORROWER(ID, NAME) VALUES
(1, 'alice');  
CREATE CACHED TABLE LIBRARY.BOOK(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0,
    TITLE VARCHAR(100) NOT NULL
);      
ALTER TABLE LIBRARY.BOOK ADD CONSTRAINT LIBRARY.CONSTRAINT_1 PRIMARY KEY(ID); 
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
INSERT INTO LIBRARY.BOOK(ID, TITLE) VALUES
(1, 'The DevOps Handbook');       
CREATE CACHED TABLE LIBRARY.LOAN(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E,
    BOOK INT NOT NULL,
    BORROWER INT NOT NULL,
    BORROW_DATE DATE NOT NULL
);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_2 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
CREATE CACHED TABLE AUTH.USER(
    ID INT DEFAULT (NEXT VALUE FOR AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722) NOT NULL NULL_TO_DEFAULT SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722,
    NAME VARCHAR(100) NOT NULL,
    PASSWORD_HASH VARCHAR(100)
);               
ALTER TABLE AUTH.USER ADD CONSTRAINT AUTH.CONSTRAINT_2 PRIMARY KEY(ID);       
-- 0 +/- SELECT COUNT(*) FROM AUTH.USER;      
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23B FOREIGN KEY(BORROWER) REFERENCES LIBRARY.BORROWER(ID) NOCHECK; 
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23 FOREIGN KEY(BOOK) REFERENCES LIBRARY.BOOK(ID) NOCHECK;          



================================================
FILE: src/integration_test/resources/db_sample_files/v2_one_loan.sql
================================================
;             
CREATE USER IF NOT EXISTS SA SALT '7ab557eb69745223' HASH '8a3855f1eb198976108dae4d0d5cdf5eb907e73321db99c043737af0124852f6' ADMIN;           
CREATE SCHEMA IF NOT EXISTS ADMINISTRATIVE AUTHORIZATION SA;  
CREATE SCHEMA IF NOT EXISTS AUTH AUTHORIZATION SA;            
CREATE SCHEMA IF NOT EXISTS LIBRARY AUTHORIZATION SA;         
CREATE SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722 START WITH 1 BELONGS_TO_TABLE;      
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B START WITH 2 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0 START WITH 2 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E START WITH 2 BELONGS_TO_TABLE;   
CREATE CACHED TABLE ADMINISTRATIVE."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE ADMINISTRATIVE."flyway_schema_history" ADD CONSTRAINT ADMINISTRATIVE."flyway_schema_history_pk" PRIMARY KEY("installed_rank");    
-- 3 +/- SELECT COUNT(*) FROM ADMINISTRATIVE."flyway_schema_history";         
INSERT INTO ADMINISTRATIVE."flyway_schema_history"("installed_rank", "version", "description", "type", "script", "checksum", "installed_by", "installed_on", "execution_time", "success") VALUES
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, 'SA', TIMESTAMP '2019-01-31 17:35:59.667', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, 'SA', TIMESTAMP '2019-01-31 17:35:59.691', 3, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1767572289, 'SA', TIMESTAMP '2019-01-31 17:35:59.706', 9, TRUE);         
CREATE INDEX ADMINISTRATIVE."flyway_schema_history_s_idx" ON ADMINISTRATIVE."flyway_schema_history"("success");               
CREATE CACHED TABLE LIBRARY.BORROWER(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B,
    NAME VARCHAR(100) NOT NULL
);   
ALTER TABLE LIBRARY.BORROWER ADD CONSTRAINT LIBRARY.CONSTRAINT_A PRIMARY KEY(ID);             
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
INSERT INTO LIBRARY.BORROWER(ID, NAME) VALUES
(1, 'alice');  
CREATE CACHED TABLE LIBRARY.BOOK(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0,
    TITLE VARCHAR(100) NOT NULL
);      
ALTER TABLE LIBRARY.BOOK ADD CONSTRAINT LIBRARY.CONSTRAINT_1 PRIMARY KEY(ID); 
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
INSERT INTO LIBRARY.BOOK(ID, TITLE) VALUES
(1, 'The DevOps Handbook');       
CREATE CACHED TABLE LIBRARY.LOAN(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E,
    BOOK INT NOT NULL,
    BORROWER INT NOT NULL,
    BORROW_DATE DATE NOT NULL
);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_2 PRIMARY KEY(ID); 
-- 1 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
INSERT INTO LIBRARY.LOAN(ID, BOOK, BORROWER, BORROW_DATE) VALUES
(1, 1, 1, DATE '2018-01-01');               
CREATE CACHED TABLE AUTH.USER(
    ID INT DEFAULT (NEXT VALUE FOR AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722) NOT NULL NULL_TO_DEFAULT SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722,
    NAME VARCHAR(100) NOT NULL,
    PASSWORD_HASH VARCHAR(100)
);               
ALTER TABLE AUTH.USER ADD CONSTRAINT AUTH.CONSTRAINT_2 PRIMARY KEY(ID);       
-- 0 +/- SELECT COUNT(*) FROM AUTH.USER;      
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23B FOREIGN KEY(BORROWER) REFERENCES LIBRARY.BORROWER(ID) NOCHECK; 
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23 FOREIGN KEY(BOOK) REFERENCES LIBRARY.BOOK(ID) NOCHECK;          



================================================
FILE: src/integration_test/resources/db_sample_files/v2_one_user.sql
================================================
;             
CREATE USER IF NOT EXISTS SA SALT '7ab557eb69745223' HASH '8a3855f1eb198976108dae4d0d5cdf5eb907e73321db99c043737af0124852f6' ADMIN;           
CREATE SCHEMA IF NOT EXISTS ADMINISTRATIVE AUTHORIZATION SA;  
CREATE SCHEMA IF NOT EXISTS AUTH AUTHORIZATION SA;            
CREATE SCHEMA IF NOT EXISTS LIBRARY AUTHORIZATION SA;         
CREATE SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722 START WITH 2 BELONGS_TO_TABLE;      
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B START WITH 1 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0 START WITH 1 BELONGS_TO_TABLE;   
CREATE SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E START WITH 1 BELONGS_TO_TABLE;   
CREATE CACHED TABLE ADMINISTRATIVE."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP() NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE ADMINISTRATIVE."flyway_schema_history" ADD CONSTRAINT ADMINISTRATIVE."flyway_schema_history_pk" PRIMARY KEY("installed_rank");    
-- 3 +/- SELECT COUNT(*) FROM ADMINISTRATIVE."flyway_schema_history";         
INSERT INTO ADMINISTRATIVE."flyway_schema_history"("installed_rank", "version", "description", "type", "script", "checksum", "installed_by", "installed_on", "execution_time", "success") VALUES
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, 'SA', TIMESTAMP '2019-01-31 17:35:59.667', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, 'SA', TIMESTAMP '2019-01-31 17:35:59.691', 3, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1767572289, 'SA', TIMESTAMP '2019-01-31 17:35:59.706', 9, TRUE);         
CREATE INDEX ADMINISTRATIVE."flyway_schema_history_s_idx" ON ADMINISTRATIVE."flyway_schema_history"("success");               
CREATE CACHED TABLE LIBRARY.BORROWER(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_5EFEED8B_6D6F_4F38_B7F2_220445FE4B5B,
    NAME VARCHAR(100) NOT NULL
);   
ALTER TABLE LIBRARY.BORROWER ADD CONSTRAINT LIBRARY.CONSTRAINT_A PRIMARY KEY(ID);             
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
CREATE CACHED TABLE LIBRARY.BOOK(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_77FCB39D_27DD_4D20_81B0_DB61CDF1A6B0,
    TITLE VARCHAR(100) NOT NULL
);      
ALTER TABLE LIBRARY.BOOK ADD CONSTRAINT LIBRARY.CONSTRAINT_1 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
CREATE CACHED TABLE LIBRARY.LOAN(
    ID INT DEFAULT (NEXT VALUE FOR LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E) NOT NULL NULL_TO_DEFAULT SEQUENCE LIBRARY.SYSTEM_SEQUENCE_4DC22436_9D2A_4365_80D1_96EAA7B0932E,
    BOOK INT NOT NULL,
    BORROWER INT NOT NULL,
    BORROW_DATE DATE NOT NULL
);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_2 PRIMARY KEY(ID); 
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
CREATE CACHED TABLE AUTH.USER(
    ID INT DEFAULT (NEXT VALUE FOR AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722) NOT NULL NULL_TO_DEFAULT SEQUENCE AUTH.SYSTEM_SEQUENCE_EBB7E93A_A8A2_4BE4_9D42_F602FF467722,
    NAME VARCHAR(100) NOT NULL,
    PASSWORD_HASH VARCHAR(100)
);               
ALTER TABLE AUTH.USER ADD CONSTRAINT AUTH.CONSTRAINT_2 PRIMARY KEY(ID);       
-- 1 +/- SELECT COUNT(*) FROM AUTH.USER;      
INSERT INTO AUTH.USER(ID, NAME, PASSWORD_HASH) VALUES
(1, 'alice', NULL);    
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23B FOREIGN KEY(BORROWER) REFERENCES LIBRARY.BORROWER(ID) NOCHECK; 
ALTER TABLE LIBRARY.LOAN ADD CONSTRAINT LIBRARY.CONSTRAINT_23 FOREIGN KEY(BOOK) REFERENCES LIBRARY.BOOK(ID) NOCHECK;          



================================================
FILE: src/integration_test/resources/db_sample_files/v2_three_books_three_borrowers.sql
================================================
;             
CREATE USER IF NOT EXISTS "" SALT '' HASH '' ADMIN;           
CREATE SCHEMA IF NOT EXISTS "ADMINISTRATIVE" AUTHORIZATION "";
CREATE SCHEMA IF NOT EXISTS "AUTH" AUTHORIZATION "";          
CREATE SCHEMA IF NOT EXISTS "LIBRARY" AUTHORIZATION "";       
CREATE SEQUENCE "AUTH"."SYSTEM_SEQUENCE_6608652E_F4BC_46BC_A456_0FCA964E591D" START WITH 1 BELONGS_TO_TABLE;  
CREATE SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_A08E4C08_164A_4348_9A78_C229789BAEF3" START WITH 4 BELONGS_TO_TABLE;               
CREATE SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_A416DDFE_1291_4BF1_B8C0_7F3A8EC53F92" START WITH 4 BELONGS_TO_TABLE;               
CREATE SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_C4EA4E4C_FC2D_4DF9_9937_3D93A483B1EE" START WITH 1 BELONGS_TO_TABLE;               
CREATE CACHED TABLE "ADMINISTRATIVE"."flyway_schema_history"(
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL
);     
ALTER TABLE "ADMINISTRATIVE"."flyway_schema_history" ADD CONSTRAINT "ADMINISTRATIVE"."flyway_schema_history_pk" PRIMARY KEY("installed_rank");
-- 4 +/- SELECT COUNT(*) FROM ADMINISTRATIVE.flyway_schema_history;           
INSERT INTO "ADMINISTRATIVE"."flyway_schema_history" VALUES
(-1, NULL, '<< Flyway Schema History table created >>', 'TABLE', '', NULL, '', TIMESTAMP '2020-04-14 22:19:07.888525', 0, TRUE),
(0, NULL, '<< Flyway Schema Creation >>', 'SCHEMA', '"ADMINISTRATIVE","LIBRARY","AUTH"', NULL, '', TIMESTAMP '2020-04-14 22:19:07.888525', 0, TRUE),
(1, '1', 'Create person table', 'SQL', 'V1__Create_person_table.sql', 2000967190, '', TIMESTAMP '2020-04-14 22:19:07.919772', 2, TRUE),
(2, '2', 'Rest of tables for auth and library', 'SQL', 'V2__Rest_of_tables_for_auth_and_library.sql', 1047360475, '', TIMESTAMP '2020-04-14 22:19:07.95102', 6, TRUE);          
CREATE INDEX "ADMINISTRATIVE"."flyway_schema_history_s_idx" ON "ADMINISTRATIVE"."flyway_schema_history"("success");           
CREATE CACHED TABLE "LIBRARY"."BORROWER"(
    "ID" INT DEFAULT (NEXT VALUE FOR "LIBRARY"."SYSTEM_SEQUENCE_A08E4C08_164A_4348_9A78_C229789BAEF3") NOT NULL NULL_TO_DEFAULT SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_A08E4C08_164A_4348_9A78_C229789BAEF3",
    "NAME" VARCHAR(100) NOT NULL
);   
ALTER TABLE "LIBRARY"."BORROWER" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_A" PRIMARY KEY("ID");   
-- 3 +/- SELECT COUNT(*) FROM LIBRARY.BORROWER;               
INSERT INTO "LIBRARY"."BORROWER" VALUES
(1, 'alice'),
(2, 'bob'),
(3, 'carol');            
CREATE CACHED TABLE "LIBRARY"."BOOK"(
    "ID" INT DEFAULT (NEXT VALUE FOR "LIBRARY"."SYSTEM_SEQUENCE_A416DDFE_1291_4BF1_B8C0_7F3A8EC53F92") NOT NULL NULL_TO_DEFAULT SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_A416DDFE_1291_4BF1_B8C0_7F3A8EC53F92",
    "TITLE" VARCHAR(100) NOT NULL
);      
ALTER TABLE "LIBRARY"."BOOK" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_1" PRIMARY KEY("ID");       
-- 3 +/- SELECT COUNT(*) FROM LIBRARY.BOOK;   
INSERT INTO "LIBRARY"."BOOK" VALUES
(1, 'a'),
(2, 'b'),
(3, 'c');          
CREATE CACHED TABLE "LIBRARY"."LOAN"(
    "ID" INT DEFAULT (NEXT VALUE FOR "LIBRARY"."SYSTEM_SEQUENCE_C4EA4E4C_FC2D_4DF9_9937_3D93A483B1EE") NOT NULL NULL_TO_DEFAULT SEQUENCE "LIBRARY"."SYSTEM_SEQUENCE_C4EA4E4C_FC2D_4DF9_9937_3D93A483B1EE",
    "BOOK" INT NOT NULL,
    "BORROWER" INT NOT NULL,
    "BORROW_DATE" DATE NOT NULL
);
ALTER TABLE "LIBRARY"."LOAN" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_2" PRIMARY KEY("ID");       
-- 0 +/- SELECT COUNT(*) FROM LIBRARY.LOAN;   
CREATE CACHED TABLE "AUTH"."USER"(
    "ID" INT DEFAULT (NEXT VALUE FOR "AUTH"."SYSTEM_SEQUENCE_6608652E_F4BC_46BC_A456_0FCA964E591D") NOT NULL NULL_TO_DEFAULT SEQUENCE "AUTH"."SYSTEM_SEQUENCE_6608652E_F4BC_46BC_A456_0FCA964E591D",
    "NAME" VARCHAR(100) NOT NULL,
    "PASSWORD_HASH" VARCHAR(100)
);             
ALTER TABLE "AUTH"."USER" ADD CONSTRAINT "AUTH"."CONSTRAINT_2" PRIMARY KEY("ID");             
-- 0 +/- SELECT COUNT(*) FROM AUTH.USER;      
ALTER TABLE "LIBRARY"."LOAN" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_23B" FOREIGN KEY("BORROWER") REFERENCES "LIBRARY"."BORROWER"("ID") ON DELETE CASCADE NOCHECK;               
ALTER TABLE "LIBRARY"."LOAN" ADD CONSTRAINT "LIBRARY"."CONSTRAINT_23" FOREIGN KEY("BOOK") REFERENCES "LIBRARY"."BOOK"("ID") ON DELETE CASCADE NOCHECK;        



================================================
FILE: src/main/java/com/coveros/training/README.txt
================================================
These different folders describe the different feature areas of the Demo application.

authentication   :  things like usernames, passwords, accouunts
cartesianproduct :  calculating the cartesian product of multiple sets
expenses         :  calculating restaurant expenses
helpers          :  cross-functional helper classes
library          :  books, borrowers, lending
mathematics      :  various math functionality
persistence      :  provides database access
tomcat           :  configures Tomcat


================================================
FILE: src/main/java/com/coveros/training/authentication/LoginServlet.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Provides an API endpoint for login.
 * <p>
 * A user (librarian) enters their username and password to authenticate.
 * </p>
 */
@WebServlet(name = "LoginServlet", urlPatterns = {"/login"}, loadOnStartup = 1)
public class LoginServlet extends HttpServlet {

    private static final long serialVersionUID = 7302828964216520580L;
    private static final Logger logger = LoggerFactory.getLogger(LoginServlet.class);
    static LoginUtils loginUtils = new LoginUtils();

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        String username = StringUtils.makeNotNullable(request.getParameter("username"));
        request.setAttribute("username", username);

        String password = StringUtils.makeNotNullable(request.getParameter("password"));
        request.setAttribute("password", password);

        String responseText;

        if (username.isEmpty()) {
            responseText = "no username provided";
        } else if (password.isEmpty()) {
            responseText = "no password provided";
        } else {
            logger.info("received request to authenticate a user, {}", username);

            final boolean userRegistered = loginUtils.isUserRegistered(username, password);
            responseText = userRegistered ? "access granted" : "access denied";
        }

        request.setAttribute("result", responseText);
        request.setAttribute("return_page", "library.html");
        ServletUtils.forwardToResult(request, response, logger);
    }

}




================================================
FILE: src/main/java/com/coveros/training/authentication/LoginUtils.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.helpers.CheckUtils;
import com.coveros.training.persistence.IPersistenceLayer;
import com.coveros.training.persistence.PersistenceLayer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Provides business-layer for determining if entered credentials qualify for authentication
 */
public class LoginUtils {

    private static final Logger logger = LoggerFactory.getLogger(LoginUtils.class);
    private final IPersistenceLayer persistenceLayer;

    public LoginUtils(IPersistenceLayer persistenceLayer) {
        this.persistenceLayer = persistenceLayer;
    }

    public LoginUtils() {
        this(new PersistenceLayer());
    }

    /**
     * Determine if input is correct credentials for a registered user.
     * @return true if the credentials are valid, false otherwise
     */
    public boolean isUserRegistered(String username, String password) {
        CheckUtils.StringMustNotBeNullOrEmpty(username, password);
        logger.info("checking if credentials for {} are valid for login", username);
        boolean isValid = persistenceLayer.areCredentialsValid(username, password).orElse(false);
        if (isValid) {
            logger.info("credentials for {} are valid - granting access", username);
        } else {
            logger.info("credentials for {} were invalid - denying access", username);
        }
        return isValid;
    }

    public static LoginUtils createEmpty() {
        return new LoginUtils(PersistenceLayer.createEmpty());
    }

    public boolean isEmpty() {
        return persistenceLayer.isEmpty();
    }

}



================================================
FILE: src/main/java/com/coveros/training/authentication/package-info.java
================================================
/**
 * Authentication mechanisms - usernames, passwords, etc.
 */
package com.coveros.training.authentication;


================================================
FILE: src/main/java/com/coveros/training/authentication/RegisterServlet.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.authentication.domainobjects.RegistrationResult;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Provides an API endpoint to register a new user, recording their username and (a hash of their) password
 */
@WebServlet(name = "RegisterServlet", urlPatterns = {"/register"}, loadOnStartup = 1)
public class RegisterServlet extends HttpServlet {

    private static final String PASSWORD_PARAM = "password";
    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(RegisterServlet.class);
    private static final String USERNAME_PARAM = "username";
    static RegistrationUtils registrationUtils = new RegistrationUtils();

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        String username = StringUtils.makeNotNullable(request.getParameter(USERNAME_PARAM));
        request.setAttribute(USERNAME_PARAM, username);

        String password = StringUtils.makeNotNullable(request.getParameter(PASSWORD_PARAM));
        request.setAttribute(PASSWORD_PARAM, password);

        String responseText;

        if (username.isEmpty()) {
            responseText = "no username provided";
        } else if (password.isEmpty()) {
            responseText = "no password provided";
        } else {

            logger.info("received request to register a user, {}", username);

            RegistrationResult registrationResult = registrationUtils.processRegistration(username, password);

            responseText = registrationResult.toPrettyString();
        }

        request.setAttribute("result", responseText);
        request.setAttribute("return_page", "library.html");
        forwardToResult(request, response, logger);
    }

    /**
     * Wrapping a static method call for testing.
     */
    private void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        ServletUtils.forwardToResult(request, response, logger);
    }

}




================================================
FILE: src/main/java/com/coveros/training/authentication/RegistrationUtils.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.authentication.domainobjects.PasswordResult;
import com.coveros.training.authentication.domainobjects.RegistrationResult;
import com.coveros.training.helpers.CheckUtils;
import com.coveros.training.persistence.IPersistenceLayer;
import com.coveros.training.persistence.PersistenceLayer;
import me.gosimple.nbvcxz.Nbvcxz;
import me.gosimple.nbvcxz.scoring.Result;
import me.gosimple.nbvcxz.scoring.TimeEstimate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.coveros.training.authentication.domainobjects.PasswordResultEnums.EMPTY_PASSWORD;
import static com.coveros.training.authentication.domainobjects.PasswordResultEnums.*;
import static com.coveros.training.authentication.domainobjects.RegistrationStatusEnums.*;
import static com.coveros.training.helpers.CheckUtils.StringMustNotBeNullOrEmpty;

/**
 * Provides logic for registering a new user
 */
public class RegistrationUtils {

    private static final Logger logger = LoggerFactory.getLogger(RegistrationUtils.class);

    private final IPersistenceLayer persistenceLayer;

    public RegistrationUtils(IPersistenceLayer persistenceLayer) {
        this.persistenceLayer = persistenceLayer;
    }

    public RegistrationUtils() {
        this(new PersistenceLayer());
    }

    /**
     * A business process to evaluate an attempt to register a new user.
     * <ol>
     *     <li>Make sure the username and password aren't null or empty</li>
     *     <li>Make sure the user isn't already in the database</li>
     *     <li>Check if the password is sufficiently complex to be secure</li>
     *     <li>Create a new account for this user, saving the user's credentials</li>
     * </ol>
     */
    public RegistrationResult processRegistration(String username, String password) {
        logger.info("Starting registration");
        StringMustNotBeNullOrEmpty(username);
        StringMustNotBeNullOrEmpty(password);

        if (isUserInDatabase(username)) {
            logger.info("cannot register this user - they are already registered");
            return new RegistrationResult(false, ALREADY_REGISTERED);
        }
        // at this point we know the user is not yet registered in the database

        // then we check if the password is good.
        final PasswordResult passwordResult = isPasswordGood(password);
        if (passwordResult.status != SUCCESS) {
            logger.info("user provided a bad password during registration");
            return new RegistrationResult(false, BAD_PASSWORD, passwordResult.toPrettyString());
        }

        // at this point, we feel assured it's ok to save to the database.
        saveToDatabase(username, password);
        logger.info("saving new user, {}, to database", username);
        return new RegistrationResult(true, SUCCESSFULLY_REGISTERED);
    }

    public static RegistrationUtils createEmpty() {
        return new RegistrationUtils(PersistenceLayer.createEmpty());
    }

    public boolean isEmpty() {
        return persistenceLayer.isEmpty();
    }

    /**
     * Whether we qualify a password as good.
     *
     * <p>
     *     To summarize - we check the following here:
     *  </p>
     *  <ol>
     *    <li>The password must not be empty</li>
     *    <li>it must not be too short (less than 6 characters)</li>
     *    <li>it cannot be too long (more than 100 characters - this is because the framework</li>
     *    <li>analysis slows to a crawl with more than 100 characters)</li>
     *    <li>Whether the entropy framework we're using considers the password good.</li>
     * </ol>
     *  <p>See {@link PasswordResult}</p>
     */
    public static PasswordResult isPasswordGood(String password) {
        if (password.isEmpty()) {
            logger.info("password was empty");
            return PasswordResult.createDefault(EMPTY_PASSWORD);
        }
        StringMustNotBeNullOrEmpty(password);

        final boolean isTooSmall = password.length() < 10;
        if (isTooSmall) {
            logger.info("password was too short");
            return PasswordResult.createDefault(TOO_SHORT);
        }
        CheckUtils.mustBeTrueAtThisPoint(isTooSmall == false,
                "At this point, the password cannot be too small");

        final boolean isTooLarge = password.length() > 100;
        if (isTooLarge) {
            logger.info("password was too long");
            return PasswordResult.createDefault(TOO_LONG);
        }
        CheckUtils.mustBeTrueAtThisPoint(isTooLarge == false,
                "At this point, the password cannot be too large");

        // Nbvcxz is a tool that tests entropy on passwords
        // See github.com/GoSimpleLLC/nbvcxz
        final Nbvcxz nbvcxz = new Nbvcxz();
        final Result result = nbvcxz.estimate(password);
        final String suggestions = String.join(";", result.getFeedback().getSuggestion());

        final Double entropy = result.getEntropy();
        CheckUtils.mustBeTrueAtThisPoint(entropy > 0d, "There must be *some* entropy at this point, more than 0");

        String timeToCrackOff = TimeEstimate.getTimeToCrackFormatted(result, "OFFLINE_BCRYPT_12");
        String timeToCrackOn = TimeEstimate.getTimeToCrackFormatted(result, "ONLINE_THROTTLED");
        if (!result.isMinimumEntropyMet()) {
            logger.info("minimum entropy for password was not met");
            return new PasswordResult(INSUFFICIENT_ENTROPY, entropy, timeToCrackOff, timeToCrackOn, suggestions);
        } else {
            logger.info("password met required entropy");
            return new PasswordResult(SUCCESS, entropy, timeToCrackOff, timeToCrackOn, result.getFeedback().getResult());
        }
    }

    public boolean isUserInDatabase(String username) {
        return persistenceLayer.searchForUserByName(username).isPresent();
    }

    private void saveToDatabase(String username, String password) {
        final long userId = persistenceLayer.saveNewUser(username);
        persistenceLayer.updateUserWithPassword(userId, password);
    }

}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/package-info.java
================================================
/**
 * Domain objects related to authentication
 */
package com.coveros.training.authentication.domainobjects;


================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/PasswordResult.java
================================================
package com.coveros.training.authentication.domainobjects;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


/**
 * This contains the results of checking the complexity of a given
 * password - that is, how good of a password, how secure, is it?
 * See {@link com.coveros.training.authentication.RegistrationUtils#isPasswordGood}
 * for the calculation that generates this.
 */
public final class PasswordResult {

    public final PasswordResultEnums status;
    private final Double entropy;
    public final String timeToCrackOffline;
    private final String timeToCrackOnline;
    private final String message;

    private static final String BASIC_PASSWORD_CHECKS_FAILED = "BASIC_PASSWORD_CHECKS_FAILED";

    public PasswordResult(PasswordResultEnums status,
                          Double entropy,
                          String timeToCrackOffline,
                          String timeToCrackOnline,
                          String message) {

        this.status = status;
        this.entropy = entropy;
        this.timeToCrackOffline = timeToCrackOffline;
        this.timeToCrackOnline = timeToCrackOnline;
        this.message = message;
    }

    /**
     * Return this if any of our very basic attempt to validate
     * the password field fail.  Like passing an empty string, for example.
     */
    public static PasswordResult createDefault(PasswordResultEnums resultStatus) {
        return new PasswordResult(resultStatus, 0d, "", "", BASIC_PASSWORD_CHECKS_FAILED);
    }

    @Override
    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        PasswordResult rhs = (PasswordResult) obj;
        return new EqualsBuilder()
                .append(status, rhs.status)
                .append(entropy, rhs.entropy)
                .append(timeToCrackOffline, rhs.timeToCrackOffline)
                .append(timeToCrackOnline, rhs.timeToCrackOnline)
                .append(message, rhs.message)
                .isEquals();
    }

    @Override
    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(15, 33).
                append(status).
                append(entropy).
                append(timeToCrackOffline).
                append(timeToCrackOnline).
                append(message).
                toHashCode();
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public final String toPrettyString() {
        return String.format("status: %s%n", status) +
                String.format("entropy: %s%n", entropy) +
                String.format("time to crack offline: %s%n", timeToCrackOffline) +
                String.format("time to crack online: %s%n", timeToCrackOnline) +
                String.format("Nbvcxz response: %s%n", message);
    }

    /**
     * Return this to represent an empty result.  Used primarily
     * when we are initializing a variable and don't want to use null.
     */
    public static PasswordResult createEmpty() {
        return new PasswordResult(PasswordResultEnums.NULL, 0d, "", "", "");
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }

}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/PasswordResultEnums.java
================================================
package com.coveros.training.authentication.domainobjects;

/**
 * All the values currently possible for our
 * assessment of a potential password
 */
public enum PasswordResultEnums {
    TOO_SHORT,

    /**
     * ironic, I know, but if it's too long we're open to DOS attacks.
     * It takes too long to process extremely long passwords.
     */
    TOO_LONG,
    EMPTY_PASSWORD,

    /**
     * as measured by a tool.  See implementation where this is used.
     */
    INSUFFICIENT_ENTROPY,
    SUCCESS,

    /**
     * This is only used for empty password results.  See {@link PasswordResult#createEmpty()}
     */
    NULL
}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/RegistrationResult.java
================================================
package com.coveros.training.authentication.domainobjects;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * This class holds detailed data on the results of
 * trying to register a new user.  See {@link com.coveros.training.authentication.RegistrationUtils#processRegistration}
 */
public final class RegistrationResult {

    public final boolean wasSuccessfullyRegistered;
    public final RegistrationStatusEnums status;
    private final String message;

    public RegistrationResult(boolean wasSuccessfullyRegistered, RegistrationStatusEnums status, String message) {
        this.wasSuccessfullyRegistered = wasSuccessfullyRegistered;
        this.status = status;
        this.message = message;
    }

    public RegistrationResult(boolean wasSuccessfullyRegistered, RegistrationStatusEnums status) {
        this(wasSuccessfullyRegistered, status, "");
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        RegistrationResult rhs = (RegistrationResult) obj;
        return new EqualsBuilder()
                .append(wasSuccessfullyRegistered, rhs.wasSuccessfullyRegistered)
                .append(status, rhs.status)
                .append(message, rhs.message)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(15, 33).
                append(wasSuccessfullyRegistered).
                append(status).
                append(message).
                toHashCode();
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public final String toPrettyString() {
        return String.format("successfully registered: %s%n", wasSuccessfullyRegistered) +
                String.format("status: %s%n", status) +
                String.format("message: %n%n%s%n", message);
    }

    public static RegistrationResult createEmpty() {
        return new RegistrationResult(false, RegistrationStatusEnums.EMPTY);
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }
}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/RegistrationStatusEnums.java
================================================
package com.coveros.training.authentication.domainobjects;

/**
 * All the values possible for the results of an
 * attempted registration
 */
public enum RegistrationStatusEnums {
    ALREADY_REGISTERED,
    EMPTY_USERNAME,
    EMPTY_PASSWORD,
    SUCCESSFULLY_REGISTERED,
    BAD_PASSWORD,
    EMPTY // represents the state of no status.  Used by the empty registration result.

}



================================================
FILE: src/main/java/com/coveros/training/authentication/domainobjects/User.java
================================================
package com.coveros.training.authentication.domainobjects;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


/**
 * Represents the data that we consider full and complete to define
 * a particular user.  This coincides neatly with the details in the database.
 */
public final class User {

    /**
     * The username of the user
     */
    public final String name;

    /**
     * The identifier of the user in the database
     */
    public final long id;

    public User(String name, long id) {
        this.name = name;
        this.id = id;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        User rhs = (User) obj;
        return new EqualsBuilder()
                .append(id, rhs.id)
                .append(name, rhs.name)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(19, 3).
                append(name).
                append(id).
                toHashCode();
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public static User createEmpty() {
        return new User("", 0);
    }

    public boolean isEmpty() {
        return this.equals(User.createEmpty());
    }

}



================================================
FILE: src/main/java/com/coveros/training/cartesianproduct/CartesianProduct.java
================================================
package com.coveros.training.cartesianproduct;

import java.util.Set;

public class CartesianProduct {

    public static <T> String calculate(final Set<T> setOfSets) {
        return "";
    }
}



================================================
FILE: src/main/java/com/coveros/training/cartesianproduct/package-info.java
================================================
/**
 * Calculates the cartesian product of multiple sets.
 *<p>
 * See the feature file for more detail, in "cartesianproduct.feature"
 * </p>
 */
package com.coveros.training.cartesianproduct;


================================================
FILE: src/main/java/com/coveros/training/expenses/AlcoholCalculator.java
================================================
package com.coveros.training.expenses;

public class AlcoholCalculator {
    public static AlcoholResult calculate(DinnerPrices dinnerPrices) {
        return AlcoholResult.returnEmpty();
    }
}



================================================
FILE: src/main/java/com/coveros/training/expenses/AlcoholResult.java
================================================
package com.coveros.training.expenses;

public class AlcoholResult {
    private final Double foodPrice;
    private final Double alcoholPrice;
    private final Double foodRatio;

    public AlcoholResult(Double foodPrice, Double alcoholPrice, Double foodRatio) {
        this.foodPrice = foodPrice;
        this.alcoholPrice = alcoholPrice;
        this.foodRatio = foodRatio;
    }

    public static AlcoholResult returnEmpty() {
        return new AlcoholResult(0d,0d,0d);
    }
}



================================================
FILE: src/main/java/com/coveros/training/expenses/DinnerPrices.java
================================================
package com.coveros.training.expenses;

public class DinnerPrices {
    private final double subTotal;
    private final double foodTotal;
    private final double tip;
    private final double tax;

    public DinnerPrices(double subTotal, double foodTotal, double tip, double tax){
        this.subTotal = subTotal;
        this.foodTotal = foodTotal;
        this.tip = tip;
        this.tax = tax;
    }
}



================================================
FILE: src/main/java/com/coveros/training/expenses/package-info.java
================================================
/**
 * Calculates restaurant expenses that include alcohol, per government accounting rules.
 */
package com.coveros.training.expenses;


================================================
FILE: src/main/java/com/coveros/training/helpers/AssertionException.java
================================================
package com.coveros.training.helpers;

/**
 * This exception is thrown whenever something is
 * set to be true as an invariant, but isn't actually true.
 * See https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science
 */
public class AssertionException extends RuntimeException {

    public AssertionException(String message) {
        super(message);
    }
}



================================================
FILE: src/main/java/com/coveros/training/helpers/CheckUtils.java
================================================
package com.coveros.training.helpers;

/**
 * helper methods to assert that certain things in our code are true,
 * or else we throw an exception.
 */
public class CheckUtils {

    private CheckUtils() {
        // using a private constructor to hide the implicit public one.
    }

    /**
     * Asserts that the integer value received is 1 or above.
     * @param parameter a value to check for being positive
     * @throws IllegalArgumentException if the input isn't a positive integer
     */
    public static void IntParameterMustBePositive(long parameter) {
        if (parameter <= 0) {
            throw new IllegalArgumentException("int value must be 1 or above.");
        }
    }

    /**
     * Makes sure the input value is a valid string of length 1 or greater
     * @param values the strings to check
     * @throws IllegalArgumentException if the string is null or empty
     */
    public static void StringMustNotBeNullOrEmpty(String ... values) {
        for (String value: values) {
            if(value == null || value.isEmpty()) {
                throw new IllegalArgumentException("string must not be null or empty at this point");
            }
        }
    }

    /**
     * Used as a general invariant declaration in our code
     * @param mustBeTrue this is a predicate that must be true,
     *                   otherwise we'll throw an {@link AssertionException}
     * @param message the message to be passed along as part of the exception
     */
    public static void mustBeTrueAtThisPoint(boolean mustBeTrue, String message) {
        if (! mustBeTrue) {
            throw new AssertionException(message);
        }
    }

}



================================================
FILE: src/main/java/com/coveros/training/helpers/package-info.java
================================================
/**
 * Various helper classes that are used throughout the application.
 */
package com.coveros.training.helpers;


================================================
FILE: src/main/java/com/coveros/training/helpers/ServletUtils.java
================================================
package com.coveros.training.helpers;


import org.slf4j.Logger;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * These helper methods help to remove duplication in
 * the servlets.  See the methods for more detail on
 * what they do.
 */
public class ServletUtils {

    public static final String RESTFUL_RESULT_JSP = "restfulresult.jsp";
    public static final String RESULT_JSP = "result.jsp";

    private ServletUtils() {
        // using a private constructor to hide the implicit public one.
    }

    /**
     * A user posts information in the regular web application, and we react by forwarding them to another web page.
     * See result.jsp to get an idea.
     */
    public static void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        try {
            request.getRequestDispatcher(RESULT_JSP).forward(request, response);
        } catch (Exception ex) {
            logger.error(String.format("failed during forward: %s", ex));
        }
    }

    /**
     * A user has made a RESTful web API call, and we are responding with the minimal syntax.
     * See restfulresult.jsp to get an idea.
     */
    public static void forwardToRestfulResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        try {
            request.getRequestDispatcher(RESTFUL_RESULT_JSP).forward(request, response);
        } catch (Exception ex) {
            logger.error(String.format("failed during forward: %s", ex));
        }
    }
}



================================================
FILE: src/main/java/com/coveros/training/helpers/StringUtils.java
================================================
package com.coveros.training.helpers;


import org.apache.logging.log4j.core.util.JsonUtils;
import org.checkerframework.checker.nullness.qual.Nullable;



/**
 * Some simple helper methods for Strings.
 */
public class StringUtils {

    private StringUtils() {
        // using a private constructor to hide the implicit public one.
    }

    /**
     * checks the String you pass in; if it's null, return an empty String.
     * Otherwise, return the unchanged string.
     */
    public static String makeNotNullable(@Nullable String s) {
        return s == null ? "" : s;
    }


    // a table of some of the values that may need to be
    // escaped in JSON strings
    static final byte SINGLE_QUOTE    = 39;
    static final byte DOUBLE_QUOTE    = 34;
    static final byte BACKSLASH       = 92;
    static final byte NEW_LINE        = 10;
    static final byte CARRIAGE_RETURN = 13;
    static final byte TAB             = 9;
    static final byte BACKSPACE       = 8;
    static final byte FORM_FEED       = 12;

    /**
     * Given a string, replaces characters so that it is safe to use
     * as JSON
     * @param value String value to convert
     * @return a properly escaped string, usable in JSON
     */
    public static String escapeForJson(String value) {
        StringBuilder sb = new StringBuilder();
        JsonUtils.quoteAsString(value, sb);
        return sb.toString();
    }


}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryBookListAvailableServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.helpers.ServletUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Web API to list books available for borrowing.
 */
@MultipartConfig
@WebServlet(name = "LibraryBookListAvailableSearch", urlPatterns = {"/listavailable"}, loadOnStartup = 1)
public class LibraryBookListAvailableServlet extends HttpServlet {

    private static final long serialVersionUID = 3219972716578253134L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryBookListAvailableServlet.class);
    public static final String RESULT = "result";
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) {
        final List<Book> books = libraryUtils.listAvailableBooks();
        logger.info("Received request for all available books");
        String result;
        if (books.isEmpty()) {
            result = "No books exist in the database";
        } else {
            final String allBooks = books.stream().map(Book::toOutputString).collect(Collectors.joining(","));
            result = "[" + allBooks + "]";
        }
        request.setAttribute(RESULT, result);

        ServletUtils.forwardToRestfulResult(request, response, logger);
    }


}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryBookListSearchServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Web API to list all books or search books by id / title
 */
@MultipartConfig
@WebServlet(name = "LibraryBookListSearch", urlPatterns = {"/book"}, loadOnStartup = 1)
public class LibraryBookListSearchServlet extends HttpServlet {

    private static final long serialVersionUID = -56598540573518235L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryBookListSearchServlet.class);
    public static final String RESULT = "result";
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) {
        final String idString = StringUtils.makeNotNullable(request.getParameter("id"));
        final String title = StringUtils.makeNotNullable(request.getParameter("title"));

        String result;
        if (idString.isEmpty() && title.isEmpty()) {
            result = listAllBooks();
        } else if (! idString.isEmpty() && title.isEmpty()) {
            result = searchById(idString);
        } else if (idString.isEmpty() ) {
            result = searchByTitle(title);
        } else  {  // both id and title have an input
            logger.info("Received request for books, by title and id - id {} and title {}", idString, title);
            result = "Error: please search by either title or id, not both";
        }
        request.setAttribute(RESULT, result);

        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    private String searchByTitle(String title) {
        logger.info("Received request for books, name requested - searching for book by title {}", title);
        final Book book = libraryUtils.searchForBookByTitle(title);
        if (book.isEmpty()) {
            return "No books found with a title of " + title;
        }
        return "[" + book.toOutputString() + "]";
    }

    private String searchById(String idString) {
        logger.info("Received request for books, id requested - searching for book by id {}", idString);
        int id;
        try {
            id = Integer.parseInt(idString);
        } catch (NumberFormatException ex) {
            return "Error: could not parse the book id as an integer";
        }
        final Book book = libraryUtils.searchForBookById(id);
        if (book.isEmpty()) {
            return "No books found with an id of " + idString;
        }
        return "[" + book.toOutputString() + "]";
    }

    private String listAllBooks() {
        logger.info("Received request for books, no title or id requested - listing all books");
        final List<Book> books = libraryUtils.listAllBooks();
        final String allBooks = books.stream().map(Book::toOutputString).collect(Collectors.joining(","));
        if (allBooks.isEmpty()) {
            return "No books exist in the database";
        }
        return "[" + allBooks + "]";
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryBorrowerListSearchServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Web API to list all borrowers or search borrowers by id / name
 */
@MultipartConfig
@WebServlet(name = "LibraryBorrowerListSearch", urlPatterns = {"/borrower"}, loadOnStartup = 1)
public class LibraryBorrowerListSearchServlet extends HttpServlet {

    private static final long serialVersionUID = -7374339112812653844L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryBorrowerListSearchServlet.class);
    public static final String RESULT = "result";
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doGet(final HttpServletRequest request, final HttpServletResponse response) {
        final String idString = StringUtils.makeNotNullable(request.getParameter("id"));
        final String name = StringUtils.makeNotNullable(request.getParameter("name"));

        String result;
        if (idString.isEmpty() && name.isEmpty()) {
            result = listAllBorrowers();
        } else if (! idString.isEmpty() && name.isEmpty()) {
            result = searchById(idString);
        } else if (idString.isEmpty() ) {
            result = searchByName(name);
        } else  {  // both id and name have an input
            logger.info("Received request for borrowers, by name and id - id {} and name {}", idString, name);
            result = "Error: please search by either name or id, not both";
        }
        request.setAttribute(RESULT, result);

        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    private String searchByName(final String name) {
        logger.info("Received request for borrowers, name requested - searching for borrower by name {}", name);
        final Borrower borrower = libraryUtils.searchForBorrowerByName(name);
        if (borrower.isEmpty()) {
            return "No borrowers found with a name of " + name;
        }
        return "["+borrower.toOutputString()+"]";
    }

    private String searchById(final String idString) {
        logger.info("Received request for borrowers, id requested - searching for borrower by id {}", idString);
        int id;
        try {
            id = Integer.parseInt(idString);
        } catch (final NumberFormatException ex) {
            return "Error: could not parse the borrower id as an integer";
        }
        final Borrower borrower = libraryUtils.searchForBorrowerById(id);
        if (borrower.isEmpty()) {
            return "No borrowers found with an id of " + idString;
        }
        return "["+borrower.toOutputString()+"]";
    }

    private String listAllBorrowers() {
        logger.info("Received request for borrowers, no name or id requested - listing all borrowers");
        final List<Borrower> borrowers = libraryUtils.listAllBorrowers();
        final String allBorrowers = borrowers.stream().map(Borrower::toOutputString).collect(Collectors.joining(","));
        if (allBorrowers.isEmpty()) {
            return "No borrowers exist in the database";
        }
        return "["+allBorrowers+"]";
    }


}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryLendServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.sql.Date;
import java.time.LocalDate;

/**
 * Web API to lend a book to a borrower
 */
@WebServlet(name = "LibraryLendServlet", urlPatterns = {"/lend"}, loadOnStartup = 1)
public class LibraryLendServlet extends HttpServlet {

    private static final long serialVersionUID = -6507483398690297645L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryLendServlet.class);
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        LibraryActionResults libraryActionResults;

        final String book = StringUtils.makeNotNullable(request.getParameter("book"));
        request.setAttribute("book", book);

        final String borrower = StringUtils.makeNotNullable(request.getParameter("borrower"));
        request.setAttribute("borrower", borrower);

        if (book.isEmpty()) {
            libraryActionResults = LibraryActionResults.NO_BOOK_TITLE_PROVIDED;
        } else if (borrower.isEmpty()) {
            libraryActionResults = LibraryActionResults.NO_BORROWER_PROVIDED;
        } else {
            final Date now = getDateNow();
            request.setAttribute("date", now.toString());

            logger.info("received request to lend a book, {}, to {}", book, borrower);

            libraryActionResults = libraryUtils.lendBook(book, borrower, now);
        }
        request.setAttribute("result", libraryActionResults.toString());
        request.setAttribute("return_page", "library.html");
        ServletUtils.forwardToResult(request, response, logger);
    }

    /**
     * Wrapping the call to get a date for now,
     * so it's easier to stub for testing.
     */
    Date getDateNow() {
        return Date.valueOf(LocalDate.now());
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryRegisterBookServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Web API to register a new book with the library
 */
@WebServlet(name = "LibraryRegisterBookServlet", urlPatterns = {"/registerbook"}, loadOnStartup = 1)
public class LibraryRegisterBookServlet extends HttpServlet {

    private static final long serialVersionUID = -6971471412293552088L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryRegisterBookServlet.class);
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doPost(final HttpServletRequest request, final HttpServletResponse response) {
        final String book = StringUtils.makeNotNullable(request.getParameter("book"));
        LibraryActionResults libraryActionResults;

        if (book.isEmpty()) {
            libraryActionResults = LibraryActionResults.NO_BOOK_TITLE_PROVIDED;
            logger.info("input for the book field was empty");
        } else {
            request.setAttribute("book", book);

            logger.info("received request to register a book, {}", book);

            libraryActionResults = libraryUtils.registerBook(book);
        }

        request.setAttribute("return_page", "library.html");
        request.setAttribute("result", libraryActionResults.toString());
        ServletUtils.forwardToResult(request, response, logger);
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryRegisterBorrowerServlet.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Web API to register a new borrower with the library
 */
@WebServlet(name = "LibraryRegisterBorrowerServlet", urlPatterns = {"/registerborrower"}, loadOnStartup = 1)
public class LibraryRegisterBorrowerServlet extends HttpServlet {

    private static final long serialVersionUID = 3293380381170679010L;
    private static final Logger logger = LoggerFactory.getLogger(LibraryRegisterBorrowerServlet.class);
    static LibraryUtils libraryUtils = new LibraryUtils();

    @Override
    protected void doPost(final HttpServletRequest request, final HttpServletResponse response) {
        final String borrower = StringUtils.makeNotNullable(request.getParameter("borrower"));
        LibraryActionResults libraryActionResults;

        if (borrower.isEmpty()) {
            libraryActionResults = LibraryActionResults.NO_BORROWER_PROVIDED;
            logger.info("input for the borrower field was empty");
        } else {
            request.setAttribute("borrower", borrower);

            logger.info("received request to register a borrower, {}", borrower);

            libraryActionResults = libraryUtils.registerBorrower(borrower);
        }

        request.setAttribute("return_page", "library.html");
        request.setAttribute("result", libraryActionResults.toString());
        ServletUtils.forwardToResult(request, response, logger);
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/LibraryUtils.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.library.domainobjects.Loan;
import com.coveros.training.persistence.IPersistenceLayer;
import com.coveros.training.persistence.PersistenceLayer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Date;
import java.util.ArrayList;
import java.util.List;

/**
 * Business logic for handling library needs.  For example, {@link #lendBook}
 */
public class LibraryUtils {

    private final IPersistenceLayer persistence;
    private static final Logger logger = LoggerFactory.getLogger(LibraryUtils.class);

    public LibraryUtils(IPersistenceLayer persistence) {
        this.persistence = persistence;
    }

    public LibraryUtils() {
        this(new PersistenceLayer());
    }

    /**
     * Lend a book to a borrower.
     * @param bookTitle The title of a registered book, e.g. see {@link #registerBook(String)}
     * @param borrowerName the name of a registered borrower, e.g. see {@link #registerBorrower(String)}
     * @param borrowDate the date the book is being lent out.
     * @return an enum {@link LibraryActionResults} indicating the resultant status
     */
    public LibraryActionResults lendBook(String bookTitle, String borrowerName, Date borrowDate) {
        logger.info("starting process to lend a book: {} to borrower: {}", bookTitle, borrowerName);
        final Book book = searchForBookByTitle(bookTitle);
        final Book foundBook = new Book(book.id, bookTitle);
        final Borrower borrower = searchForBorrowerByName(borrowerName);
        final Borrower foundBorrower = new Borrower(borrower.id, borrowerName);
        return lendBook(foundBook, foundBorrower, borrowDate);
    }

    public LibraryActionResults lendBook(Book book, Borrower borrower, Date borrowDate) {
        if (book.id == 0) {
            logger.info("book: {} was not registered.  Lending failed", book.title);
            return LibraryActionResults.BOOK_NOT_REGISTERED;
        }

        if (borrower.id == 0) {
            logger.info("borrower: {} was not registered.  Lending failed", borrower.name);
            return LibraryActionResults.BORROWER_NOT_REGISTERED;
        }

        final Loan loan = searchForLoanByBook(book);
        if (!loan.isEmpty()) {
            logger.info("book: {} was already checked out on {}.  Lending failed", book.title, loan.checkoutDate);
            return LibraryActionResults.BOOK_CHECKED_OUT;
        }

        logger.info("book: {} is available for borrowing by valid borrower: {}", book.title, borrower.name);
        createLoan(book, borrower, borrowDate);
        return LibraryActionResults.SUCCESS;
    }

    /**
     * This is here so we can extract out the portion of code
     * that calls to the persistence layer, making it easier to test.
     */
    void createLoan(Book book, Borrower borrower, Date borrowDate) {
        logger.info("creating loan for book: {} by borrower: {}", book.title, borrower.name);
        persistence.createLoan(book, borrower, borrowDate);
    }

    /**
     * Register a borrower with the library
     * @param borrower the name of a borrower
     * @return an enum, {@link LibraryActionResults} indicating the resultant status
     */
    public LibraryActionResults registerBorrower(String borrower) {
        logger.info("trying to register a borrower with name: {}", borrower);
        final Borrower borrowerDetails = searchForBorrowerByName(borrower);
        final boolean borrowerWasFound = !borrowerDetails.equals(Borrower.createEmpty());
        if (borrowerWasFound) {
            logger.info("borrower: {} was already registered", borrower);
            return LibraryActionResults.ALREADY_REGISTERED_BORROWER;
        }
        logger.info("borrower: {} was not found.  Registering new borrower...", borrower);
        saveNewBorrower(borrower);
        return LibraryActionResults.SUCCESS;
    }

    /**
     * This is here so we can extract out the portion of code
     * that calls to the persistence layer, making it easier to test.
     */
    void saveNewBorrower(String borrower) {
        logger.info("saving new borrower: {}", borrower);
        persistence.saveNewBorrower(borrower);
    }

    /**
     * Register a new book with the library
     * @param bookTitle the title of a book
     * @return an enum {@link LibraryActionResults} indicating the resultant status
     */
    public LibraryActionResults registerBook(String bookTitle) {
        if (bookTitle.isEmpty()) {
            throw new IllegalArgumentException("bookTitle was an empty string - disallowed when registering books");
        }
        logger.info("trying to register a book with title: {}", bookTitle);
        final Book book = searchForBookByTitle(bookTitle);
        if (!book.isEmpty()) {
            logger.info("book: {} was already registered", bookTitle);
            return LibraryActionResults.ALREADY_REGISTERED_BOOK;
        }
        logger.info("book: {} was not found.  Registering new book...", bookTitle);
        saveNewBook(bookTitle);
        return LibraryActionResults.SUCCESS;
    }

    /**
     * This is here so we can extract out the portion of code
     * that calls to the persistence layer, making it easier to test.
     */
    void saveNewBook(String bookTitle) {
        logger.info("saving a new book: {}", bookTitle);
        persistence.saveNewBook(bookTitle);
    }

    public Loan searchForLoanByBook(Book book) {
        logger.info("searching for loan by book with title: {}", book.title);
        return persistence.searchForLoanByBook(book).orElse(Loan.createEmpty());
    }


    public List<Loan> searchForLoanByBorrower(Borrower borrower) {
        logger.info("searching for loan by borrower with name: {}", borrower.name);
        return persistence.searchForLoanByBorrower(borrower).orElse(new ArrayList<>());
    }

    public Borrower searchForBorrowerByName(String borrowerName) {
        logger.info("searching for borrower by name: {}", borrowerName);
        return persistence.searchBorrowerDataByName(borrowerName).orElse(Borrower.createEmpty());
    }

    public Book searchForBookByTitle(String title) {
        if (title.isEmpty()) {
            throw new IllegalArgumentException("when searching for a book, must include a non-empty string for title");
        }
        logger.info("search for book with title: {}", title);
        final Book book = persistence.searchBooksByTitle(title).orElse(Book.createEmpty());
        if (book.isEmpty()) {
            logger.info("No book found with title of {}", title);
        } else {
            logger.info("book found with title of {}", title);
        }
        return book;
    }

    /**
     * The id has to be positive.  Exception will be thrown otherwise.
     */
    public Book searchForBookById(long id) {
        if (id < 1) {
            throw new IllegalArgumentException("when searching for a book, must include an id of one or greater");
        }
        logger.info("search for book with id: {}", id);
        final Book book = persistence.searchBooksById(id).orElse(Book.createEmpty());
        if (book.isEmpty()) {
            logger.info("No book found with id of {}", id);
        } else {
            logger.info("Book found with id of {}", id);
        }
        return book;
    }

    /**
     * The id has to be positive.  Exception will be thrown otherwise.
     */
    public Borrower searchForBorrowerById(long id) {
        if (id < 1) {
            throw new IllegalArgumentException("when searching for a borrower, must include an id of one or greater");
        }
        logger.info("search for borrower with id: {}", id);
        final Borrower borrower = persistence.searchBorrowersById(id).orElse(Borrower.createEmpty());
        if (borrower.isEmpty()) {
            logger.info("No borrower found with id of {}", id);
        } else {
            logger.info("borrower found with id of {}", id);
        }
        return borrower;
    }

    public static LibraryUtils createEmpty() {
        return new LibraryUtils(PersistenceLayer.createEmpty());
    }

    public boolean isEmpty() {
        return persistence.isEmpty();
    }

    public LibraryActionResults deleteBook(Book book) {
        logger.info("deleting a book.  id: {}, title: {}", book.id, book.title);
        final Book bookInDatabase = searchForBookByTitle(book.title);
        if (bookInDatabase.isEmpty()) {
            logger.info("book not found in database.  Therefore, obviously, cannot be deleted");
            return LibraryActionResults.NON_REGISTERED_BOOK_CANNOT_BE_DELETED;
        }
        persistence.deleteBook(book.id);
        logger.info("book with title: {} and id: {} was deleted", bookInDatabase.title, bookInDatabase.id);
        return LibraryActionResults.SUCCESS;
    }

    public LibraryActionResults deleteBorrower(Borrower borrower) {
        logger.info("deleting a borrower.  id: {}, name: {}", borrower.id, borrower.name);
        final Borrower borrowerInDatabase = searchForBorrowerByName(borrower.name);
        if (borrowerInDatabase.isEmpty()) {
            logger.info("borrower not found in database.  Therefore, obviously, cannot be deleted");
            return LibraryActionResults.NON_REGISTERED_BORROWER_CANNOT_BE_DELETED;
        }
        persistence.deleteBorrower(borrower.id);
        logger.info("borrower with name: {} and id: {} was deleted", borrowerInDatabase.name, borrowerInDatabase.id);
        return LibraryActionResults.SUCCESS;
    }

    public List<Book> listAllBooks() {
        logger.info("received request to list all books");
        return persistence.listAllBooks().orElse(new ArrayList<>());
    }


    public List<Borrower> listAllBorrowers() {
        logger.info("received request to list all borrowers");
        return persistence.listAllBorrowers().orElse(new ArrayList<>());
    }


    public List<Book> listAvailableBooks() {
        logger.info("received request to list available books");
        return persistence.listAvailableBooks().orElse(new ArrayList<>());
    }
}



================================================
FILE: src/main/java/com/coveros/training/library/package-info.java
================================================
/**
 * Books and borrowers and that sort of thing.
 */
package com.coveros.training.library;


================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/Book.java
================================================
package com.coveros.training.library.domainobjects;

import com.coveros.training.helpers.StringUtils;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Represents the data that we consider full and complete to define
 * a particular book in the library.  This coincides neatly with the details in the database.
 */
public final class Book {

    /**
     * The title of the book
     */
    public final String title;

    /**
     * The identifier number in our database
     */
    public final long id;

    public Book(long id, String title) {
        this.title = title;
        this.id = id;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        Book rhs = (Book) obj;
        return new EqualsBuilder()
                .append(id, rhs.id)
                .append(title, rhs.title)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(13, 33).
                append(id).
                append(title).
                toHashCode();
    }

    public final String toOutputString() {
        return String.format("{\"Title\": \"%s\", \"Id\": \"%s\"}", StringUtils.escapeForJson(title), id);
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public static Book createEmpty() {
        return new Book(0, "");
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }

}



================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/Borrower.java
================================================
package com.coveros.training.library.domainobjects;

import com.coveros.training.helpers.StringUtils;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


/**
 * An immutable data value representing the data for a borrower.
 * <p>
 * A borrower is a person who borrows a book from a library.
 * <p>
 * Note that we make our fields public because they are final,
 * so there's no need to have methods wrapping them.
 */
public final class Borrower {

    /**
     * The identifier for this borrower in the database.
     */
    public final long id;

    /**
     * The name of the borrower
     */
    public final String name;

    public Borrower(long id, String name) {
        this.id = id;
        this.name = name;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        Borrower rhs = (Borrower) obj;
        return new EqualsBuilder()
                .append(id, rhs.id)
                .append(name, rhs.name)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(17, 37).
                append(id).
                append(name).
                toHashCode();
    }

    public final String toOutputString() {
        return String.format("{\"Name\": \"%s\", \"Id\": \"%s\"}", StringUtils.escapeForJson(name), id);
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public static Borrower createEmpty() {
        return new Borrower(0, "");
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }
}



================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/LibraryActionResults.java
================================================
package com.coveros.training.library.domainobjects;

/**
 * These are the possible results of business functions
 * related to the library.  For example, you might
 * get ALREADY_REGISTERED_BOOK if you are trying to register
 * a book and it's already in the library.
 */
public enum LibraryActionResults {

    ALREADY_REGISTERED_BOOK,

    /**
     * if a book isn't registered, then of course we cannot delete it.
     */
    NON_REGISTERED_BOOK_CANNOT_BE_DELETED,

    /**
     * if a borrower isn't registered, then of course we cannot delete it.
     */
    NON_REGISTERED_BORROWER_CANNOT_BE_DELETED,
    ALREADY_REGISTERED_BORROWER,
    BOOK_NOT_REGISTERED,
    BORROWER_NOT_REGISTERED,
    /**
     * someone already has this book checked out.
     */
    BOOK_CHECKED_OUT,
    SUCCESS,
    /**
     * if a method needs a book and none is provided
     */
    NO_BOOK_TITLE_PROVIDED,
    /**
     * if a method needs a borrower and none is provided
     */
    NO_BORROWER_PROVIDED,
    /**
     * may be used when initializing a variable of this type
     */
    NULL
}



================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/Loan.java
================================================
package com.coveros.training.library.domainobjects;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


import java.sql.Date;

/**
 * Represents the data that we consider full and complete to define
 * a particular loan of a book to a borrower in the library.
 * This coincides neatly with the details in the database.
 */
public final class Loan {

    /**
     * The date the book was checked out.
     */
    public final java.sql.Date checkoutDate;

    /**
     * The book that is checked out
     */
    public final Book book;

    /**
     * The borrower that has this book
     */
    public final Borrower borrower;

    /**
     * The identifier of this loan in our database
     */
    public final long id;

    public Loan(Book book, Borrower borrower, long id, Date checkoutDate) {
        this.book = book;
        this.borrower = borrower;
        this.id = id;
        this.checkoutDate = checkoutDate;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        Loan rhs = (Loan) obj;
        return new EqualsBuilder()
                .append(id, rhs.id)
                .append(book, rhs.book)
                .append(borrower, rhs.borrower)
                .append(checkoutDate, rhs.checkoutDate)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(5, 21)
                .append(book)
                .append(borrower)
                .append(id)
                .append(checkoutDate)
                .toHashCode();
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public static Loan createEmpty() {
        return new Loan(Book.createEmpty(), Borrower.createEmpty(), 0, new Date(0));
    }

    public boolean isEmpty() {
        return this.equals(createEmpty());
    }
}



================================================
FILE: src/main/java/com/coveros/training/library/domainobjects/package-info.java
================================================
/**
 * These represent concepts within the library domain, like books, borrowers, loans.
 */
package com.coveros.training.library.domainobjects;


================================================
FILE: src/main/java/com/coveros/training/mathematics/Ackermann.java
================================================
package com.coveros.training.mathematics;

import java.math.BigInteger;


public class Ackermann {

    private Ackermann() {
        throw new IllegalStateException("Utility class");
    }

    /**
     * Ackerman function.
     *
     * This version found at https://rosettacode.org/wiki/Ackermann_function#Java
     */
    public static BigInteger ack(BigInteger m, BigInteger n) {
        if (m.equals(BigInteger.ZERO)) {
            return n.add(BigInteger.ONE);
        }
        if (n.equals(BigInteger.ZERO)) {
            return ack(m.subtract(BigInteger.ONE), BigInteger.ONE);
        }
        return ack(m.subtract(BigInteger.ONE), ack(m, n.subtract(BigInteger.ONE)));
    }

    /**
     * A helper method to make it easy to call this with only integers
     * Calls to {@link #ack}
     */
    public static BigInteger calculate(int m, int n) {
        BigInteger bigM = BigInteger.valueOf(m);
        BigInteger bigN = BigInteger.valueOf(n);
        return ack(bigM, bigN);
    }
}



================================================
FILE: src/main/java/com/coveros/training/mathematics/AckermannIterative.java
================================================
package com.coveros.training.mathematics;

import java.math.BigInteger;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.function.BinaryOperator;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * From https://rosettacode.org/wiki/Ackermann_function#Java
 */
public interface AckermannIterative {
    static BigInteger calculate(int m, int n) {
        BigInteger bigM = BigInteger.valueOf(m);
        BigInteger bigN = BigInteger.valueOf(n);
        return $.main(bigM, bigN);
    }
    BigInteger number1();
    BigInteger number2();

    Deque<BigInteger> stack();

    boolean flag();

    enum $ {
        END;

        private static final BigInteger ZERO = BigInteger.ZERO;
        private static final BigInteger ONE = BigInteger.ONE;
        private static final BigInteger TWO = BigInteger.valueOf(2);
        private static final BigInteger THREE = BigInteger.valueOf(3);

        private static AckermannIterative tail(BigInteger number1, BigInteger number2, Deque<BigInteger> stack, boolean flag) {
            return (FunctionalAckermann) field -> {
                switch (field) {
                    case NUMBER_1: return number1;
                    case NUMBER_2: return number2;
                    case STACK: return stack;
                    case FLAG: return flag;
                    default: throw new UnsupportedOperationException(
                            field instanceof Field
                                    ? "Field checker has not been updated properly."
                                    : "Field is not of the correct type."
                    );
                }
            };
        }

        private static final BinaryOperator<BigInteger> ACKERMANN =
                TailRecursive.tailie(
                        (BigInteger number1, BigInteger number2) ->
                                tail(
                                        number1,
                                        number2,
                                        Stream.of(number1).collect(
                                                Collectors.toCollection(ArrayDeque::new)
                                        ),
                                        false
                                )
                        ,
                        ackermann -> {
                            BigInteger number1 = ackermann.number1();
                            BigInteger number2 = ackermann.number2();
                            Deque<BigInteger> stack = ackermann.stack();
                            if (!stack.isEmpty() && !ackermann.flag()) {
                                number1 = stack.pop();
                            }
                            switch (number1.intValue()) {
                                case 0:
                                    return tail(
                                            number1,
                                            number2.add(ONE),
                                            stack,
                                            false
                                    );
                                case 1:
                                    return tail(
                                            number1,
                                            number2.add(TWO),
                                            stack,
                                            false
                                    );
                                case 2:
                                    return tail(
                                            number1,
                                            number2.multiply(TWO).add(THREE),
                                            stack,
                                            false
                                    );
                                default:
                                    if (ZERO.equals(number2)) {
                                        return tail(
                                                number1.subtract(ONE),
                                                ONE,
                                                stack,
                                                true
                                        );
                                    } else {
                                        stack.push(number1.subtract(ONE));
                                        return tail(
                                                number1,
                                                number2.subtract(ONE),
                                                stack,
                                                true
                                        );
                                    }
                            }
                        },
                        ackermann -> ackermann.stack().isEmpty(),
                        AckermannIterative::number2
                )::apply
                ;

        private static BigInteger main(BigInteger m, BigInteger n) {
            return ACKERMANN.apply(m, n);
        }

        private enum Field {
            NUMBER_1,
            NUMBER_2,
            STACK,
            FLAG
        }

        @FunctionalInterface
        private interface FunctionalAckermann extends FunctionalField<Field>, AckermannIterative {
            @Override
            default BigInteger number1() {
                return field(Field.NUMBER_1);
            }

            @Override
            default BigInteger number2() {
                return field(Field.NUMBER_2);
            }

            @Override
            default Deque<BigInteger> stack() {
                return field(Field.STACK);
            }

            @Override
            default boolean flag() {
                return field(Field.FLAG);
            }
        }
    }
}


================================================
FILE: src/main/java/com/coveros/training/mathematics/AckServlet.java
================================================
package com.coveros.training.mathematics;

import com.coveros.training.helpers.ServletUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.math.BigInteger;

@MultipartConfig
@WebServlet(name = "AckServlet", urlPatterns = {"/ackermann"}, loadOnStartup = 1)
public class AckServlet extends HttpServlet {

    private static final long serialVersionUID = 5669410483481180165L;
    public static final String RESULT = "result";
    static Logger logger = LoggerFactory.getLogger(AckServlet.class);

    private int putNumberInRequest(String itemName, HttpServletRequest request) {
        int item = Integer.parseInt(request.getParameter(itemName));
        request.setAttribute(itemName, item);
        return item;
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        try {
            int ackParamM = putNumberInRequest("ack_param_m", request);
            int ackParamN = putNumberInRequest("ack_param_n", request);
            String algorithm = request.getParameter("ack_algorithm_choice");

            logger.info("received request to calculate Ackermann's with {} and {} and the {} algorithm", ackParamM, ackParamN, algorithm);

            if (algorithm.equals("tail_recursive")) {
                tailRecursive(request, ackParamM, ackParamN);
            } else {
                regularRecursive(request, ackParamM, ackParamN);
            }

        } catch (NumberFormatException ex) {
            request.setAttribute(RESULT, "Error: only accepts integers");
        }
        forwardToResult(request, response, logger);
    }

    /**
     * Wrapping a static method call for testing.
     */
    void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    /**
     * Wrapping a request set for easier testing and clarity.
     */
    void regularRecursive(HttpServletRequest request, int itemA, int itemB) {
        final BigInteger result = Ackermann.calculate(itemA, itemB);
        logger.info("Ackermann's result is {}", result);
        request.setAttribute(RESULT, result);
    }

    /**
     * Wrapping a request set for easier testing and clarity.
     */
    void tailRecursive(HttpServletRequest request, int itemA, int itemB) {
        final BigInteger result = AckermannIterative.calculate(itemA, itemB);
        logger.info("Ackermann's result is {}", result);
        request.setAttribute(RESULT, result);
    }

}



================================================
FILE: src/main/java/com/coveros/training/mathematics/Calculator.java
================================================
package com.coveros.training.mathematics;

import org.apache.commons.lang3.tuple.Pair;

/**
 * A simple class to do simple things.
 */
public class Calculator {

    private final Baz baz;

    public Calculator() {
        this.baz = new Baz();
    }

    public Calculator(Baz baz) {
        this.baz = baz;
    }


    /**
     * Simply add two integers
     */
    public static int add(int a, int b) {
        return a + b;
    }

    /**
     * Simply add two doubles.
     */
    public static double add(double a, double b) {
        return a + b;
    }

    /**
     * This method converts integers 0 to 10 into their
     * ordinals.  For example: 0 returns "zero"
     */
    public static String toStringZeroToTen(int i) {
        switch (i) {
            case 0: return "zero";
            case 1: return "one";
            case 2: return "two";
            case 3: return "three";
            case 4: return "four";
            case 5: return "five";
            case 6: return "six";
            case 7: return "seven";
            case 8: return "eight";
            case 9: return "nine";
            case 10: return "ten";
            default: return "dunno";
        }
    }

    /**
     * Add two pairs.
     */
    public static Pair<Integer, Integer> add(Pair<Integer, Integer> pair1, Pair<Integer, Integer> pair2) {
        int newLeftValue = pair1.getLeft() + pair2.getLeft();
        int newRightValue = pair1.getRight() + pair2.getRight();
        return Pair.of(newLeftValue, newRightValue);
    }

    /**
     * Used for teaching
     * testing stubs.
     */
    public static int calculateAndMore(int a, int b, iFoo foo, iBar bar) {
        int c = foo.doComplexThing(a);
        int d = bar.doOtherComplexThing(c);
        return a + b + c + d;
    }

    /**
     * Used for teaching
     * testing stubs.
     */
    public int calculateAndMorePart2(int a) {
        int b = baz.doThirdPartyThing(a);
        return a + b;
    }

    /**
     * Used for teaching
     * testing mocks.
     */
    public void calculateAndMorePart3(int a) {
        baz.doThirdPartyThing(a);
    }

    public interface iFoo {
        int doComplexThing(int a);
    }

    /**
     * An artificial class needed as a dependency
     */
    public static class Foo {
        public int doComplexThing(int a) {
            return a + 1;
        }
    }


    public interface iBar {
        int doOtherComplexThing(int c);
    }

    /**
     * An artificial class needed as a dependency
     */
    public static class Bar {
        public int doOtherComplexThing(int c) {
            return c - 1;
        }
    }

    /**
     * An artificial class needed as a dependency
     */
    public class Baz {

        public int doThirdPartyThing(int a) {
            return 42;
        }
    }
}



================================================
FILE: src/main/java/com/coveros/training/mathematics/Fibonacci.java
================================================
package com.coveros.training.mathematics;

public class Fibonacci {

    private Fibonacci() {
        // static utility class.  Do not construct.
    }

    public static long calculate(long n) {
        long result;

        if (n <= 1) {
            result = n;
        } else {
            result = calculate(n - 1) + calculate(n - 2);
        }

        return result;
    }
}




================================================
FILE: src/main/java/com/coveros/training/mathematics/FibonacciIterative.java
================================================
package com.coveros.training.mathematics;

import java.math.BigInteger;

/**
 * From https://rosettacode.org/wiki/Fibonacci_sequence#Iterative_35
 */
public class FibonacciIterative {

    private FibonacciIterative() {
        throw new IllegalStateException("Utility class");
    }

    /**
     * O(log(n))
     */
    public static BigInteger fibAlgo1(long n) {
        if (n <= 0)
            return BigInteger.ZERO;

        BigInteger i =  (BigInteger.valueOf(n).subtract(BigInteger.ONE));
        BigInteger a = BigInteger.ONE;
        BigInteger b = BigInteger.ZERO;
        BigInteger c = BigInteger.ZERO;
        BigInteger d = BigInteger.ONE;
        BigInteger tmp1;
        BigInteger tmp2;

        while (i.compareTo(BigInteger.ZERO) > 0) {
            if (!i.mod(BigInteger.valueOf(2)).equals(BigInteger.ZERO)) {
                tmp1 = d.multiply(b).add(c.multiply(a));
                tmp2 = d.multiply (b.add(a)).add(c.multiply(b));
                a = tmp1;
                b = tmp2;
            }

            tmp1 = c.pow(2).add(d.pow(2));
            tmp2 = d.multiply(c.multiply(BigInteger.valueOf(2)).add(d));

            c = tmp1;
            d = tmp2;

            i = i.divide(BigInteger.valueOf(2));
        }
        return a.add(b);
    }

    public static BigInteger fibAlgo2(int n)
    {
        if (n < 2)
            return BigInteger.valueOf(n);
        BigInteger ans = BigInteger.ZERO;
        BigInteger n1 =  BigInteger.ZERO;
        BigInteger n2 =  BigInteger.ONE;
        for(n--; n > 0; n--)
        {
            ans = n1.add(n2);
            n1 = n2;
            n2 = ans;
        }
        return ans;
    }

}



================================================
FILE: src/main/java/com/coveros/training/mathematics/FibServlet.java
================================================
package com.coveros.training.mathematics;

import com.coveros.training.helpers.ServletUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.math.BigInteger;

@MultipartConfig
@WebServlet(name = "FibServlet", urlPatterns = {"/fibonacci"}, loadOnStartup = 1)
public class FibServlet extends HttpServlet {

    private static final long serialVersionUID = 5290010004362186530L;
    public static final String RESULT = "result";
    public static final String FIBONACCI_VALUE_IS = "Fibonacci value is {}";
    static Logger logger = LoggerFactory.getLogger(FibServlet.class);

    private int putNumberInRequest(String itemName, HttpServletRequest request) {
        int item = Integer.parseInt(request.getParameter(itemName));
        request.setAttribute(itemName, item);
        return item;
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        try {
            int fibParamN = putNumberInRequest("fib_param_n", request);
            String algorithm = request.getParameter("fib_algorithm_choice");

            logger.info("received request to calculate the {}th fibonacci number by {}", fibParamN, algorithm);

            if (algorithm.equals("tail_recursive_1")) {
                tailRecursiveAlgo1Calc(request, fibParamN);
            } else if (algorithm.equals("tail_recursive_2")) {
                tailRecursiveAlgo2Calc(request, fibParamN);
            } else {
                defaultRecursiveCalculation(request, fibParamN);
            }
        } catch (NumberFormatException ex) {
            request.setAttribute(RESULT, "Error: only accepts integers");
        }
        forwardToResult(request, response, logger);
    }

    void tailRecursiveAlgo2Calc(HttpServletRequest request, int fibParamN) {
        final BigInteger result = FibonacciIterative.fibAlgo2(fibParamN);
        logger.info(FIBONACCI_VALUE_IS, result);
        request.setAttribute(RESULT, result);
    }

    void tailRecursiveAlgo1Calc(HttpServletRequest request, int fibParamN) {
        final BigInteger result = FibonacciIterative.fibAlgo1(fibParamN);
        logger.info(FIBONACCI_VALUE_IS, result);
        request.setAttribute(RESULT, result);
    }

    /**
     * Wrapping a static method call for testing.
     */
    void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    /**
     * Wrapping a request set for easier testing and clarity.
     */
    void defaultRecursiveCalculation(HttpServletRequest request, int itemA) {
        final long result = Fibonacci.calculate(itemA);
        logger.info(FIBONACCI_VALUE_IS, result);
        request.setAttribute(RESULT, result);
    }

}



================================================
FILE: src/main/java/com/coveros/training/mathematics/FunctionalField.java
================================================
package com.coveros.training.mathematics;

@FunctionalInterface
public interface FunctionalField<F extends Enum<?>> {
    Object untypedField(F field);

    @SuppressWarnings("unchecked")
    default <V> V field(F field) {
        return (V) untypedField(field);
    }
}



================================================
FILE: src/main/java/com/coveros/training/mathematics/MathServlet.java
================================================
package com.coveros.training.mathematics;

import com.coveros.training.helpers.ServletUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.MultipartConfig;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

// Multipart config is necessary so that we can properly receive data when
// sending via the "FormData" API.  Using FormData is part of the modern
// API and also allows sending files.
@MultipartConfig
@WebServlet(name = "MathServlet", urlPatterns = {"/math"}, loadOnStartup = 1)
public class MathServlet extends HttpServlet {

    private static final long serialVersionUID = 1766696864489619658L;
    static org.slf4j.Logger logger = LoggerFactory.getLogger(MathServlet.class);

    private int putNumberInRequest(String itemName, HttpServletRequest request) {
        int item = Integer.parseInt(request.getParameter(itemName));
        request.setAttribute(itemName, item);
        return item;
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        try {
            int itemA = putNumberInRequest("item_a", request);
            int itemB = putNumberInRequest("item_b", request);

            logger.info("received request to add two numbers, {} and {}", itemA, itemB);

            setResultToSum(request, itemA, itemB);
        } catch (NumberFormatException ex) {
            request.setAttribute("result", "Error: only accepts integers");
        }
        forwardToResult(request, response, logger);
    }

    /**
     * Wrapping a static method call for testing.
     */
    void forwardToResult(HttpServletRequest request, HttpServletResponse response, Logger logger) {
        ServletUtils.forwardToRestfulResult(request, response, logger);
    }

    /**
     * Wrapping a request set for easier testing and clarity.
     */
    void setResultToSum(HttpServletRequest request, int itemA, int itemB) {
        final int result = Calculator.add(itemA, itemB);
        request.setAttribute("result", result);
    }

}



================================================
FILE: src/main/java/com/coveros/training/mathematics/package-info.java
================================================
/**
 * Interesting mathematics - adding things, Fibonacci sequence, Ackermann's formula, etc.
 */
package com.coveros.training.mathematics;


================================================
FILE: src/main/java/com/coveros/training/mathematics/TailRecursive.java
================================================
package com.coveros.training.mathematics;

import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;

public interface TailRecursive {

    static <M, N, I, O> BiFunction<M, N, O> tailie(BiFunction<M, N, I> toIntermediary, UnaryOperator<I> unaryOperator, Predicate<I> predicate, Function<I, O> toOutput) {
        return (input1, input2) ->
                $.epsilon(
                        Stream.iterate(
                                toIntermediary.apply(input1, input2),
                                unaryOperator
                        ),
                        predicate,
                        toOutput
                )
                ;
    }

    enum $ {
        END;

        private static <I, O> O epsilon(Stream<I> stream, Predicate<I> predicate, Function<I, O> function) {
            return stream
                    .filter(predicate)
                    .map(function)
                    .findAny()
                    .orElseThrow(RuntimeException::new)
                    ;
        }
    }
}



================================================
FILE: src/main/java/com/coveros/training/persistence/DbServlet.java
================================================
package com.coveros.training.persistence;

import com.coveros.training.helpers.ServletUtils;
import com.coveros.training.helpers.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(name = "DbServlet", urlPatterns = {"/flyway"}, loadOnStartup = 1)
public class DbServlet extends HttpServlet {

    private static final long serialVersionUID = 1960160729302133928L;
    private final IPersistenceLayer pl;

    public DbServlet() {
        pl = new PersistenceLayer();
    }

    public DbServlet(IPersistenceLayer pl) {
        this.pl = pl;
    }

    private static final String RESULT = "result";
    private static final Logger logger = LoggerFactory.getLogger(DbServlet.class);

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) {
        final String action = StringUtils.makeNotNullable(request.getParameter("action"));
        switch (action) {
            case "clean":
                logger.info("received request to clean the database - i.e. remove all data and schema");
                pl.cleanDatabase();
                request.setAttribute(RESULT, "cleaned");
                break;
            case "migrate":
                logger.info("received request to migrate the database - i.e. add schema, but no data");
                pl.migrateDatabase();
                request.setAttribute(RESULT, "migrated");
                break;
            default:
                logger.info("received request to clean, then migrate the database - i.e. putting it a fresh state with no data");
                pl.cleanAndMigrateDatabase();
                request.setAttribute(RESULT, "cleaned and migrated");
        }
        request.setAttribute("return_page", "library.html");

        ServletUtils.forwardToResult(request, response, logger);
    }


}



================================================
FILE: src/main/java/com/coveros/training/persistence/EmptyDataSource.java
================================================
package com.coveros.training.persistence;

import javax.sql.DataSource;
import java.io.PrintWriter;
import java.sql.Connection;
import java.util.logging.Logger;

/**
 * This class only exists because we want no nulls in our
 * system.  In order to do this, we have to be able to create
 * "empty" versions of our classes.  To create an empty String, for
 * example, is simply "".  But an empty DataSource would look like this.
 */
class EmptyDataSource implements DataSource {
    @Override
    public Connection getConnection() {
        throw new NotImplementedException();
    }

    @Override
    public Connection getConnection(String username, String password) {
        throw new NotImplementedException();
    }

    @Override
    public <T> T unwrap(Class<T> iface) {
        throw new NotImplementedException();
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) {
        throw new NotImplementedException();
    }

    @Override
    public PrintWriter getLogWriter() {
        throw new NotImplementedException();
    }

    @Override
    public void setLogWriter(PrintWriter out) {
        throw new NotImplementedException();
    }

    @Override
    public void setLoginTimeout(int seconds) {
        throw new NotImplementedException();
    }

    @Override
    public int getLoginTimeout() {
        throw new NotImplementedException();
    }

    @Override
    public Logger getParentLogger() {
        throw new NotImplementedException();
    }

}



================================================
FILE: src/main/java/com/coveros/training/persistence/IPersistenceLayer.java
================================================
package com.coveros.training.persistence;

import com.coveros.training.authentication.domainobjects.User;
import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.library.domainobjects.Loan;

import java.sql.Date;
import java.util.List;
import java.util.Optional;

/**
 * This is the only place in our application allowed to speak
 * directly to the database.  All business functionality that
 * requires database access must go through here.
 */
public interface IPersistenceLayer {


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Library Persistence Functions
     *
     * ==========================================================
     * ==========================================================
     */


    /**
     * Creates a new borrower in the database
     *
     * @param borrowerName the name of the borrower
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long saveNewBorrower(String borrowerName);


    /**
     * Creates a new loan of a book in the database.
     *
     * @param book       a book we have to loan out
     * @param borrower   a person who is borrowing the book
     * @param borrowDate the date this book was borrowed
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long createLoan(Book book, Borrower borrower, Date borrowDate);


    /**
     * Creates a new book in the database
     *
     * @param bookTitle the String title of a book
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long saveNewBook(String bookTitle);


    /**
     * If we already have a borrower, this command allows us to change
     * their values (except for their id)
     *
     * @param id           the id of a borrower (a constant)
     * @param borrowerName the name of a borrower, which we can change.
     */
    void updateBorrower(long id, String borrowerName);


    /**
     * Delete a book from the database
     * @param id the identifier for a book
     */
    void deleteBook(long id);


    /**
     * Delete a borrower from the database
     * @param id the identifier for a borrower
     */
    void deleteBorrower(long id);


    /**
     * Given the id for a borrower, this command returns their name.
     *
     * @param id a borrower's id.
     * @return the borrower's name, or empty
     */
    Optional<String> getBorrowerName(long id);


    /**
     * Searches for a borrower by name.  Returns full details
     * if found.  return empty borrower data if not found.
     *
     * @param borrowerName the name of a borrower
     * @return a valid borrower, or empty
     */
    Optional<Borrower> searchBorrowerDataByName(String borrowerName);


    /**
     * Find a book by its title
     * @param bookTitle the title of a book
     * @return a valid book, or empty
     */
    Optional<Book> searchBooksByTitle(String bookTitle);


    /**
     * Find a book by its id
     * @param id the database id for a book
     * @return a valid book, or empty
     */
    Optional<Book> searchBooksById(long id);


    /**
     * Find a borrower by their id
     * @param id the database id of a borrower
     * @return a borrower, or empty
     */
    Optional<Borrower> searchBorrowersById(long id);


    /**
     * List all the books in the library
     * @return all the books, or empty
     */
    Optional<List<Book>> listAllBooks();


    /**
     * List all the books currently available for borrowing
     * @return all the available books, or empty
     */
    Optional<List<Book>> listAvailableBooks();


    /**
     * List all the borrowers registered in the library
     * @return a list of all the borrowers, or empty
     */
    Optional<List<Borrower>> listAllBorrowers();


    /**
     * Search for book loans by borrower
     *
     * A borrower may have more than one loan.  But a book
     * can only be loaned to one borrower.  That is why when we
     * search for loans by borrower, we may get multiple loans
     * back, but when we search by book, we only get one back.
     * A book cannot be loaned to two people at the same time!
     *
     * @param borrower a given borrower registered with the library
     * @return a list of loans, or empty
     */
    Optional<List<Loan>> searchForLoanByBorrower(Borrower borrower);


    /**
     * A book can only be loaned to one person.  Find that loan
     * @param book the book used to search for the loan
     * @return a loan, or empty
     */
    Optional<Loan> searchForLoanByBook(Book book);


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Authentication Persistence Functions
     *
     * ==========================================================
     * ==========================================================
     */


    /**
     * Save a new user to the database
     *
     * @param username a String name of a user
     * @return a long id representing its id in the database.  Generated by the database.
     */
    long saveNewUser(String username);


    /**
     * Change the password for a user.
     *
     * We store the user's hash, not their password.  This method
     * first hashes the password, then stores that.
     * @param id the database id for a given user
     * @param password the new password, which we'll hash first before storing
     */
    void updateUserWithPassword(long id, String password);


    /**
     * Search the database for a given borrower by their name
     * @param username a borrower's name
     * @return a user, or empty
     */
    Optional<User> searchForUserByName(String username);


    /**
     * Check whether the credentials are valid
     * @param username a user's chosen username
     * @param password a user's chosen password
     * @return true if the credentials match something we have, empty otherwise
     */
    Optional<Boolean> areCredentialsValid(String username, String password);


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Utility Persistence Functions
     *      General functions related to database persistence
     *
     * ==========================================================
     * ==========================================================
     */


    /**
     * Records the current state of the database as a SQL script,
     * used later for restoring by something like {@link #runRestore(String)}
     *
     * @param backupFileName the path to the sql script, based in the project home directory.
     */
    void runBackup(String backupFileName);


    /**
     * Runs a database restore script.
     *
     * @param backupFileName the path to the sql script, based in the project home directory.
     */
    void runRestore(String backupFileName);


    /**
     * Cleans the database and runs the scripts to update it
     * to the most current version.
     */
    void cleanAndMigrateDatabase();


    /**
     * Cleans the database and runs the scripts to update it
     * to the most current version.
     */
    void cleanDatabase();


    /**
     * Cleans the database and runs the scripts to update it
     * to the most current version.
     */
    void migrateDatabase();


    /**
     * Used to indicate that a persistence layer object is
     * using an empty datasource.  See {@link EmptyDataSource}
     * @return true if the object is "empty"
     */
    boolean isEmpty();
}



================================================
FILE: src/main/java/com/coveros/training/persistence/NotImplementedException.java
================================================
package com.coveros.training.persistence;

class NotImplementedException extends RuntimeException {

    private static final long serialVersionUID = -7063829616868098428L;
}



================================================
FILE: src/main/java/com/coveros/training/persistence/package-info.java
================================================
/**
 * Classes that provide communication with the database
 */
package com.coveros.training.persistence;