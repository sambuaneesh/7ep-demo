


================================================
FILE: src/main/java/com/coveros/training/persistence/ParameterObject.java
================================================
package com.coveros.training.persistence;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;


/**
 * a POJO container for the parameters for the {@link SqlData} object.
 */
public final class ParameterObject<T> {

    /**
     * The data we are injecting into the SQL statement
     */
    final Object data;

    /**
     * The type of the data we are injecting into the SQL statement (e.g. Integer, String, etc.)
     */
    final Class<T> type;

    ParameterObject(Object data, Class<T> type) {
        this.data = data;
        this.type = type;
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        ParameterObject<?> rhs = (ParameterObject<?>) obj;
        return new EqualsBuilder()
                .append(data, rhs.data)
                .append(type, rhs.type)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(63, 7).
                append(data).
                append(type).
                toHashCode();
    }

    public static ParameterObject<Void> createEmpty() {
        return new ParameterObject<>("", Void.class);
    }

    public boolean isEmpty() {
        return this.equals(ParameterObject.createEmpty());
    }

    public final String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

}



================================================
FILE: src/main/java/com/coveros/training/persistence/PersistenceLayer.java
================================================
package com.coveros.training.persistence;

import com.coveros.training.helpers.CheckUtils;
import com.coveros.training.helpers.StringUtils;
import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.library.domainobjects.Loan;
import com.coveros.training.authentication.domainobjects.User;
import org.flywaydb.core.Flyway;
import org.h2.jdbcx.JdbcConnectionPool;

import javax.sql.DataSource;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;


public class PersistenceLayer implements IPersistenceLayer {

    /*
     * ==========================================================
     * ==========================================================
     *
     *  Class construction - details of making this class
     *
     * ==========================================================
     * ==========================================================
     */

    private final DataSource dataSource;

    public PersistenceLayer() {
        this(obtainConnectionPool());
    }

    PersistenceLayer(DataSource ds) {
        dataSource = ds;
    }

    private static JdbcConnectionPool obtainConnectionPool() {
        return JdbcConnectionPool.create(
                "jdbc:h2:mem:training;MODE=PostgreSQL", "", "");
    }

    /*
     * ==========================================================
     * ==========================================================
     *
     *  Micro ORM
     *    Demo has a simplistic Object Relational Mapper (ORM)
     *    implementation.  These are the methods that comprise
     *    the mechanisms for that.
     *
     *    In comparison, a gargantuan project like Hibernate
     *    would consist of a heckuva-lot-more than this.  That's
     *    why this one is termed, "micro"
     *
     * ==========================================================
     * ==========================================================
     */


    /**
     * This command provides a template to execute updates (including inserts) on the database
     */
    void executeUpdateTemplate(String description, String preparedStatement, Object ... params) {
        final SqlData<Object> sqlData = new SqlData<>(description, preparedStatement, params);
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st = prepareStatementWithKeys(sqlData, connection)) {
                executeUpdateOnPreparedStatement(sqlData, st);
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }


    public long executeInsertTemplate(
            String description,
            String preparedStatement,
            Object ... params) {
        final SqlData<Object> sqlData = new SqlData<>(description, preparedStatement, params);
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st = prepareStatementWithKeys(sqlData, connection)) {
                return executeInsertOnPreparedStatement(sqlData, st);
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }


    <T> long executeInsertOnPreparedStatement(SqlData<T> sqlData, PreparedStatement st) throws SQLException {
        sqlData.applyParametersToPreparedStatement(st);
        st.executeUpdate();
        try (ResultSet generatedKeys = st.getGeneratedKeys()) {
            long newId;
            if (generatedKeys.next()) {
                newId = generatedKeys.getLong(1);
                assert (newId > 0);
            } else {
                throw new SqlRuntimeException("failed Sql.  Description: " + sqlData.description + " SQL code: " + sqlData.preparedStatement);
            }
            return newId;
        }
    }


    private <T> void executeUpdateOnPreparedStatement(SqlData<T> sqlData, PreparedStatement st) throws SQLException {
        sqlData.applyParametersToPreparedStatement(st);
        st.executeUpdate();
    }


    /**
     * A helper method.  Simply creates a prepared statement that
     * always returns the generated keys from the database, like
     * when you insert a new row of data in a table with auto-generating primary key.
     *
     * @param sqlData    see {@link SqlData}
     * @param connection a typical {@link Connection}
     */
    private <T> PreparedStatement prepareStatementWithKeys(SqlData<T> sqlData, Connection connection) throws SQLException {
        return connection.prepareStatement(
                sqlData.preparedStatement,
                Statement.RETURN_GENERATED_KEYS);
    }


    <R> Optional<R> runQuery(SqlData<R> sqlData) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st =
                         connection.prepareStatement(sqlData.preparedStatement)) {
                sqlData.applyParametersToPreparedStatement(st);
                try (ResultSet resultSet = st.executeQuery()) {
                    return sqlData.extractor.apply(resultSet);
                }
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }

    }


    /**
     * This is an interface to a wrapper around {@link Function} so we can catch exceptions
     * in the generic function.
     *
     * @param <R> The return type
     * @param <E> The type of the exception
     */
    @FunctionalInterface
    private interface ThrowingFunction<R, E extends Exception> {
        R apply(ResultSet resultSet) throws E;
    }


    /**
     * This wraps the throwing function, so that we are not forced to
     * catch an exception in our ordinary code - it's caught and handled
     * here.
     * @param throwingFunction a lambda that throws a checked exception we have to handle.
     *                         specifically in this case that's a SqlRuntimeException
     * @param <R> the type of value returned
     * @return returns a function that runs and returns a function wrapped with an exception handler
     */
    static <R> Function<ResultSet, R> throwingFunctionWrapper(
            ThrowingFunction<R, Exception> throwingFunction) {

        return resultSet -> {
            try {
                return throwingFunction.apply(resultSet);
            } catch (Exception ex) {
                throw new SqlRuntimeException(ex);
            }
        };
    }


    /**
     * Accepts a function to extract data from a {@link ResultSet} and
     * removes some boilerplate with handling its response.
     * Works in conjunction with {@link #throwingFunctionWrapper}
     * @param extractorFunction a function that extracts data from a {@link ResultSet}
     * @param <T> the type of data we'll retrieve from the {@link ResultSet}
     * @return either the type of data wrapped with an optional, or {@link Optional#empty}
     */
    private <T> Function<ResultSet, Optional<T>> createExtractor(
            ThrowingFunction<Optional<T>, Exception> extractorFunction) {
        return throwingFunctionWrapper(rs -> {
            if (rs.next()) {
                return extractorFunction.apply(rs);
            } else {
                return Optional.empty();
            }
        });
    }


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Business functions
     *     loaning out books, registering users, etc
     *
     * ==========================================================
     * ==========================================================
     */


    // Library functions

    @Override
    public long saveNewBorrower(String borrowerName) {
        CheckUtils.StringMustNotBeNullOrEmpty(borrowerName);
        return executeInsertTemplate(
                "adds a new library borrower",
                "INSERT INTO library.borrower (name) VALUES (?);", borrowerName);
    }


    @Override
    public long createLoan(Book book, Borrower borrower, Date borrowDate) {
        return executeInsertTemplate(
                "Creates a new loan of a book to a borrower",
                "INSERT INTO library.loan (book, borrower, borrow_date) VALUES (?, ?, ?);", book.id, borrower.id, borrowDate);
    }


    @Override
    public long saveNewBook(String bookTitle) {
        CheckUtils.StringMustNotBeNullOrEmpty(bookTitle);
        return executeInsertTemplate(
                "Creates a new book in the database",
                "INSERT INTO library.book (title) VALUES (?);", bookTitle);
    }


    @Override
    public void updateBorrower(long id, String borrowerName) {
        CheckUtils.IntParameterMustBePositive(id);
        CheckUtils.StringMustNotBeNullOrEmpty(borrowerName);
        executeUpdateTemplate(
                "Updates the borrower's data",
                "UPDATE library.borrower SET name = ? WHERE id = ?;", borrowerName, id);
    }


    @Override
    public void deleteBook(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        executeUpdateTemplate(
                "Deletes a book from the database",
                "DELETE FROM library.book WHERE id = ?;", id);
    }


    @Override
    public void deleteBorrower(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        executeUpdateTemplate(
                "Deletes a borrower from the database",
                "DELETE FROM library.borrower WHERE id = ?;", id);
    }


    @Override
    public Optional<String> getBorrowerName(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        Function<ResultSet, Optional<String>> extractor =
                createExtractor(rs -> Optional.of(StringUtils.makeNotNullable(rs.getString(1))));

        return runQuery(new SqlData<>(
                        "get a borrower's name by their id",
                        "SELECT name FROM library.borrower WHERE id = ?;",
                        extractor, id));
    }


    @Override
    public Optional<Borrower> searchBorrowerDataByName(String borrowerName) {
        CheckUtils.StringMustNotBeNullOrEmpty(borrowerName);
        Function<ResultSet, Optional<Borrower>> extractor = createExtractor(rs -> {
            long id = rs.getLong(1);
            String name = StringUtils.makeNotNullable(rs.getString(2));
            return Optional.of(new Borrower(id, name));
        });

        return runQuery(new SqlData<>(
                        "search for details on a borrower by name",
                        "SELECT id, name FROM library.borrower WHERE name = ?;",
                        extractor, borrowerName));
    }


    @Override
    public Optional<Book> searchBooksByTitle(String bookTitle) {
        CheckUtils.StringMustNotBeNullOrEmpty(bookTitle);
        Function<ResultSet, Optional<Book>> extractor = createExtractor(rs -> {
            long id = rs.getLong(1);
            return Optional.of(new Book(id, bookTitle));
        });

        return runQuery(new SqlData<>(
                        "search for a book by title",
                        "SELECT id FROM library.book WHERE title = ?;",
                        extractor, bookTitle));
    }


    @Override
    public Optional<Book> searchBooksById(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        Function<ResultSet, Optional<Book>> extractor = createExtractor(rs -> {
            long bookId = rs.getLong(1);
            String title = StringUtils.makeNotNullable(rs.getString(2));
            return Optional.of(new Book(bookId, title));
        });

        return runQuery(new SqlData<>(
                        "search for a book by title",
                        "SELECT id, title FROM library.book WHERE id = ?;",
                        extractor, id));
    }


    @Override
    public Optional<Borrower> searchBorrowersById(long id) {
        CheckUtils.IntParameterMustBePositive(id);
        Function<ResultSet, Optional<Borrower>> extractor = createExtractor(rs -> {
            long borrowerId = rs.getLong(1);
            String name = StringUtils.makeNotNullable(rs.getString(2));
            return Optional.of(new Borrower(borrowerId, name));
        });

        return runQuery(new SqlData<>(
                        "search for a borrower by name",
                        "SELECT id, name FROM library.borrower WHERE id = ?;",
                        extractor, id));
    }


    @Override
    public Optional<List<Book>> listAllBooks() {
        return listBooks("get all books", "SELECT id, title FROM library.book;");
    }


    @Override
    public Optional<List<Book>> listAvailableBooks() {
        return listBooks("get all available books", "SELECT b.id, b.title FROM library.book b LEFT JOIN library.loan l ON b.id = l.book WHERE l.borrow_date IS NULL;");
    }


    private Optional<List<Book>> listBooks(String description, String sqlCode) {
        Function<ResultSet, Optional<List<Book>>> extractor = createExtractor(rs -> {
            List<Book> bookList = new ArrayList<>();
            do {
                long id = rs.getLong(1);
                String title = StringUtils.makeNotNullable(rs.getString(2));
                bookList.add(new Book(id, title));
            } while (rs.next());
            return Optional.of(bookList);
        });

        return runQuery(new SqlData<>(
                        description,
                        sqlCode,
                        extractor));
    }


    @Override
    public Optional<List<Borrower>> listAllBorrowers() {
        Function<ResultSet, Optional<List<Borrower>>> extractor = createExtractor(rs -> {
            List<Borrower> borrowerList = new ArrayList<>();
            do {
                long id = rs.getLong(1);
                String name = StringUtils.makeNotNullable(rs.getString(2));
                borrowerList.add(new Borrower(id, name));
            } while (rs.next());
            return Optional.of(borrowerList);
        });

        return runQuery(new SqlData<>(
                        "get all borrowers",
                        "SELECT id, name FROM library.borrower;",
                        extractor));
    }


    @Override
    public Optional<List<Loan>> searchForLoanByBorrower(Borrower borrower) {
        Function<ResultSet, Optional<List<Loan>>> extractor = createExtractor(rs -> {
            List<Loan> loans = new ArrayList<>();
            do {
                final long loanId = rs.getLong(1);
                final Date borrowDate = rs.getDate(2);
                final long bookId = rs.getLong(3);
                final String bookTitle = StringUtils.makeNotNullable(rs.getString(4));
                final Date borrowDateNotNullable = borrowDate == null ? Date.valueOf("0000-01-01") : borrowDate;
                loans.add(new Loan(new Book(bookId, bookTitle), borrower, loanId, borrowDateNotNullable));
            } while (rs.next());
            return Optional.of(loans);
        });

        return runQuery(new SqlData<>(
                "search for all loans by borrower",
                "SELECT loan.id, loan.borrow_date, loan.book, book.title " +
                        "FROM library.loan loan " +
                        "JOIN library.book book ON book.id = loan.book " +
                        "WHERE loan.borrower = ?;",
                extractor, borrower.id));
    }


    @Override
    public Optional<Loan> searchForLoanByBook(Book book) {
        Function<ResultSet, Optional<Loan>> extractor = createExtractor(rs -> {
            final long loanId = rs.getLong(1);
            final Date borrowDate = rs.getDate(2);
            final long borrowerId = rs.getLong(3);
            final String borrowerName = StringUtils.makeNotNullable(rs.getString(4));
            final Date borrowDateNotNullable = borrowDate == null ? Date.valueOf("0000-01-01") : borrowDate;
            return Optional.of(new Loan(book, new Borrower(borrowerId, borrowerName), loanId, borrowDateNotNullable));
        });

        return runQuery(new SqlData<>(
                "search for a loan by book",
                "SELECT loan.id, loan.borrow_date, loan.borrower, bor.name " +
                        "FROM library.loan loan " +
                        "JOIN library.borrower bor ON bor.id = loan.borrower " +
                        "WHERE loan.book = ?;",
                extractor, book.id));
    }


    // authentication functions


    @Override
    public long saveNewUser(String username) {
        CheckUtils.StringMustNotBeNullOrEmpty(username);
        return executeInsertTemplate(
                "Creates a new user in the database",
                "INSERT INTO auth.user (name) VALUES (?);", username);
    }


    @Override
    public Optional<User> searchForUserByName(String username) {
        CheckUtils.StringMustNotBeNullOrEmpty(username);
        Function<ResultSet, Optional<User>> extractor = createExtractor(rs -> {
            final long id = rs.getLong(1);
            return Optional.of(new User(username, id));
        });

        return runQuery(new SqlData<>(
                "search for a user by id, return that user if found, otherwise return an empty user",
                "SELECT id  FROM auth.user WHERE name = ?;",
                extractor, username));
    }


    @Override
    public Optional<Boolean> areCredentialsValid(String username, String password) {
        Function<ResultSet, Optional<Boolean>> extractor = createExtractor(rs -> {
            final long id = rs.getLong(1);
            assert (id > 0);
            return Optional.of(true);
        });

        final String hexHash = createHashedValueFromPassword(password);
        return runQuery(new SqlData<>(
                "check to see if the credentials for a user are valid",
                "SELECT id FROM auth.user WHERE name = ? AND password_hash = ?;",
                extractor, username, hexHash));
    }


    @Override
    public void updateUserWithPassword(long id, String password) {
        CheckUtils.IntParameterMustBePositive(id);
        String hashedPassword = createHashedValueFromPassword(password);
        executeUpdateTemplate(
                "Updates the user's password field with a new hash",
                "UPDATE auth.user SET password_hash = ? WHERE id = ?;", hashedPassword, id);
    }


    /**
     * Given a password (for example, "password123"), return a
     * hash of that.
     * @param password a user's password
     * @return a hash of the password value.  a one-way function that returns a unique value,
     *          but different than the original, cannot be converted back to its original value.
     */
    private String createHashedValueFromPassword(String password) {
        CheckUtils.StringMustNotBeNullOrEmpty(password);
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] encodedhash = digest.digest(
                    password.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(encodedhash);
        } catch (NoSuchAlgorithmException e) {
            throw new SqlRuntimeException(e);
        }
    }


    /**
     * Converts an array of bytes to their corresponding hex string
     * @param bytes an array of bytes
     * @return a hex string of that array
     */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }


    /*
     * ==========================================================
     * ==========================================================
     *
     *  General utility methods
     *
     * ==========================================================
     * ==========================================================
     */


    public static IPersistenceLayer createEmpty() {
        return new PersistenceLayer(new EmptyDataSource());
    }


    @Override
    public boolean isEmpty() {
        return this.dataSource.getClass().equals(EmptyDataSource.class);
    }

    @Override
    public void runBackup(String backupFileName) {
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st = connection.prepareStatement("SCRIPT TO ?")) {
                st.setString(1, backupFileName);
                st.execute();
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }

    @Override
    public void runRestore(String backupFileName) {
        String dbScriptsDirectory="src/integration_test/resources/db_sample_files/";
        String fullPathToBackup = dbScriptsDirectory + backupFileName;
        try (Connection connection = dataSource.getConnection()) {
            try (PreparedStatement st = connection.prepareStatement(
                    "DROP SCHEMA IF EXISTS ADMINISTRATIVE CASCADE;" +
                            "DROP SCHEMA IF EXISTS AUTH CASCADE;" +
                            "DROP SCHEMA IF EXISTS LIBRARY CASCADE;")) {
                st.execute();
            }
            try (PreparedStatement st = connection.prepareStatement("RUNSCRIPT FROM ?")) {
                st.setString(1, fullPathToBackup);
                st.execute();
            }
        } catch (SQLException ex) {
            throw new SqlRuntimeException(ex);
        }
    }


    /*
     * ==========================================================
     * ==========================================================
     *
     *  Database migration code - using FlywayDb
     *
     * ==========================================================
     * ==========================================================
     */


    @Override
    public void cleanAndMigrateDatabase() {
        cleanDatabase();
        migrateDatabase();
    }

    @Override
    public void cleanDatabase() {
        Flyway flyway = configureFlyway();
        flyway.clean();
    }

    @Override
    public void migrateDatabase() {
        Flyway flyway = configureFlyway();
        flyway.migrate();
    }

    private Flyway configureFlyway() {
        return Flyway.configure()
                .schemas("ADMINISTRATIVE", "LIBRARY", "AUTH")
                .dataSource(this.dataSource)
                .load();
    }

}



================================================
FILE: src/main/java/com/coveros/training/persistence/SqlData.java
================================================
package com.coveros.training.persistence;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.checkerframework.checker.nullness.qual.Nullable;

import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;

/**
 * This class encapsulates some of the actions related to
 * injecting data into a prepared SQL statement, so that
 * we are able to summarize what we want done without
 * all the annoying boilerplate.  See examples like {@link PersistenceLayer#saveNewBorrower}
 * <p>
 * Was necessary to suppress the nullness warnings on this class due to its
 * use of generics.
 * The generic R is the result type - if we ask for a string, R would be a String.
 * On the other hand if R might be a compound type, like Employee.
 */
final class SqlData<R> {

    /**
     * A summary description of what this SQL is doing.
     */
    final String description;

    /**
     * This is the String text of the SQL prepared statement.  We're using PostgreSQL,
     * see https://jdbc.postgresql.org/documentation/81/server-prepare.html
     */
    final String preparedStatement;

    /**
     * The data that we will inject to the SQL statement.
     */
    private final List<ParameterObject<?>> params;

    /**
     * A generic function - takes a {@link ResultSet} straight from the database,
     * and then carries out actions on it, per the user's intentions, to convert it
     * into something of type {@link R}.
     */
    public final Function<ResultSet, Optional<R>> extractor;

    SqlData(String description, String preparedStatement, Object ... params) {
        this(description, preparedStatement, (resultSet -> Optional.empty()), params);
    }

    /**
     * Creates an object that is used to avoid some of the boilerplate
     * in running database CRUD operations.
     *
     * @param description       A string that describes in plain English what this SQL does.
     * @param preparedStatement The SQL that is run on the database
     * @param extractor         see {@link #extractor} a function that is run to convert the returned {@link ResultSet} into whatever we want
     */
    SqlData(String description, String preparedStatement, Function<ResultSet, Optional<R>> extractor, Object ... params) {
        this.description = description;
        this.preparedStatement = preparedStatement;
        this.params = new ArrayList<>();
        if (params.length > 0) {
            generateParams(params);
        }
        this.extractor = extractor;
    }

    /**
     * Loads the parameters for this SQL
     * @param params
     */
    private void generateParams(Object[] params) {
        for (Object param:params) {
            addParameter(param, param.getClass());
        }
    }


    /**
     * A list of the parameters to a particular SQL statement.
     * Add to this list in the order of the statement.
     * For example,
     * for SELECT * FROM USERS WHERE a = ? and b = ?
     * <p>
     * first add the parameter for a, then for b.
     *
     * @param data  a particular item of data.  Any object will do.  Look at {@link #applyParametersToPreparedStatement(PreparedStatement)}
     *              to see what we can process.
     * @param clazz the class of the thing.  I would rather not use reflection, let's keep it above board for now.
     */
    <T> void addParameter(Object data, Class<T> clazz) {
        params.add(new ParameterObject<>(data, clazz));
    }

    /**
     * Loop through the parameters that have been added and
     * serially add them to the prepared statement.
     *
     * @param st a prepared statement
     */
    void applyParametersToPreparedStatement(PreparedStatement st) {
        try {
            for (int i = 1; i <= params.size(); i++) {
                ParameterObject<?> p = params.get(i - 1);
                if (p.type == String.class) {
                    st.setString(i, (String) p.data);
                } else if (p.type == Integer.class) {
                    st.setInt(i, (Integer) p.data);
                } else if (p.type == Long.class) {
                    st.setLong(i, (Long) p.data);
                } else if (p.type == Date.class) {
                    st.setDate(i, (Date) p.data);
                }
            }
        } catch (SQLException e) {
            throw new SqlRuntimeException(e);
        }
    }

    public final boolean equals(@Nullable Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        SqlData<?> rhs = (SqlData<?>) obj;
        return new EqualsBuilder()
                .append(description, rhs.description)
                .append(preparedStatement, rhs.preparedStatement)
                .append(params, rhs.params)
                .append(extractor, rhs.extractor)
                .isEquals();
    }

    public final int hashCode() {
        // you pick a hard-coded, randomly chosen, non-zero, odd number
        // ideally different for each class
        return new HashCodeBuilder(53, 97)
                .append(description)
                .append(preparedStatement)
                .append(params)
                .append(extractor)
                .toHashCode();
    }

    public final String toString() {
        StringBuilder paramsString = new StringBuilder();
        for(ParameterObject<?> p : params) {
            paramsString.append(p);
        }

        return new ToStringBuilder(this).
                append("description", description).
                append("params", paramsString.toString()).
                append("prepared statement", preparedStatement).
                toString();
    }

    public static <T> SqlData<T> createEmpty() {
        return new SqlData<>("", "");
    }

    public boolean isEmpty() {
        return this.equals(SqlData.createEmpty());
    }

}



================================================
FILE: src/main/java/com/coveros/training/persistence/SqlRuntimeException.java
================================================
package com.coveros.training.persistence;

class SqlRuntimeException extends RuntimeException {

    public SqlRuntimeException(Exception ex) {
        super(ex);
    }

    public SqlRuntimeException(String message) {
        super(message);
    }
}



================================================
FILE: src/main/java/com/coveros/training/tomcat/package-info.java
================================================
/**
 * Classes that configure Tomcat server, specifically.
 * For example, WebAppListner - Tomcat uses that to know
 * what commands to run at server start.
 */
package com.coveros.training.tomcat;


================================================
FILE: src/main/java/com/coveros/training/tomcat/WebAppListener.java
================================================
package com.coveros.training.tomcat;

import com.coveros.training.persistence.IPersistenceLayer;
import com.coveros.training.persistence.PersistenceLayer;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;

/**
 * The purpose of this class is to run certain commands at the
 * start-up of the application.
 */
@WebListener
public class WebAppListener implements ServletContextListener {

    private final IPersistenceLayer pl;

    public WebAppListener() {
        pl = new PersistenceLayer();
    }

    public WebAppListener(IPersistenceLayer pl) {
        this.pl = pl;
    }

    /**
     * Cleans and migrates the database using Flyway.
     * See database migration files like V2__Rest_of_tables_for_auth_and_library.sql
     */
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        //  clean the database and configure the schema
        pl.cleanAndMigrateDatabase();
    }

    /**
     * This does nothing, but it's required to implement per the interface.
     */
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        // do nothing.
    }

}


================================================
FILE: src/main/javadoc/overview.html
================================================
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
    <TITLE>API Overview</TITLE>
</HEAD>
<BODY>
<p>
    This is the Demo application by <a href="https://www.coveros.com">Coveros</a>.  You can find
    plenty of documentation in the docs/ directory.  It is listed on <a href="https://github.com/7ep/demo">Github</a>
</p>
<p>
    When looking into each class, the following patterns may aid in your understanding.
</p>
<ul>
<li>Files that
    end with "Servlet" are the code that makes the application available to the outside world, that
    is, it is the definition of web API
</li>
<li>Files that end with "Utils" are the business logic for a particular domain</li>
</ul>
</BODY>
</HTML>


================================================
FILE: src/main/resources/README.txt
================================================
The resources consist of:

log4j2.xml      :    configuration for the logging mechanism when Demo runs
db              :    database files


================================================
FILE: src/main/resources/log4j2.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Configuration monitorinterval="30" status="info" strict="true">

    <Appenders>
        <!-- configure the logging output for the console.  See https://logging.apache.org/log4j/2.x/manual/layouts.html -->
        <Appender type="Console" name="Console">
            <Layout type="PatternLayout" pattern="%d %p %m%n"/>
        </Appender>
    </Appenders>


    <Loggers>
        <!-- set the logging to the INFO level - meaning it will show INFO and up (INFO, WARN, FATAL, etc) -->
        <Root level="INFO">
            <AppenderRef ref="Console"/>
        </Root>
    </Loggers>

</Configuration>



================================================
FILE: src/main/resources/db/README.txt
================================================
The database files consist of:

migration           :  Flyway scripts to manipulate the schema of the database.  For example,
                       one thing they do, among others, is to create a user table.


================================================
FILE: src/main/resources/db/migration/V1__Create_person_table.sql
================================================
-- Maybe we'll create a person table - something to hold our librarians and borrowers
create table library.PERSON (
    id serial PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);



================================================
FILE: src/main/resources/db/migration/V2__Rest_of_tables_for_auth_and_library.sql
================================================
-- eh, instead of one table for both librarians and borrowers,
-- we'll create a borrower table for borrowers and a
-- separate auth.USER table for librarians
drop table library.person;

-- here's our borrower table
create table library.BORROWER (
    id serial PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

-- books, obviously - it's a library
create table library.BOOK (
    id serial PRIMARY KEY,
    title VARCHAR(100) NOT NULL
);

-- this tracks which books have been lent to borrowers
create table library.LOAN (
    id serial PRIMARY KEY,
    book int NOT NULL REFERENCES library.BOOK (id) ON DELETE CASCADE,
    borrower int NOT NULL REFERENCES library.BORROWER (id) ON DELETE CASCADE,
    borrow_date date NOT NULL
);

-- this holds the list of librarians, mainly their name and their
-- password hash (used during authentication)
create table auth.USER (
    id serial PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    password_hash VARCHAR(100)
);



================================================
FILE: src/main/webapp/catalog.css
================================================
[Empty file]


================================================
FILE: src/main/webapp/catalog.js
================================================
window.addEventListener( "load", function () {
  function sendData(formObject) {
    const XHR = new XMLHttpRequest();

    // Bind the FormData object and the form element
    const FD = new FormData( formObject );

    // Define what happens on successful data submission
    XHR.addEventListener( "load", function(event) {
      var responseArea = formObject.getElementsByClassName("responsearea")[0];
      responseArea.innerText = event.target.responseText;
    } );

    // Define what happens in case of error
    XHR.addEventListener( "error", function( event ) {
      alert( 'Oops! Something went wrong.' );
    } );


    let queryString = '';
    if (formObject.method == "get") {
        entries = [];
        for(var pair of FD.entries()) {
           entries.push(pair[0]+ '='+ pair[1]);
        }
        queryString = '?'+entries.join('&');
    }

    // Set up our request
    XHR.open( formObject.method, formObject.action + queryString);

    // The data sent is what the user provided in the form
    XHR.send( FD );
  }

  let forms = document.querySelectorAll("form");
  for (let j = 0; j < forms.length; j++){
    // Access the form element...
    let form = forms[j];

    // ...and take over its submit event.
    form.addEventListener( "submit", function ( event ) {
      event.preventDefault();
      sendData(form);
    } );
  }
} );


================================================
FILE: src/main/webapp/dbhelp.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Database help</title>
</head>
<body>
<p>To log in, username and password is empty and this is the URL:</p>
<p>jdbc:h2:mem:training;MODE=PostgreSQL;DB_CLOSE_DELAY=-1</p>
</body>
</html>


================================================
FILE: src/main/webapp/endpointcatalog.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8">
    <title>Catalog of endpoints for Demo</title>
    <link rel="stylesheet" href="catalog.css">
    <script type="text/javascript" src="catalog.js"></script>
</head>
<body>

<form id="post_math_form" method="POST" action="math" autocomplete="off">
    <fieldset>
        <legend class="title" id="math_title">The "math" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Simply adds two integers where the integers are each
                between -2147483648 and 2147483647, and their sum also does
                not exceed that range</span>
        </p>
        <p>
            <label for="math_param_item_a">item_a</label>
            <input type="number" id="math_param_item_a" name="item_a">
        </p>
        <p>
            <label for="math_param_item_b">item_b</label>
            <input type="number" id="math_param_item_b" name="item_b">
        </p>
        <p>
            <label for="math_response">Response:</label>
            <textarea class="responsearea" id="math_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoMathButton">POST</button>
        </p>
    </fieldset>
</form>

<form id="post_fibonacci_form" method="POST" action="fibonacci" autocomplete="off">
    <fieldset>
        <legend class="title" id="fibonacci_title">The "fibonacci" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Calculates the nth value in the Fibonacci sequence, per one of three algorithms.  The
            default, naive, recursive approach is "default recursive".  The other two use more sophisticated
            tail-recursive techniques.</span>
        </p>
        <p>
            <label for="fibonacci_param_fib_param_n">fib_param_n</label>
            <input type="number" id="fibonacci_param_fib_param_n" name="fib_param_n">
        </p>
        <p>
            <label for="fibonacci_param_fib_algorithm_choice">fib_algorithm_choice</label>
            <select id="fibonacci_param_fib_algorithm_choice" name="fib_algorithm_choice">
                <option value="default_recursive">default_recursive</option>
                <option value="tail_recursive_1">tail_recursive_1</option>
                <option value="tail_recursive_2">tail_recursive_2</option>
            </select>
        </p>
        <p>
            <label for="fibonacci_response">Response:</label>
            <textarea class="responsearea" id="fibonacci_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoFibonacciButton">POST</button>
        </p>
    </fieldset>
</form>

<form id="post_ackermann_form" method="POST" action="ackermann" autocomplete="off">
    <fieldset>
        <legend class="title" id="ackermann_title">The "ackermann" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Calculates the nth value in the Ackermann sequence, per one of two algorithms.  The
            default, naive, recursive approach is "default recursive".  The other one uses a sophisticated
            tail-recursive technique.</span>
        </p>
        <p>
            <label for="ackermann_param_ack_param_m">ack_param_m</label>
            <input type="number" id="ackermann_param_ack_param_m" name="ack_param_m">
        </p>
        <p>
            <label for="ackermann_param_ack_param_n">ack_param_n</label>
            <input type="number" id="ackermann_param_ack_param_n" name="ack_param_n">
        </p>
        <p>
            <label for="ackermann_param_ack_algorithm_choice">ack_algorithm_choice</label>
            <select id="ackermann_param_ack_algorithm_choice" name="ack_algorithm_choice">
                <option value="default_recursive">default_recursive</option>
                <option value="tail_recursive">tail_recursive</option>
            </select>
        </p>
        <p>
            <label for="ackermann_response">Response:</label>
            <textarea class="responsearea" id="ackermann_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoAckermannButton">POST</button>
        </p>
    </fieldset>
</form>

<form id="get_book_form" method="GET" action="book" autocomplete="off">
    <fieldset>
        <legend class="title" id="book_title">The "book" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Lists and searches books.  If you provide no input, it will list all books.  If you provide
            an identifier number or a title, it will search by those.  If you provide both an identifier
            and a title, it will return an error message.</span>
        </p>
        <p>
            <label for="book_param_id">id</label>
            <input type="number" id="book_param_id" name="id">
        </p>
        <p>
            <label for="book_param_title">title</label>
            <input type="text" id="book_param_title" name="title">
        </p>
        <p>
            <label for="book_response">Response:</label>
            <textarea class="responsearea" id="book_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoBookButton">POST</button>
        </p>
    </fieldset>
</form>

<form id="get_borrower_form" method="GET" action="borrower" autocomplete="off">
    <fieldset>
        <legend class="title" id="borrower_title">The "borrower" endpoint</legend>
        <p>
            <label>Description:</label>
            <span>Lists and searches borrowers.  If you provide no input, it will list all borrowers.  If you provide
            an identifier number or a name, it will search by those.  If you provide both an identifier
            and a name, it will return an error message.</span>
        </p>
        <p>
            <label for="borrower_param_id">id</label>
            <input type="number" id="borrower_param_id" name="id">
        </p>
        <p>
            <label for="borrower_param_name">name</label>
            <input type="text" id="borrower_param_name" name="name">
        </p>
        <p>
            <label for="borrower_response">Response:</label>
            <textarea class="responsearea" id="borrower_response" rows="1" readonly ></textarea>
        </p>
        <p>
            <button id="postToDemoBorrowerButton">POST</button>
        </p>
    </fieldset>
</form>

</body>

</html>


================================================
FILE: src/main/webapp/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8">
    <title>Demo Index</title>
</head>
<body>
<ul>
    <li><a href="library.html">Library</a></li>
    <li><a href="endpointcatalog.html">Endpoint catalog</a></li>
    <li><a href="commit.html">Current commit</a></li>
</ul>
</body>
</html>


================================================
FILE: src/main/webapp/library.html
================================================
<html>
<head>
    <title>Library</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css">

</head>
<body>

<form method="post" action="login" autocomplete="off" class="regular-form">

    <h2>Librarian login</h2>
    <label for="login_username">Name:</label>
    <p><input type="text" id="login_username" name="username" placeholder="name"/></p>

    <label for="login_password">Password:</label>
    <p><input type="password" id="login_password" name="password" placeholder="password123"/></p>

    <p><input type="submit" id="login_submit" value="login"/></p>
</form>

<form method="post" action="register" autocomplete="off" class="regular-form">

    <h2>Register librarian</h2>
    <label for="register_username">Name:</label>
    <p><input type="text" id="register_username" name="username" placeholder="name"/></p>

    <label for="register_password">Password:</label>
    <p><input type="password" id="register_password" name="password" placeholder="password123"/></p>
    <p><input type="submit" id="register_submit" value="register"/></p>
</form>

<form method="post" action="lend" autocomplete="off" class="regular-form">

    <h2>Borrow a book</h2>

    <label for="lend_book">Book:</label>
    <p><input type="text" id="lend_book" name="book" placeholder="book"/></p>

    <label for="lend_borrower">Borrower:</label>
    <p><input type="text" id="lend_borrower" name="borrower" placeholder="borrower"/></p>

    <p><input type="submit" id="lend_book_submit" value="lend"/></p>
</form>


<form method="post" action="registerbook" autocomplete="off" class="regular-form">

    <h2>Register a book</h2>

    <label for="register_book">Book:</label>
    <p><input type="text" id="register_book" name="book" placeholder="book"/></p>

    <p><input type="submit" id="register_book_submit" value="register"/></p>
</form>


<form method="post" action="registerborrower" autocomplete="off" class="regular-form">

    <h2>Register a borrower</h2>

    <label for="book">Borrower:</label>
    <p><input type="text" id="register_borrower" name="borrower" placeholder="borrower"/></p>

    <p><input type="submit" id="register_borrower_submit" value="register"/></p>
</form>

<div class="buttons">
  <h2>Database versioning</h2>
  <form action="flyway" class="button-form">
      <input type="hidden" name="action" value="clean"/>
      <input type="submit" value="Clean"/>
  </form>
  <form action="flyway" class="button-form">
      <input type="hidden" name="action" value="migrate"/>
      <input type="submit" value="Migrate"/>
  </form>
  <form action="flyway" class="button-form">
      <input type="submit" value="Clean / Migrate"/>
  </form>
    <p><a href="console">Database console</a></p>
    <p><a href="dbhelp.html">Console help</a></p>
</div>

</body>
</html>
<script src="library.js"></script>


================================================
FILE: src/main/webapp/library.js
================================================
/**
  * This code enables us to keep track of which listeners we
  * have added to elements.  For example, if we add a "click"
  * listener, this code adds a new method, getEventListeners,
  * to get the list of event listeners.
  */
var ListenerTracker=new function(){
    // a variable to track whether this has been run already.
    // is set to true after the initial run of this code, so follow-up
    // calls will do nothing.
    var is_active=false;

    // listener tracking datas

    // the web elements (also known as "nodes")
    var _elements_  =[];

    //
    var _listeners_ =[];

    this.init=function(){
        if(!is_active){//avoid duplicate call
            intercep_events_listeners();
        }
        is_active=true;
    };

    // register individual element and returns its corresponding listeners
    var register_element=function(element){
        if(_elements_.indexOf(element)==-1){
            // NB : split by useCapture to make listener easier to find when removing
            var elt_listeners=[{/*useCapture=false*/},{/*useCapture=true*/}];
            _elements_.push(element);
            _listeners_.push(elt_listeners);
        }
        return _listeners_[_elements_.indexOf(element)];
    };
    var intercep_events_listeners = function(){
        // backup overrided methods
        var _super_={
            "addEventListener"      : HTMLElement.prototype.addEventListener,
            "removeEventListener"   : HTMLElement.prototype.removeEventListener
        };

        Element.prototype["addEventListener"]=function(type, listener, useCapture){
            var listeners=register_element(this);
            // add event before to avoid registering if an error is thrown
            _super_["addEventListener"].apply(this,arguments);
            // adapt to 'elt_listeners' index
            useCapture=useCapture?1:0;

            if(!listeners[useCapture][type])listeners[useCapture][type]=[];
            listeners[useCapture][type].push(listener);
        };

        Element.prototype["removeEventListener"]=function(type, listener, useCapture){
            var listeners=register_element(this);
            // add event before to avoid registering if an error is thrown
            _super_["removeEventListener"].apply(this,arguments);
            // adapt to 'elt_listeners' index
            useCapture=useCapture?1:0;
            if(!listeners[useCapture][type])return;
            var lid = listeners[useCapture][type].indexOf(listener);
            if(lid>-1)listeners[useCapture][type].splice(lid,1);
        };

        Element.prototype["getEventListeners"]=function(type){
            var listeners=register_element(this);
            // convert to listener datas list
            var result=[];
            for(var useCapture=0,list;list=listeners[useCapture];useCapture++){
                if(typeof(type)=="string"){// filtered by type
                    if(list[type]){
                        for(var id in list[type]){
                            result.push({"type":type,"listener":list[type][id],"useCapture":!!useCapture});
                        }
                    }
                }else{// all
                    for(var _type in list){
                        for(var id in list[_type]){
                            result.push({"type":_type,"listener":list[_type][id],"useCapture":!!useCapture});
                        }
                    }
                }
            }
            return result;
        };
    };
}();
ListenerTracker.init();

/**
  * Creates a list item. see https://www.w3.org/TR/REC-html40/struct/lists.html#edef-LI
  * Adds an attribute, "data", that holds the text data, and also
  * puts the text in as the inner text node
  */
function createItemForList(text) {
    let item = document.createElement('li');
    item.setAttribute("data",text);
    item.appendChild(document.createTextNode(text));
    return item;
}

/**
  * Adds the behavior that takes place when a user clicks on 
  * an item in the autocomplete search box.  That behavior
  * is to put the item in the text input field
  * @param item an item in the autocomplete list, like a book for example
  * @param the base id on which to select parts of the searchbox
  */
function addItemClickBehavior(item, input_id) {
    console.assert(item.getEventListeners('click').length == 0)
    // if the user clicks, put the value in the input field
    item.addEventListener('click', function(event) {
      let input_field = document.getElementById(input_id);
      input_field.value = event.target.innerText;
      deleteSearchBox(input_id);
    });
    console.assert(item.getEventListeners('click').length == 1)
}

/**
  * given an id, find and remove a searchbox from the page
  */
function deleteSearchBox(input_id) {
  let searchbox = document.getElementById(input_id+"_searchbox");
  if (searchbox != null) {
    searchbox.remove();
  }
}

/**
  * creates a unordered list to contain the autocomplete items
  */
function createList(input_id) {
    var innerList = document.createElement('ul');
    innerList.setAttribute("id", input_id+"_searchlist");
    return innerList;
}

/**
  * creates a div that sits under a given input, as a
  * container to the autocomplete functionality
  */
function createSearchBox(input_id) {
    let searchbox = document.createElement('div');
    searchbox.setAttribute("id", input_id+"_searchbox");
    searchbox.setAttribute("class", "searchbox");
    return searchbox;
}

/**
  * Add a dropdown, a <select> to choose amongst the available books.
  */
function addDropdown(id, getdata) {
    let element = document.getElementById(id);
    let nameOfElement = element.getAttribute("name");
    let parent = element.parentNode;
    parent.removeChild(element);
    let select = document.createElement('select');
    select.setAttribute("id", id);
    select.setAttribute("name", nameOfElement);
    let option;

    getdata().forEach(function( item ) {
        option = document.createElement('option');
        option.value = option.textContent = item;
        select.appendChild( option );
    });
    let defaultOption = document.createElement('option');
    defaultOption.textContent = "Choose here";
    defaultOption.setAttribute("selected", "");
    defaultOption.setAttribute("disabled", "");
    defaultOption.setAttribute("hidden", "");
    select.appendChild(defaultOption)

    parent.appendChild(select);
}

/**
  * adds an autocomplete functionality to a given input.
  * this allows a nicer user experience for the user - as they type,
  * the possibilties are narrowed down, and they click on an item to 
  * select it.
  */
function addAutoComplete(id, getdata) {

    let element = document.getElementById(id);

    /**
      * If the autocomplete searchbox is open and the user presses
      * the escape key, remove the searchbox
      */
    function considerRemovingSearchBoxOnPressingEscape(event) {
        if (event.key === "Escape") {
            deleteSearchBox(id);
        }
    }

    function handleBlurEvent(event) {
        // if we tab from this input to another, we'll get a "relatedTarget", and that's
        // the only situation where we would want to close the searchbox - tabbing to another field.
        // so if it's null, ignore the blur event.
        if (event.relatedTarget === null) {
            return;
        } else {
            deleteSearchBox(id);
        }

    }

    function considerKillingThisModalIfOutsideClick(event) {
      if (event.target != document.getElementById(id+"searchbox")) {
        deleteSearchBox(id);
      }
    }

    document.addEventListener('keydown', considerRemovingSearchBoxOnPressingEscape);
    document.addEventListener('click', considerKillingThisModalIfOutsideClick);
    element.addEventListener('blur', handleBlurEvent);

    function openAutoComplete(event) {
        if (event.key === "Escape") return;
        // as the user presses keys, we keep checking what is current
        // and we provide a search box for that.

        let currentContent = element.value;
        if (currentContent.length == 0) {
            // if there's no text in the input box, don't show a searchbox.

            // delete it if it exists
             deleteSearchBox(id);
        } else {
            // if there's more than one item in the input...
             
           let list = createList(id);

            // if the searchbox doesn't exist, create it...
            if (document.getElementById(id+"_searchbox") == null) {
                let searchbox = createSearchBox(id);
                element.insertAdjacentElement('afterend',searchbox);
                searchbox.appendChild(list);
            }

            // get data for the list.
            let mydata = getdata();

            addFilteredData(list, mydata, currentContent, id);

        }
    }

    // if the user clicks, open the autocomplete
    element.addEventListener('keyup', openAutoComplete);
    element.addEventListener('click', openAutoComplete);

}

/**
  * fills the list with data depending on what the user has typed into 
  * the input field.  
  * @param list the list in the searchbox which holds the results
  * @param data the whole set of data from which to filter
  * @param currentContent what the user has currently typed into the input field
  * @param id the core identifier passed around.  other components build off that,
  *        e.g. if the id is abc, then the list item might be 
  */
function addFilteredData(list, data, currentContent, id) {
    let maxSearchListSize = 5;
    let filteredList = 
        data.filter(text => text.includes(currentContent))
            .slice(0,maxSearchListSize);
    for (var i = 0; i < filteredList.length; i++) {
        let item = createItemForList(filteredList[i]);
        // if the user clicks, put the value in the input field
        addItemClickBehavior(item, id);
        list.appendChild(item);
    }
    return list;
}

/**
  * disables an input if there's no data for it.  I mean, there's 
  * no point then, is there?
  */
function lockInput(id) {
    let input = document.getElementById(id);
    input.placeholder = "locked - no data";
    input.disabled = true;
}

/**
  * Communicates with the server.  
  * @param verb - GET or POST
  * @param path - the "action", the route to the endpoint.  e.g. "fib" or "math"
  * @param data - if posting, the data to send to the server.
  */ 
function talk(verb, path, data) {
  return new Promise((resolve, reject) => {
    let r = new XMLHttpRequest();
    r.open(verb, path, true);
    //Send the proper header information along with the request
    r.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    r.onreadystatechange = function () {
      if (r.readyState != 4 || r.status != 200) {
        return;
      } else {
          resolve(r.responseText);
      }

    }
    r.send(data);
  });
}

/**
  *  converts a json object to an array of strings
  *  given a lambda (extractor) to use in the map function
  *  to extract the string desired.  if parsing fails, do nothing.
  */
let extractData = function(value, extractor) {
  try {
    return JSON.parse(value).map(extractor).sort();
  } catch (error) {
    // do nothing
    // console.log("unable to parse the following as JSON: " + value);
  }
}

// Add an autocomplete to the book input for lending
talk("GET", "listavailable")
.then(function(v){
  betterUserExperienceForInput(v, book => book.Title, "lend_book");
});

// Add an autocomplete to the borrower input for lending
talk("GET", "borrower")
.then(function(v) {
    betterUserExperienceForInput(v, borrower => borrower.Name, "lend_borrower");
});

/**
  * Adding this to an input field will provide a better UX experience
  * in certain cases.
  *
  * This is used on the "lend book" fields, to provide a better experience.
  * specifically, if there are no values to select from on a field, lock
  * the field.  If there are between 1 and 9 values, create a dropdown.
  * otherwise, create an autocommplete mechanism - as the user types values,
  * a searchbox below the input is populated with potential values that fit.
  *
  * @param v data received from XHR in JSON format
  * @param extractor a lambda used in a map across JSON elements to extract a string per item
  * @param the id to a particular text input on the page
  */
function betterUserExperienceForInput(v, extractor, input_id) {
  let receivedData = extractData(v, extractor);
  if (receivedData == null) {
    lockInput(input_id);
  } else if (receivedData && receivedData.length > 0 && receivedData.length < 10) {
    addDropdown(input_id, function() {return receivedData});
  } else {
    addAutoComplete(input_id, function() {return receivedData});
  }
}



function integration_tests() {
console.log("WARNING: integration tests running - these affect state");

// clean the database to begin
talk("GET", "flyway")
.then(function(v){
  return talk("POST", "registerborrower", "borrower=alice");
})
.then(function(v){
  return talk("GET", "borrower");  
})
.then(function(v){
  console.assert(v === '[{"Name": "alice", "Id": "1"}]', 'result was ' + v);  
  return JSON.parse(v).map(borrower => borrower.Name);
})
.then(function(v) {
    console.assert(v[0] === "alice", "result was " + v[0])
    return v;
})
.then(function(v) {
    talk("GET", "flyway");
});
}
// uncomment the function below to run integration tests
// integration_tests();

function unit_tests() {
// testing the createItemForList basics
let item = createItemForList("abc");
console.assert(item.getAttribute("data") === "abc", "data attribute was " + item.getAttribute("data") );
console.assert(item.innerText === "abc", "the inner text was " + item.innerText )

// testing createList
let list = createList("abc")
console.assert(list.id === "abc_searchlist", "list id was " + list.id);

// testing createSearchBox
let searchbox = createSearchBox("abc");
console.assert(searchbox.id === "abc_searchbox")

// testing addFilteredData
let mydata = ['a','b','c'];
let currentContent = 'a';
let filteredDataList = addFilteredData(list, mydata, currentContent, "abc");

}
// uncomment the function below to run unit tests
// unit_tests();


   


================================================
FILE: src/main/webapp/main.css
================================================

  * {
    font-family: sans-serif;
  }

  form {
    margin: 0;
    padding: 0;
  }

  div.buttons, form.regular-form {
    border: 2px black solid;
    width: 165px;
    height: 175px;
    margin: 2px;
    padding: 5px;
    float: left;
    background: #c9d0ce;
   }

   div.searchbox > ul {
    margin: 0;
    padding: 0;
    list-style: none;
   }

   div.searchbox {
    width: 162px;
    height: auto;
    position: absolute;
    background: white;
    border: solid 1px;

   }

   li:hover {
    background: black;
    color: white;
   }

  label {
     font-size: 0.8em;
  }

  p {
    margin: 0px;
    padding: 0px;
  }

  h2 {
    font-size: 1.0em;
    margin: 0;
    padding: 0;
  }

   input[type="text"],
   input[type="number"],
   input[type="password"],
   select {
    background: white;
    width: 100%;
   }

   input[type=submit] {
     font-size: 1.0em;
     margin-top: 15px;
     width: 100%;
   }

    @media all and (max-width: 500px) {

      div.buttons, form.regular-form {
        border: 5px black solid;
        width: 87%;
        height: auto;
        margin: auto;
        float: none;
        background: #c9d0ce;
       }

       input {
        padding: 10px;
       }

        /* the following is necessary on iphone to stop
        the browser from zooming in on a text element when
        it gains focus */
       input[type="color"],
       input[type="date"],
       input[type="datetime"],
       input[type="datetime-local"],
       input[type="email"],
       input[type="month"],
       input[type="number"],
       input[type="password"],
       input[type="search"],
       input[type="tel"],
       input[type="text"],
       input[type="time"],
       input[type="url"],
       input[type="week"],
       select:focus,
       textarea {
         font-size: 16px;
       }

    }


================================================
FILE: src/main/webapp/restfulresult.jsp
================================================
${result}


================================================
FILE: src/main/webapp/result.jsp
================================================
<%@ page contentType="text/html;charset=UTF-8" language="java" session="false" %>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Result Page</title>
    </head>
    <body>
        <h2>Result</h2>
        <p><pre id="result">${result}</pre></p>
    </body>
    <p>
    <a href="${return_page}">Return</a>
    </p>
</html>



================================================
FILE: src/main/webapp/WEB-INF/web.xml
================================================
<web-app
        xmlns="http://java.sun.com/xml/ns/j2ee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
        version="2.4">

    <description>Demo App for Training</description>

    <jsp-config>
        <jsp-property-group>
            <url-pattern>*.jsp</url-pattern>
            <page-encoding>UTF-8</page-encoding>
        </jsp-property-group>
    </jsp-config>

    <servlet>
        <servlet-name>H2Console</servlet-name>
        <servlet-class>org.h2.server.web.WebServlet</servlet-class>
        <init-param>
            <param-name>webAllowOthers</param-name>
            <param-value>true</param-value>
        </init-param>
        <!--
        <init-param>
            <param-name>trace</param-name>
            <param-value></param-value>
        </init-param>
        -->
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>H2Console</servlet-name>
        <url-pattern>/console/*</url-pattern>
    </servlet-mapping>

    <session-config>
        <!-- Disables URL-based sessions (no more 'jsessionid' in the URL using Tomcat) -->
        <tracking-mode>COOKIE</tracking-mode>
    </session-config>

</web-app>


================================================
FILE: src/selenified_tests/java/com/coveros/training/selenified/SelenifiedSample.java
================================================
package com.coveros.training.selenified;

import com.coveros.selenified.Locator;
import com.coveros.selenified.Selenified;
import com.coveros.selenified.application.App;
import com.coveros.selenified.element.Element;
import org.junit.Assert;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.testng.ITestContext;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

public class SelenifiedSample extends Selenified {

    static final String BASE_URL =  "http://localhost:8080/demo/";
    static final String LIBRARY_URL = BASE_URL + "library.html";
    static final String RESET_DATABASE_URL = BASE_URL + "flyway";

    @BeforeClass(alwaysRun = true)
    public void beforeClass(ITestContext test) {
        // set the base URL for the tests here
        setAppURL(this, test, LIBRARY_URL);
    }

    @Test(groups = {"sample"}, description = "Check that the title on the page is as expected")
    public void sampleTest() {
        // use this object to manipulate the app
        App app = this.apps.get();
        // verify the correct page title
        app.azzert().titleEquals("Library");
        // verify no issues
        finish();
    }

    @Test(groups = {"sample"}, description = "Make sure we can successfully register a user")
    public void sampleTest2() {
        String username = "fakeuser";
        String password = "asdfpoiasefaslfaje";

        // use this object to manipulate the app
        App app = this.apps.get();

        app.goToURL(RESET_DATABASE_URL);
        app.goToURL(LIBRARY_URL);

        // find the register user field and enter a username to register
        Element register_username = app.newElement(Locator.ID, "register_username");
        register_username.type(username);

        // find the register password field and enter a password
        Element register_password = app.newElement(Locator.ID, "register_password");
        register_password.type(password);

        // click to register the user
        Element register_submit = app.newElement(Locator.ID, "register_submit");
        register_submit.click();

        // assert we find the proper response in the result
        app.azzert().textPresent("successfully registered: true");

        // verify no issues
        finish();
    }

    /**
     *  This is a test to do whatever blah blah blah
     *
     */
    @Test
    public void sampleTest3() {
        // arrange
        App app = this.apps.get();

        final WebDriver driver = app.getDriver();
        String username = "someuser";
        String password = "passworsdosjfasldf";

        app.goToURL(LIBRARY_URL);

        final WebElement login_username = driver.findElement(By.id("login_username"));
        login_username.sendKeys(username);

        final WebElement login_password = driver.findElement(By.id("login_password"));
        login_password.sendKeys(password);

        // act
        final WebElement login_submit = driver.findElement(By.id("login_submit"));
        login_submit.click();

        // assert
        final WebElement result = driver.findElement(By.id("result"));
        Assert.assertEquals("access denied", result.getText());
    }

    /**
     * Testing out logging in with invalid credentials
     *
     * This uses basic Selenium, not Selenified.
     */
    @Test
    public void sampleTest4() {
        App app = this.apps.get();
        final WebDriver driver = app.getDriver();
        String username = "someuser";
        String password = "passworsdosjfasldf";

        app.goToURL(LIBRARY_URL);

        final WebElement register_username = driver.findElement(By.id("register_username"));
        register_username.sendKeys(username);

        final WebElement register_password = driver.findElement(By.id("register_password"));
        register_password.sendKeys(password);

        final WebElement register_submit = driver.findElement(By.id("register_submit"));
        register_submit.click();

        driver.get(LIBRARY_URL);

        final WebElement login_username = driver.findElement(By.id("login_username"));
        login_username.sendKeys(username);

        final WebElement login_password = driver.findElement(By.id("login_password"));
        login_password.sendKeys(password);

        final WebElement login_submit = driver.findElement(By.id("login_submit"));
        login_submit.click();

        final WebElement result = driver.findElement(By.id("result"));
        Assert.assertEquals("access granted", result.getText());

        finish();
    }

}







  


================================================
FILE: src/selenified_tests/resources/selenified.properties
================================================
# connection
#hub=http://localhost:4444
hub=
proxy=
appURL=
# browser
browser=Chrome
headless=false
options=
# logging
defaultWait=5
defaultPoll=50
generatePDF=false
packageResults=false


================================================
FILE: src/test/java/com/coveros/training/authentication/LoginServletTests.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.helpers.ServletUtils;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import static org.mockito.Mockito.*;

/**
 * These tests cover the testing of the endpoint itself, not so much
 * anything it calls.  That's why we mock out everything outside
 * this class.  It makes our tests run very quickly, and enables us to
 * focus with laser-like precision on the functionality this class
 * provides.  Other tests will provide integration testing - but not
 * this one.
 */
public class LoginServletTests {
    public static final String DEFAULT_USERNAME = "alice";
    public static final String DEFAULT_PASSWORD = "abc123";
    private HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
    private HttpServletResponse response = Mockito.mock(HttpServletResponse.class);
    private RequestDispatcher requestDispatcher = Mockito.mock(RequestDispatcher.class);
    private LoginServlet loginServlet = spy(new LoginServlet());

    /**
     * We'll be mocking requests and responses and so on throughout these
     * tests, so just initialize them here for later use.  Notice
     * that we use spy for the LoginServlet.  This specifically allows us to mock
     * out its loginUtils class, but otherwise, all LoginServlet calls
     * are to the real code.  Why mock LoginUtils? So that we can prevent
     * real calls into that class - it's assumed we have already tested
     * that class on its own, we just want to test code specific to this class.
     *
     * LoginServlet uses a static method, {@link ServletUtils#forwardToResult}
     * that has a call to {@link HttpServletRequest#getRequestDispatcher} that
     * we need to mock out.
     */
    @Before
    public void before() {
        request = mock(HttpServletRequest.class);
        response = mock(HttpServletResponse.class);
        requestDispatcher = mock(RequestDispatcher.class);
        loginServlet = spy(new LoginServlet());
        LoginServlet.loginUtils = Mockito.mock(LoginUtils.class);

        // this is always called in a static method, it's boilerplate for these tests.
        when(request.getRequestDispatcher(ServletUtils.RESULT_JSP)).thenReturn(requestDispatcher);
    }

    /**
     * The basic happy path - a username and password are entered
     */
    @Test
    public void testHappyPathPost() {
        // not the greatest password in the world, but we're not testing that
        // at this level - rather, just that the endpoint got a password at all
        setMock_UsernameAndPassword(DEFAULT_USERNAME, DEFAULT_PASSWORD);
        setMock_LoginUtilsUserRegistered(DEFAULT_USERNAME, DEFAULT_PASSWORD, true);

        loginServlet.doPost(request, response);

        verifyExpectedResult("access granted");
    }

    /**
     * If a particular username and password are not registered, login will fail.  access denied.
     */
    @Test
    public void testShouldGetAccessDeniedIfUserNotRegistered() {
        setMock_UsernameAndPassword(DEFAULT_USERNAME, DEFAULT_PASSWORD);
        setMock_LoginUtilsUserRegistered(DEFAULT_USERNAME, DEFAULT_PASSWORD, false);

        loginServlet.doPost(request, response);

        verifyExpectedResult("access denied");
    }

    /**
     * If they pass in an empty string for username, it should return a message
     * indicating that.
     */
    @Test
    public void testEmptyString_Username() {
        // Empty string for the username.
        setMock_UsernameAndPassword("", DEFAULT_PASSWORD);

        loginServlet.doPost(request, response);

        verifyExpectedResult("no username provided");
    }

    /**
     * If they pass in an empty string for password, it should return a message
     * indicating that.
     */
    @Test
    public void testEmptyString_Password() {
        // Empty string for the password.
        setMock_UsernameAndPassword(DEFAULT_USERNAME, "");

        loginServlet.doPost(request, response);

        verifyExpectedResult("no password provided");
    }

    /**
     * Mock out the username and password values on the request, the
     * user's input to this endpoint
     */
    private void setMock_UsernameAndPassword(String username, String password) {
        when(request.getParameter("username")).thenReturn(username);
        when(request.getParameter("password")).thenReturn(password);
    }


    /**
     * Mock out the call and response for LoginUtils, so we can
     * better control how our endpoint will behave in different situations
     * @param username check this if already registered
     * @param password check this if already registered
     * @param expectedReturn what we want the call to return for the purposes of our test
     */
    private void setMock_LoginUtilsUserRegistered(String username, String password, boolean expectedReturn) {
        when(LoginServlet.loginUtils.isUserRegistered(username, password)).thenReturn(expectedReturn);
    }


    /**
     * A wrapper around the mock just to better document intention
     * @param expectedResult what we expect as the bottom-line result,
     *                       which will end up sent to the user as a message
     */
    private void verifyExpectedResult(String expectedResult) {
        Mockito.verify(request).setAttribute("result", expectedResult);
    }
}



================================================
FILE: src/test/java/com/coveros/training/authentication/LoginUtilsTests.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.persistence.IPersistenceLayer;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import static org.mockito.internal.verification.VerificationModeFactory.times;

public class LoginUtilsTests {

    private IPersistenceLayer mockPersistenceLayer = Mockito.mock(IPersistenceLayer.class);
    private LoginUtils loginUtils = Mockito.spy(new LoginUtils(mockPersistenceLayer));


    @Before
    public void init() {
        mockPersistenceLayer = Mockito.mock(IPersistenceLayer.class);
        loginUtils = Mockito.spy(new LoginUtils(mockPersistenceLayer));
    }

    @Test
    public void testCanCreateEmpty() {
        final LoginUtils loginUtils = LoginUtils.createEmpty();
        Assert.assertTrue(loginUtils.isEmpty());
    }

    @Test
    public void testCanSeeIfUserRegistered() {
        loginUtils.isUserRegistered("alice", "abc123");
        Mockito.verify(mockPersistenceLayer, times(1)).areCredentialsValid("alice", "abc123");
    }

}



================================================
FILE: src/test/java/com/coveros/training/authentication/RegisterServletTests.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.authentication.domainobjects.RegistrationResult;
import com.coveros.training.authentication.domainobjects.RegistrationStatusEnums;
import com.coveros.training.helpers.ServletUtils;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import static org.mockito.Mockito.*;

public class RegisterServletTests {

    private static final String ALICE = "alice";
    private static final RegistrationResult EMPTY_USERNAME = new RegistrationResult(false, RegistrationStatusEnums.EMPTY_USERNAME);
    private static final RegistrationResult SUCCESSFUL_REGISTRATION = new RegistrationResult(true, RegistrationStatusEnums.SUCCESSFULLY_REGISTERED);
    private HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
    private HttpServletResponse response = Mockito.mock(HttpServletResponse.class);
    private RequestDispatcher requestDispatcher = Mockito.mock(RequestDispatcher.class);
    private RegisterServlet registerServlet = spy(new RegisterServlet());

    @Before
    public void before() {
        request = mock(HttpServletRequest.class);
        response = mock(HttpServletResponse.class);
        requestDispatcher = mock(RequestDispatcher.class);
        registerServlet = spy(new RegisterServlet());
        RegisterServlet.registrationUtils = Mockito.mock(RegistrationUtils.class);
    }

    /**
     * Makes sure that the request dispatcher sends the user to the right place.
     * <p>
     * If the user enters no name when registering, they should be
     * sent to the error page "empty_username.html"
     */
    @Test
    public void doPostWithoutName() {
        // given a user entered an empty string for username
        mockRequestParam("username", "");
        mockRequestParam("password", "");
        mockRegisterUserToReturnSomeResponse(EMPTY_USERNAME);
        mockRequestDispatcherForExpectedRedirection(ServletUtils.RESULT_JSP);

        // do the post
        registerServlet.doPost(request, response);

        // verify that the correct redirect was chosen.
        verify(request).getRequestDispatcher(ServletUtils.RESULT_JSP);
    }

    /**
     * Makes sure that the request dispatcher sends the user to the right place.
     * <p>
     * If the user enters their name when registering, they should be
     * sent to the successful registration page.
     */
    @Test
    public void doPostWithName() {
        // given a user entered their username
        mockRequestParam("username", "Alice");
        mockRequestParam("password", "password123");
        mockRegisterUserToReturnSomeResponse(SUCCESSFUL_REGISTRATION);
        mockRequestDispatcherForExpectedRedirection(ServletUtils.RESULT_JSP);

        // do the post
        registerServlet.doPost(request, response);

        // verify that the correct redirect was chosen.
        verify(request).getRequestDispatcher(ServletUtils.RESULT_JSP);
    }

    /**
     * If they pass in an empty string, it should return a message
     * indicating that.
     */
    @Test
    public void testEmptyString_Username() {
        when(request.getRequestDispatcher(ServletUtils.RESULT_JSP)).thenReturn(requestDispatcher);
        String emptyString = "";
        when(request.getParameter("username")).thenReturn(emptyString);
        when(request.getParameter("password")).thenReturn("abc123");

        // do the post
        registerServlet.doPost(request, response);

        // verify that the missing book title was handled
        Mockito.verify(request).setAttribute("result", "no username provided");
    }

    /**
     * If they pass in an empty string, it should return a message
     * indicating that.
     */
    @Test
    public void testEmptyString_Password() {
        when(request.getRequestDispatcher(ServletUtils.RESULT_JSP)).thenReturn(requestDispatcher);
        String emptyString = "";
        when(request.getParameter("password")).thenReturn(emptyString);
        when(request.getParameter("username")).thenReturn(ALICE);

        // do the post
        registerServlet.doPost(request, response);

        // verify that the missing book title was handled
        Mockito.verify(request).setAttribute("result", "no password provided");
    }


    private void mockRegisterUserToReturnSomeResponse(RegistrationResult expectedResult) {
        when(RegisterServlet.registrationUtils.processRegistration(Mockito.anyString(), Mockito.anyString())).thenReturn(expectedResult);
    }

    private void mockRequestDispatcherForExpectedRedirection(String expectedPath) {
        when(request.getRequestDispatcher(expectedPath)).thenReturn(requestDispatcher);
    }

    private void mockRequestParam(String paramName, String name) {
        when(request.getParameter(paramName)).thenReturn(name);
    }


}



================================================
FILE: src/test/java/com/coveros/training/authentication/RegistrationUtilsTests.java
================================================
package com.coveros.training.authentication;

import com.coveros.training.authentication.domainobjects.*;
import com.coveros.training.persistence.IPersistenceLayer;
import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class RegistrationUtilsTests {

    private static final String GOOD_PASSWORD = "LpcVWwRkWSNVH";
    private static final String ALICE = "alice";
    private static final String BAD_PASSWORD = "abc123horsestaples";
    private final IPersistenceLayer persistenceLayer = mock(IPersistenceLayer.class);
    private final RegistrationUtils registrationUtils = new RegistrationUtils(persistenceLayer);

    /**
     * a really short password can be found by brute force extremely quickly,
     * making this highly insecure
     */
    @Test
    public void testShouldFailOnShortPassword() {
        final PasswordResult result = RegistrationUtils.isPasswordGood("abc");
        Assert.assertEquals(PasswordResultEnums.TOO_SHORT, result.status);
    }

    @Test
    public void testShouldFailOnEmptyPassword_EmptyString() {
        final PasswordResult result = RegistrationUtils.isPasswordGood("");
        Assert.assertEquals(PasswordResultEnums.EMPTY_PASSWORD, result.status);
    }

    /**
     * A lightweight performance test for a slow call
     */
    @Ignore
    @Test
    public void testShouldPerformWell() {
        long start = System.currentTimeMillis();
        final List<String> goodPasswords =
                Arrays.asList(
                        "XaZE}SkOC/@k#blv}U+wOlDfj=a]q",
                        "-MzlAim%Zuh.=B|8N|Vd~`l5?*Cs,ZH\\'l/76t-9]W\\D$Il#vynO+~y_@",
                        "lm=U(#C;@Bl*jvEy_*U1QlR@3sje");
        for (String password : goodPasswords) {
            RegistrationUtils.isPasswordGood(password);
        }
        long finish = System.currentTimeMillis();
        long timeElapsed = finish - start;

        Assert.assertTrue("All these calls should have finished in a short time.  " +
                "Time elapsed was " + timeElapsed, timeElapsed < 1500);
    }

    /**
     * If we provide a good password, then by golly we should get that
     * as a result from our {@link RegistrationUtils#isPasswordGood} method.
     */
    @Test
    public void testShouldHaveSufficientEntropyInPassword() {
        final PasswordResult result = RegistrationUtils.isPasswordGood(GOOD_PASSWORD);
        Assert.assertEquals(PasswordResultEnums.SUCCESS, result.status);
    }

    /**
     * Not really a lot to test here...
     */
    @Test
    public void testShouldDetermineIfUserInDatabase() {
        // mock that a user is found when we search for them
        when(persistenceLayer.searchForUserByName(ALICE)).thenReturn(Optional.of(new User(ALICE, 1)));

        final boolean result = registrationUtils.isUserInDatabase(ALICE);

        Assert.assertTrue(result);
    }

    /**
     * Testing registration without hitting the actual database.
     * The password has to be sufficient to meet the entropy stipulations.
     * We need to mock the calls that will have been sent to the database.
     */
    @Test
    public void testShouldProcessRegistration_HappyPath() {
        // this needs to not find a user
        when(persistenceLayer.searchForUserByName(ALICE)).thenReturn(Optional.empty());
        RegistrationResult expectedResult = new RegistrationResult(true, RegistrationStatusEnums.SUCCESSFULLY_REGISTERED);

        final RegistrationResult registrationResult =
                registrationUtils.processRegistration(ALICE, GOOD_PASSWORD);

        Assert.assertEquals(expectedResult, registrationResult);
    }

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    /**
     * If we pass in an empty username, we should get a response that
     * registration failed.
     */
    @Test
    public void testShouldProcessRegistration_EmptyUsername() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("string must not be null or empty at this point");
        registrationUtils.processRegistration("", GOOD_PASSWORD);
    }

    /**
     * Registration should fail if the password isn't good enough.
     */
    @Test
    public void testShouldProcessRegistration_BadPassword() {
        // this needs to not find a user
        when(persistenceLayer.searchForUserByName(ALICE)).thenReturn(Optional.empty());
        final PasswordResult result = RegistrationUtils.isPasswordGood(BAD_PASSWORD);
        RegistrationResult expectedResult = new RegistrationResult(false, RegistrationStatusEnums.BAD_PASSWORD, result.toPrettyString());

        final RegistrationResult registrationResult =
                registrationUtils.processRegistration(ALICE, BAD_PASSWORD);

        Assert.assertEquals(expectedResult, registrationResult);
    }

    /**
     * Registration should fail if we're trying to register an already-existing user.
     */
    @Test
    public void testShouldProcessRegistration_ExistingUser() {
        // this needs to find an existing user - so they are already registered
        when(persistenceLayer.searchForUserByName(ALICE)).thenReturn(Optional.of(new User(ALICE, 1)));
        RegistrationResult expectedResult = new RegistrationResult(false, RegistrationStatusEnums.ALREADY_REGISTERED);

        final RegistrationResult registrationResult =
                registrationUtils.processRegistration(ALICE, GOOD_PASSWORD);

        Assert.assertEquals(expectedResult, registrationResult);
    }

    @Test
    public void testEmptyObject() {
        final RegistrationUtils registrationUtils = RegistrationUtils.createEmpty();
        Assert.assertTrue(registrationUtils.isEmpty());
    }

}



================================================
FILE: src/test/java/com/coveros/training/authentication/domainobjects/PasswordResultTests.java
================================================
package com.coveros.training.authentication.domainobjects;

import nl.jqno.equalsverifier.EqualsVerifier;
import org.junit.Assert;
import org.junit.Test;

public class PasswordResultTests {

    @Test
    public void testShouldHaveEqualsAndHashcodeImplementedCorrectly() {
        EqualsVerifier.forClass(PasswordResult.class).verify();
    }

    @Test
    public void testShouldOutputGoodString() {
        final PasswordResult passwordResult = createTestPasswordResult();
        final String result = passwordResult.toString();
        Assert.assertTrue("was " + passwordResult,
                result.contains("status=SUCCESS") &&
                result.contains("entropy=0.0") &&
                result.contains("timeToCrackOffline=") &&
                result.contains("timeToCrackOnline=") &&
                result.contains("message=BASIC_PASSWORD_CHECKS_FAILED"));
    }

    private static PasswordResult createTestPasswordResult() {
        return PasswordResult.createDefault(PasswordResultEnums.SUCCESS);
    }

    @Test
    public void testCanCreateEmpty() {
        final PasswordResult passwordResult = PasswordResult.createEmpty();
        Assert.assertTrue(passwordResult.isEmpty());
    }
}



================================================
FILE: src/test/java/com/coveros/training/authentication/domainobjects/RegistrationResultTests.java
================================================
package com.coveros.training.authentication.domainobjects;

import nl.jqno.equalsverifier.EqualsVerifier;
import org.junit.Assert;
import org.junit.Test;


public class RegistrationResultTests {

    @Test
    public void testShouldHaveEqualsAndHashcodeImplementedCorrectly() {
        EqualsVerifier.forClass(RegistrationResult.class).verify();
    }

    @Test
    public void testShouldOutputGoodString() {
        final RegistrationResult registrationResult = RegistrationResult.createEmpty();
        final String result = registrationResult.toString();
        Assert.assertTrue("was " + registrationResult,
                result.contains("wasSuccessfullyRegistered=false") &&
                        result.contains("status=EMPTY") &&
                        result.contains("message="));
    }

    @Test
    public void testCanCreateEmpty() {
        final RegistrationResult registrationResult = RegistrationResult.createEmpty();
        Assert.assertTrue(registrationResult.isEmpty());
    }

}



================================================
FILE: src/test/java/com/coveros/training/authentication/domainobjects/UserTests.java
================================================
package com.coveros.training.authentication.domainobjects;

import nl.jqno.equalsverifier.EqualsVerifier;
import org.junit.Assert;
import org.junit.Test;

public class UserTests {

    @Test
    public void testShouldHaveEqualsAndHashcodeImplementedCorrectly() {
        EqualsVerifier.forClass(User.class).verify();
    }

    @Test
    public void testShouldOutputGoodString() {
        final User user = createTestUser();
        final String s = user.toString();
        Assert.assertTrue("toString was: " + user.toString(),
                s.contains("name=alice") &&
                s.contains("id=1"));
    }

    @Test
    public void testCanCreateEmpty() {
        final User user = User.createEmpty();
        Assert.assertTrue(user.isEmpty());
    }

    private static User createTestUser() {
        return new User("alice", 1);
    }

}



================================================
FILE: src/test/java/com/coveros/training/helpers/CheckUtilsTests.java
================================================
package com.coveros.training.helpers;

import org.junit.Test;

public class CheckUtilsTests {

    @Test(expected = IllegalArgumentException.class)
    public void testShouldThrowErrorFor0() {
        CheckUtils.IntParameterMustBePositive(0);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testShouldThrowErrorForSubZero() {
        CheckUtils.IntParameterMustBePositive(-1);
    }

    @Test
    public void testShouldSucceedForPositiveValue() {
        CheckUtils.IntParameterMustBePositive(1);
    }

}



================================================
FILE: src/test/java/com/coveros/training/helpers/DateUtils.java
================================================
package com.coveros.training.helpers;

import java.util.Date;

public class DateUtils {

    /**
     * @return true if the current time from {@link Date#getTime} is even.
     */
    public static boolean isTimeEven() {
        final Date date = new Date();
        return date.getTime() % 2 == 0;
    }

}



================================================
FILE: src/test/java/com/coveros/training/helpers/DateUtilsTests.java
================================================
package com.coveros.training.helpers;

import com.coveros.training.helpers.DateUtils;
import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;

import java.time.LocalDate;
import java.time.Month;
import java.time.temporal.ChronoUnit;

public class DateUtilsTests {

    /**
     * This contrived example is here to provide an opportunity to
     * improve a flaky test.  Our tests should always return the same
     * result, we want total control over our laboratory.
     */
    @Ignore("used for teaching purposes")
    @Test
    public void testShouldReturnEvenTime() {
        Assert.assertTrue(DateUtils.isTimeEven());
    }

    /**
     * In Virginia, the law states you must be at least 16 years and 3 months
     * old to get a drivers license.
     *
     * In this test we'll presume a straightforward happy path.  A person
     * is born Jan 1, 1990.  When do they get their driver's license?
     *
     * 1990 + 16 years = 2006
     * Jan + 3 months = April
     * So, April 1, 2006.
     * How many days is that from the day they were born?
     */
    @Ignore("used for teaching purposes")
    @Test
    public void testShouldBe16Years3Months_HappyPath() {
        // arrange
        // assume a person is born Jan 1, 1990
        final LocalDate birthDate = LocalDate.of(1990, Month.JANUARY, 1);
        // expected that they can get it on April 1, 2006
        final LocalDate expectedLicenseDate = LocalDate.of(2006, Month.APRIL, 1);

        // act
        // add 16 years and 3 months
        final LocalDate licenseDate = calculateFirstPossibleLicenseDate(birthDate);

        // assert
        Assert.assertEquals(expectedLicenseDate, licenseDate);
        long noOfDaysBetween = ChronoUnit.DAYS.between(licenseDate, birthDate);

        // there were 5934 days from the day they were born to the day they can
        // get their license.  It seems fair that that number is the same for
        // everyone, right?  Why should being born on a different day of the
        // year make a difference in how long you have to wait to get your license?
        Assert.assertTrue(Math.abs(noOfDaysBetween) == 5934);

        // let's run an experiment.  We'll start with someone born in Jan 1, 1990,
        // and use the same method to calculate their first possible day to get
        // a driver's license.  We will then loop through every day for 100 years
        // to make sure the answer is always the same.

        for (LocalDate scanningBirthDate = birthDate;
             scanningBirthDate.isBefore(birthDate.plusYears(100));
             scanningBirthDate = scanningBirthDate.plusDays(1)) {
            LocalDate scanningLicenseDate = calculateFirstPossibleLicenseDate(scanningBirthDate);
            // assert
            long daysBetween = ChronoUnit.DAYS.between(scanningLicenseDate, scanningBirthDate);
            String errorMessage = "days between was " + Math.abs(daysBetween) + " for a birthdate of " + scanningBirthDate
                    + " and a license date of " + scanningLicenseDate;
            Assert.assertTrue(errorMessage, Math.abs(daysBetween) == 5934);
        }
    }

    /**
     * Determine the first date which this person is able to obtain a driver's
     * license, per Virginia's law that they be 16 years and 3 months.
     *<p>
     * calculates using this method: <p><code>birthDate.plusYears(16).plusMonths(3);</code></p>
     * </p>
     */
    private LocalDate calculateFirstPossibleLicenseDate(LocalDate birthDate) {
        return birthDate.plusYears(16).plusMonths(3);
    }

}



================================================
FILE: src/test/java/com/coveros/training/helpers/StringUtilsTests.java
================================================
package com.coveros.training.helpers;

import org.junit.Test;

import static com.coveros.training.helpers.StringUtils.*;
import static org.junit.Assert.assertEquals;

public class StringUtilsTests {

    @Test
    public void testShouldConvertNullToEmptyString() {
        final String s = StringUtils.makeNotNullable(null);
        assertEquals("", s);
    }

    @Test
    public void testShouldNotAlterNonNullString() {
        final String s = StringUtils.makeNotNullable("abc");
        assertEquals("abc", s);
    }

    /**
     * JSON won't parse if it has a double quote in a string
     */
    @Test
    public void testEscapeForJson_ShouldEscapeDoubleQuote() {
        final String expectedResult = new String(new byte[]{BACKSLASH, DOUBLE_QUOTE});
        final String inputString = new String(new byte[]{DOUBLE_QUOTE});
        String result = StringUtils.escapeForJson(inputString);
        assertEquals(expectedResult, result);
    }

    /**
     * Testing another potential problem with a JSON string
     */
    @Test
    public void testEscapeForJson_ShouldEscapeBackslash() {
        final String expectedResult = new String(new byte[]{BACKSLASH, BACKSLASH});
        final String inputString = new String(new byte[]{BACKSLASH});
        String result = StringUtils.escapeForJson(inputString);
        assertEquals(expectedResult, result);
    }

}



================================================
FILE: src/test/java/com/coveros/training/library/LendingTests.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.library.domainobjects.Loan;
import org.junit.Assert;
import org.junit.Test;
import org.mockito.Mockito;

import java.sql.Date;
import java.time.LocalDate;
import java.time.Month;

import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doReturn;

public class LendingTests {


    private final static Date BORROW_DATE = Date.valueOf(LocalDate.of(2018, Month.JANUARY, 1));
    private final static String BORROWER_A_NAME = "borrower_a";
    private final static String BORROWER_B_NAME = "borrower_b";
    private final static String TITLE = "Some book";
    private final static Book SAMPLE_BOOK = new Book(1, TITLE);
    private final static Borrower SAMPLE_BORROWER_A = new Borrower(1, BORROWER_A_NAME);
    private final static Borrower SAMPLE_BORROWER_B = new Borrower(1, BORROWER_B_NAME);
    private final LibraryUtils libraryUtils = Mockito.spy(LibraryUtils.class);

    /**
     * If a borrower and a book are registered, a user should be able to borrow it.
     */
    @Test
    public void shouldLendToUser() {
        mockSearchForLoan();
        mockThatLoanIsCreated(SAMPLE_BOOK, SAMPLE_BORROWER_A, BORROW_DATE);
        final LibraryActionResults libraryActionResults = libraryUtils.lendBook(SAMPLE_BOOK, SAMPLE_BORROWER_A, BORROW_DATE);
        Assert.assertEquals(LibraryActionResults.SUCCESS, libraryActionResults);
    }

    private void mockThatLoanIsCreated(Book book, Borrower borrower, Date borrowDate) {
        Mockito.doNothing().when(libraryUtils).createLoan(book, borrower, borrowDate);
    }

    private void mockSearchForLoan() {
        Mockito.doReturn(Loan.createEmpty()).when(libraryUtils).searchForLoanByBook(SAMPLE_BOOK);
    }

    /**
     * Just make sure that we get the expected response if we register a borrower
     */
    @Test
    public void shouldRegisterBorrower() {
        mockBorrowerNotRegistered(BORROWER_A_NAME);
        mockThatNewBorrowerGetsSaved(BORROWER_A_NAME);
        final LibraryActionResults result = libraryUtils.registerBorrower(BORROWER_A_NAME);
        Assert.assertEquals(LibraryActionResults.SUCCESS, result);
    }

    private void mockThatNewBorrowerGetsSaved(String borrowerAName) {
        doNothing().when(libraryUtils).saveNewBorrower(borrowerAName);
    }

    private void mockBorrowerNotRegistered(String borrower) {
        doReturn(Borrower.createEmpty()).when(libraryUtils).searchForBorrowerByName(borrower);
    }

    /**
     * Just make sure that we get the expected response if we register a book
     */
    @Test
    public void shouldRegisterBook() {
        mockThatBookNotRegistered(TITLE);
        mockThatNewBookGetsSaved(TITLE);
        final LibraryActionResults result = libraryUtils.registerBook(TITLE);
        Assert.assertEquals(LibraryActionResults.SUCCESS, result);
    }

    private void mockThatNewBookGetsSaved(String title) {
        doNothing().when(libraryUtils).saveNewBook(title);
    }

    private void mockThatBookNotRegistered(String title) {
        doReturn(Book.createEmpty()).when(libraryUtils).searchForBookByTitle(title);
    }

    /**
     * We shouldn't be able to lend if we try to lend
     * to a borrower who isn't registered
     */
    @Test
    public void testShouldNotLendIfBorrowerNotRegistered() {
        final LibraryActionResults result = libraryUtils.lendBook(SAMPLE_BOOK, Borrower.createEmpty(), BORROW_DATE);
        Assert.assertEquals(LibraryActionResults.BORROWER_NOT_REGISTERED, result);
    }

    /**
     * We shouldn't be able to lend if we try to lend
     * out a book that isn't registered
     */
    @Test
    public void testShouldNotLendIfBookNotRegistered() {
        final LibraryActionResults result = libraryUtils.lendBook(Book.createEmpty(), SAMPLE_BORROWER_A, BORROW_DATE);
        Assert.assertEquals(LibraryActionResults.BOOK_NOT_REGISTERED, result);
    }

    /**
     * b wants to check out a book, but a has it.  Can they borrow it? (no)
     */
    @Test
    public void shouldNotLendIfCurrentlyBorrowed() {
        mockSearchForLoan();
        Mockito.when(libraryUtils.searchForLoanByBook(SAMPLE_BOOK)).thenReturn(new Loan(SAMPLE_BOOK, SAMPLE_BORROWER_B, 1, BORROW_DATE));
        final LibraryActionResults libraryActionResults_bob = libraryUtils.lendBook(SAMPLE_BOOK, SAMPLE_BORROWER_B, BORROW_DATE);
        Assert.assertEquals(LibraryActionResults.BOOK_CHECKED_OUT, libraryActionResults_bob);
    }

}



================================================
FILE: src/test/java/com/coveros/training/library/LibraryBookListAvailableServletTests.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.helpers.ServletUtils;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.util.Arrays;

import static com.coveros.training.library.LibraryBookListAvailableServlet.RESULT;
import static org.mockito.Mockito.*;

public class LibraryBookListAvailableServletTests {

    public static final String A_BOOK = "a book";
    public static final Book DEFAULT_BOOK = new Book(1, A_BOOK);
    private HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
    private HttpServletResponse response = Mockito.mock(HttpServletResponse.class);
    private LibraryBookListAvailableServlet libraryBookListAvailableServlet = spy(new LibraryBookListAvailableServlet());
    private final RequestDispatcher requestDispatcher = Mockito.mock(RequestDispatcher.class);
    private final LibraryUtils libraryUtils = Mockito.mock(LibraryUtils.class);


    @Before
    public void before() {
        request = mock(HttpServletRequest.class);
        response = mock(HttpServletResponse.class);
        libraryBookListAvailableServlet = spy(new LibraryBookListAvailableServlet());
        LibraryBookListAvailableServlet.libraryUtils = this.libraryUtils;
    }

    /**
     * If we don't pass a title or an id, we'll get a list of all books
     */
    @Test
    public void testListAvailableBooks_OneBook() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(libraryUtils.listAvailableBooks()).thenReturn(Arrays.asList(DEFAULT_BOOK));

        // act
        libraryBookListAvailableServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "[{\"Title\": \"a book\", \"Id\": \"1\"}]");
    }

    /**
     * If we don't pass a title or an id, we'll get a list of all books
     */
    @Test
    public void testListAvailableBooks_MultipleBook() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(libraryUtils.listAvailableBooks()).thenReturn(Arrays.asList(DEFAULT_BOOK, DEFAULT_BOOK, DEFAULT_BOOK));

        // act
        libraryBookListAvailableServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "[{\"Title\": \"a book\", \"Id\": \"1\"},{\"Title\": \"a book\", \"Id\": \"1\"},{\"Title\": \"a book\", \"Id\": \"1\"}]");
    }


    /**
     * If we don't pass a title or an id, we'll get a list of all books
     * This tests what happens if there's no books in the database
     */
    @Test
    public void testListAvailableBooks_EmptyList() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);

        // act
        libraryBookListAvailableServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "No books exist in the database");
    }

    /**
     * If there aren't any books
     */
    @Test
    public void testSearchNoBooks() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("id")).thenReturn("");
        when(request.getParameter("title")).thenReturn("");

        // act
        libraryBookListAvailableServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "No books exist in the database");
    }


}



================================================
FILE: src/test/java/com/coveros/training/library/LibraryBookListSearchServletTests.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Book;
import com.coveros.training.helpers.ServletUtils;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.util.Arrays;

import static com.coveros.training.library.LibraryBookListSearchServlet.RESULT;
import static org.mockito.Mockito.*;

public class LibraryBookListSearchServletTests {

    public static final String A_BOOK = "a book";
    public static final Book DEFAULT_BOOK = new Book(1, A_BOOK);
    private HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
    private HttpServletResponse response = Mockito.mock(HttpServletResponse.class);
    private LibraryBookListSearchServlet libraryBookListSearchServlet = spy(new LibraryBookListSearchServlet());
    private final RequestDispatcher requestDispatcher = Mockito.mock(RequestDispatcher.class);
    private final LibraryUtils libraryUtils = Mockito.mock(LibraryUtils.class);


    @Before
    public void before() {
        request = mock(HttpServletRequest.class);
        response = mock(HttpServletResponse.class);
        libraryBookListSearchServlet = spy(new LibraryBookListSearchServlet());
        LibraryBookListSearchServlet.libraryUtils = this.libraryUtils;
    }

    /**
     * If we don't pass a title or an id, we'll get a list of all books
     */
    @Test
    public void testListAllBooks() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(libraryUtils.listAllBooks()).thenReturn(Arrays.asList(DEFAULT_BOOK));
        // act
        libraryBookListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "[{\"Title\": \"a book\", \"Id\": \"1\"}]");
    }

    /**
     * If we don't pass a title or an id, we'll get a list of all books
     * this tests when the database is empty of books
     */
    @Test
    public void testListAllBooks_NoBooksInDatabase() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);

        // act
        libraryBookListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "No books exist in the database");
    }

    /**
     * If we pass an id, we'll get a particular book
     * testing for when there's no books found by that id
     */
    @Test
    public void testSearchById_noBookFound() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("id")).thenReturn("1");
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBookById(1)).thenReturn(Book.createEmpty());

        // act
        libraryBookListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "No books found with an id of 1");
    }

    /**
     * If we pass an id, we'll get a particular book
     */
    @Test
    public void testSearchById() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("id")).thenReturn("1");
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBookById(1)).thenReturn(DEFAULT_BOOK);

        // act
        libraryBookListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "[{\"Title\": \"a book\", \"Id\": \"1\"}]");
    }

    /**
     * If we pass a title, we'll get a particular book
     */
    @Test
    public void testSearchByTitle() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("title")).thenReturn(A_BOOK);
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBookByTitle(A_BOOK)).thenReturn(DEFAULT_BOOK);

        // act
        libraryBookListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(libraryUtils).searchForBookByTitle(A_BOOK);
        verify(request).setAttribute(RESULT, "[{\"Title\": \"a book\", \"Id\": \"1\"}]");
    }

    /**
     * If there aren't any books
     */
    @Test
    public void testSearchNoBooks() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("id")).thenReturn("");
        when(request.getParameter("title")).thenReturn("");

        // act
        libraryBookListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "No books exist in the database");
    }

    /**
     * If nothing found by id
     */
    @Test
    public void testSearchNothingFoundById() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("id")).thenReturn("1");
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBookById(1)).thenReturn(Book.createEmpty());

        // act
        libraryBookListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "No books found with an id of 1");
    }

    /**
     * If no books found by title
     */
    @Test
    public void testSearchNothingFoundByTitle() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("title")).thenReturn(A_BOOK);
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBookByTitle(A_BOOK)).thenReturn(Book.createEmpty());

        // act
        libraryBookListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(libraryUtils).searchForBookByTitle(A_BOOK);
        verify(request).setAttribute(RESULT, "No books found with a title of " + A_BOOK);
    }

    /**
     * If we provide an ID and a title
     */
    @Test
    public void testSearchIdAndTitle() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("title")).thenReturn(A_BOOK);
        when(request.getParameter("id")).thenReturn("1");

        // act
        libraryBookListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "Error: please search by either title or id, not both");
    }

}



================================================
FILE: src/test/java/com/coveros/training/library/LibraryBorrowerListSearchServletTests.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.Borrower;
import com.coveros.training.helpers.ServletUtils;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.util.Arrays;

import static com.coveros.training.library.LibraryBorrowerListSearchServlet.RESULT;
import static org.mockito.Mockito.*;

public class LibraryBorrowerListSearchServletTests {

    private static final String A_BORROWER = "abe borrower";
    private static final Borrower DEFAULT_BORROWER = new Borrower(1, A_BORROWER);
    private HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
    private HttpServletResponse response = Mockito.mock(HttpServletResponse.class);
    private LibraryBorrowerListSearchServlet libraryBorrowerListSearchServlet = spy(new LibraryBorrowerListSearchServlet());
    private final RequestDispatcher requestDispatcher = Mockito.mock(RequestDispatcher.class);
    private final LibraryUtils libraryUtils = Mockito.mock(LibraryUtils.class);


    @Before
    public void before() {
        request = mock(HttpServletRequest.class);
        response = mock(HttpServletResponse.class);
        libraryBorrowerListSearchServlet = spy(new LibraryBorrowerListSearchServlet());
        LibraryBorrowerListSearchServlet.libraryUtils = this.libraryUtils;
    }

    /**
     * If we don't pass a name or an id, we'll get a list of all borrowers
     * But what do we get if there aren't any?
     */
    @Test
    public void testListAllBorrowers_noBorrowersExist() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "No borrowers exist in the database");
    }


    /**
     * If we don't pass a name or an id, we'll get a list of all borrowers
     */
    @Test
    public void testListAllBorrowers() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(libraryUtils.listAllBorrowers()).thenReturn(Arrays.asList(DEFAULT_BORROWER));
        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "[{\"Name\": \"abe borrower\", \"Id\": \"1\"}]");
    }

    /**
     * If we pass an id, we'll get a particular borrower
     */
    @Test
    public void testSearchById() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("id")).thenReturn("1");
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBorrowerById(1)).thenReturn(Borrower.createEmpty());

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(libraryUtils).searchForBorrowerById(1);
    }

    /**
     * If we pass a name, and the borrower isn't found
     */
    @Test
    public void testSearchByNameNotFound() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("name")).thenReturn(A_BORROWER);
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBorrowerByName(A_BORROWER)).thenReturn(Borrower.createEmpty());

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(libraryUtils).searchForBorrowerByName(A_BORROWER);
    }

    /**
     * If we pass a name, we'll get a particular borrower
     */
    @Test
    public void testSearchByName() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("name")).thenReturn(A_BORROWER);
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBorrowerByName(A_BORROWER)).thenReturn(DEFAULT_BORROWER);

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "[{\"Name\": \"abe borrower\", \"Id\": \"1\"}]");
    }


    /**
     * If there aren't any borrowers
     */
    @Test
    public void testSearchNoBorrowers() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("id")).thenReturn("");
        when(request.getParameter("name")).thenReturn("");

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "No borrowers exist in the database");
    }

    /**
     * If nothing found by id
     */
    @Test
    public void testSearchNothingFoundById() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("id")).thenReturn("1");
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBorrowerById(1)).thenReturn(Borrower.createEmpty());

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "No borrowers found with an id of 1");
    }


    /**
     * If borrower found by id
     */
    @Test
    public void testSearchBorrowerFoundById() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("id")).thenReturn("1");
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBorrowerById(1)).thenReturn(DEFAULT_BORROWER);

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "[{\"Name\": \"abe borrower\", \"Id\": \"1\"}]");
    }


    /**
     * If the id isn't a number
     */
    @Test
    public void testSearchByBadId() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        // a is not a valid id
        when(request.getParameter("id")).thenReturn("a");
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBorrowerById(1)).thenReturn(DEFAULT_BORROWER);

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "Error: could not parse the borrower id as an integer");
    }

    /**
     * If no borrowers found by name
     */
    @Test
    public void testSearchNothingFoundByName() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("name")).thenReturn(A_BORROWER);
        // the following is just to avoid a null pointer exception when the test succeeds
        when(libraryUtils.searchForBorrowerByName(A_BORROWER)).thenReturn(Borrower.createEmpty());

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(libraryUtils).searchForBorrowerByName(A_BORROWER);
        verify(request).setAttribute(RESULT, "No borrowers found with a name of " + A_BORROWER);
    }

    /**
     * If we provide an ID and a name
     */
    @Test
    public void testSearchIdAndName() {
        when(request.getRequestDispatcher(ServletUtils.RESTFUL_RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("name")).thenReturn(A_BORROWER);
        when(request.getParameter("id")).thenReturn("1");

        // act
        libraryBorrowerListSearchServlet.doGet(request, response);

        // verify that the correct redirect was chosen.
        verify(request).setAttribute(RESULT, "Error: please search by either name or id, not both");
    }

}



================================================
FILE: src/test/java/com/coveros/training/library/LibraryLendServletTests.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.LibraryActionResults;
import org.junit.Assert;
import org.junit.Test;
import org.mockito.Mockito;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.sql.Date;
import java.time.LocalDate;
import java.time.Month;

import static org.mockito.Mockito.*;

public class LibraryLendServletTests {

    private final static Date BORROW_DATE = Date.valueOf(LocalDate.of(2018, Month.JANUARY, 1));
    private static final String BOOK_TITLE = "The DevOps Handbook";
    private static final String ALICE = "alice";
    private final LibraryLendServlet libraryLendServlet = Mockito.spy(new LibraryLendServlet());
    private final LibraryUtils libraryUtils = Mockito.mock(LibraryUtils.class);
    private final HttpServletRequest request = Mockito.mock(HttpServletRequest.class, RETURNS_DEEP_STUBS);
    private final HttpServletResponse response = Mockito.mock(HttpServletResponse.class);

    @Test
    public void testHappyPathPost() {
        when(request.getParameter("book")).thenReturn(BOOK_TITLE);
        when(request.getParameter("borrower")).thenReturn(ALICE);
        doReturn(BORROW_DATE).when(libraryLendServlet).getDateNow();
        LibraryLendServlet.libraryUtils = libraryUtils;
        when(libraryUtils.lendBook(BOOK_TITLE, ALICE, BORROW_DATE)).thenReturn(LibraryActionResults.SUCCESS);

        libraryLendServlet.doPost(request, response);

        verify(request).setAttribute("result", "SUCCESS");
    }

    @Test
    public void testDateFunction() {
        final Date dateNow = libraryLendServlet.getDateNow();
        Assert.assertNotEquals(dateNow, Date.valueOf(LocalDate.MIN));
        Assert.assertNotEquals(dateNow, Date.valueOf(LocalDate.MAX));
    }

    /**
     * If they pass in an empty string for either field, it should return a message
     * indicating that.
     */
    @Test
    public void testEmptyString_Book() {
        String emptyString = "";
        when(request.getParameter("book")).thenReturn(emptyString);
        when(request.getParameter("borrower")).thenReturn(ALICE);

        // do the post
        libraryLendServlet.doPost(request, response);

        // verify that the missing book title was handled
        Mockito.verify(request).setAttribute("result", "NO_BOOK_TITLE_PROVIDED");
    }

    /**
     * If they pass in an empty string for either field, it should return a message
     * indicating that.
     */
    @Test
    public void testEmptyString_Borrower() {
        String emptyString = "";
        when(request.getParameter("borrower")).thenReturn(emptyString);
        when(request.getParameter("book")).thenReturn(BOOK_TITLE);

        // do the post
        libraryLendServlet.doPost(request, response);

        // verify that the missing borrower was handled
        Mockito.verify(request).setAttribute("result", "NO_BORROWER_PROVIDED");
    }

}



================================================
FILE: src/test/java/com/coveros/training/library/LibraryRegisterBookServletTests.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.helpers.ServletUtils;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import static org.mockito.Mockito.*;

public class LibraryRegisterBookServletTests {

    private HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
    private HttpServletResponse response = Mockito.mock(HttpServletResponse.class);
    private LibraryRegisterBookServlet libraryRegisterBookServlet = spy(new LibraryRegisterBookServlet());
    private final RequestDispatcher requestDispatcher = Mockito.mock(RequestDispatcher.class);


    @Before
    public void before() {
        request = mock(HttpServletRequest.class);
        response = mock(HttpServletResponse.class);
        libraryRegisterBookServlet = spy(new LibraryRegisterBookServlet());
        LibraryRegisterBookServlet.libraryUtils = Mockito.mock(LibraryUtils.class);
    }

    @Test
    public void testHappyPathPost() {
        when(request.getRequestDispatcher(ServletUtils.RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("book")).thenReturn("The DevOps Handbook");
        when(LibraryRegisterBookServlet.libraryUtils.registerBook(Mockito.anyString()))
                .thenReturn(LibraryActionResults.SUCCESS);

        // do the post
        libraryRegisterBookServlet.doPost(request, response);

        // verify that the correct redirect was chosen.
        verify(request).getRequestDispatcher(ServletUtils.RESULT_JSP);
    }

    /**
     * If they pass in an empty string, it should return a message
     * indicating that.
     */
    @Test
    public void testEmptyString() {
        when(request.getRequestDispatcher(ServletUtils.RESULT_JSP)).thenReturn(requestDispatcher);
        String emptyString = "";
        when(request.getParameter("book")).thenReturn(emptyString);

        // do the post
        libraryRegisterBookServlet.doPost(request, response);

        // verify that the missing book title was handled
        Mockito.verify(request).setAttribute("result", "NO_BOOK_TITLE_PROVIDED");
    }
}



================================================
FILE: src/test/java/com/coveros/training/library/LibraryRegisterBorrowerServletTests.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.LibraryActionResults;
import com.coveros.training.helpers.ServletUtils;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import static org.mockito.Mockito.*;

public class LibraryRegisterBorrowerServletTests {

    private HttpServletRequest request = Mockito.mock(HttpServletRequest.class);
    private HttpServletResponse response = Mockito.mock(HttpServletResponse.class);
    private LibraryRegisterBorrowerServlet libraryRegisterBorrowerServlet = spy(new LibraryRegisterBorrowerServlet());
    private final RequestDispatcher requestDispatcher = Mockito.mock(RequestDispatcher.class);

    @Before
    public void before() {
        request = mock(HttpServletRequest.class);
        response = mock(HttpServletResponse.class);
        libraryRegisterBorrowerServlet = spy(new LibraryRegisterBorrowerServlet());
        LibraryRegisterBorrowerServlet.libraryUtils = Mockito.mock(LibraryUtils.class);
    }

    @Test
    public void testHappyPathPost() {
        when(request.getRequestDispatcher(ServletUtils.RESULT_JSP)).thenReturn(requestDispatcher);
        when(request.getParameter("borrower")).thenReturn("Alice");
        when(LibraryRegisterBorrowerServlet.libraryUtils.registerBorrower(Mockito.anyString()))
                .thenReturn(LibraryActionResults.SUCCESS);

        // do the post
        libraryRegisterBorrowerServlet.doPost(request, response);

        // verify that the correct redirect was chosen.
        verify(request).getRequestDispatcher(ServletUtils.RESULT_JSP);
    }


    /**
     * If they pass in an empty string, it should return a message
     * indicating that.
     */
    @Test
    public void testEmptyString() {
        when(request.getRequestDispatcher(ServletUtils.RESULT_JSP)).thenReturn(requestDispatcher);
        String emptyString = "";
        when(request.getParameter("borrower")).thenReturn(emptyString);

        // do the post
        libraryRegisterBorrowerServlet.doPost(request, response);

        // verify that the missing borrower name was handled
        Mockito.verify(request).setAttribute("result", "NO_BORROWER_PROVIDED");
    }
}



================================================
FILE: src/test/java/com/coveros/training/library/LibraryUtilsTests.java
================================================
package com.coveros.training.library;

import com.coveros.training.library.domainobjects.*;
import com.coveros.training.persistence.IPersistenceLayer;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.mockito.Mockito;

import java.sql.Date;
import java.time.LocalDate;
import java.time.Month;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static org.mockito.internal.verification.VerificationModeFactory.times;

public class LibraryUtilsTests {

    private IPersistenceLayer mockPersistenceLayer = Mockito.mock(IPersistenceLayer.class);
    private LibraryUtils libraryUtils = Mockito.spy(new LibraryUtils(mockPersistenceLayer));

    private final Book DEFAULT_BOOK = BookTests.createTestBook();
    private final Borrower DEFAULT_BORROWER = BorrowerTests.createTestBorrower();
    private final static Date BORROW_DATE = Date.valueOf(LocalDate.of(2018, Month.JANUARY, 1));


    @Before
    public void init() {
        mockPersistenceLayer = Mockito.mock(IPersistenceLayer.class);
        libraryUtils = Mockito.spy(new LibraryUtils(mockPersistenceLayer));
    }

    @Test
    public void testCanCreateEmpty() {
        final LibraryUtils libraryUtils = LibraryUtils.createEmpty();
        Assert.assertTrue(libraryUtils.isEmpty());
    }

    @Test
    public void testCanLendBook() {
        Mockito.doReturn(Loan.createEmpty()).when(libraryUtils).searchForLoanByBook(DEFAULT_BOOK);

        final LibraryActionResults libraryActionResults =
                libraryUtils.lendBook(DEFAULT_BOOK, DEFAULT_BORROWER, BORROW_DATE);

        Assert.assertEquals(LibraryActionResults.SUCCESS, libraryActionResults);
    }

    /**
     * Same as {@link #testCanLendBook()} but we're hitting its wrapper.
     */
    @Test
    public void testCanLendBook_wrapperMethod() {
        Mockito.doReturn(Loan.createEmpty()).when(libraryUtils).searchForLoanByBook(DEFAULT_BOOK);
        Mockito.doReturn(DEFAULT_BOOK).when(libraryUtils).searchForBookByTitle(DEFAULT_BOOK.title);
        Mockito.doReturn(DEFAULT_BORROWER).when(libraryUtils).searchForBorrowerByName(DEFAULT_BORROWER.name);

        final LibraryActionResults libraryActionResults =
                libraryUtils.lendBook(DEFAULT_BOOK.title, DEFAULT_BORROWER.name, BORROW_DATE);

        Assert.assertEquals(LibraryActionResults.SUCCESS, libraryActionResults);
    }

    @Test
    public void testCanRegisterBorrower() {
        Mockito.doReturn(Borrower.createEmpty()).when(libraryUtils).searchForBorrowerByName(DEFAULT_BORROWER.name);

        final LibraryActionResults libraryActionResults
                = libraryUtils.registerBorrower(DEFAULT_BORROWER.name);

        Assert.assertEquals(LibraryActionResults.SUCCESS, libraryActionResults);
    }

    @Test
    public void testCanRegisterBook() {
        Mockito.doReturn(Book.createEmpty()).when(libraryUtils).searchForBookByTitle(DEFAULT_BOOK.title);

        final LibraryActionResults libraryActionResults = libraryUtils.registerBook(DEFAULT_BOOK.title);

        Assert.assertEquals(LibraryActionResults.SUCCESS, libraryActionResults);
    }

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    /**
     * Makes no sense to allow registering a book with an empty string.
     * Throw an exception, since it's probably a dev error in that case - it
     * should never have been allowed to occur, by the developer.
     */
    @Test
    public void testCannotRegisterBookWithEmptyString() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("bookTitle was an empty string - disallowed when registering books");

        libraryUtils.registerBook("");
    }

    @Test
    public void testCanSearchForLoanByBook() {
        libraryUtils.searchForLoanByBook(DEFAULT_BOOK);
        Mockito.verify(mockPersistenceLayer, times(1)).searchForLoanByBook(DEFAULT_BOOK);
    }

    @Test
    public void testCanSearchForLoanByBorrower() {
        libraryUtils.searchForLoanByBorrower(DEFAULT_BORROWER);
        Mockito.verify(mockPersistenceLayer, times(1)).searchForLoanByBorrower(DEFAULT_BORROWER);
    }

    @Test
    public void testCanSearchForBorrowerByName() {
        libraryUtils.searchForBorrowerByName(DEFAULT_BORROWER.name);
        Mockito.verify(mockPersistenceLayer, times(1)).searchBorrowerDataByName(DEFAULT_BORROWER.name);
    }

    @Test
    public void testCanSearchForBooksByTitle() {
        Mockito.when(mockPersistenceLayer.searchBooksByTitle(DEFAULT_BOOK.title)).thenReturn(Optional.of(DEFAULT_BOOK));
        libraryUtils.searchForBookByTitle(DEFAULT_BOOK.title);
        Mockito.verify(mockPersistenceLayer, times(1)).searchBooksByTitle(DEFAULT_BOOK.title);
    }

    /**
     * We don't allow to search by empty string.
     */
    @Test
    public void testShouldThrowExceptionWhenSearchingWithEmptyStringAsBookTitle() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("when searching for a book, must include a non-empty string for title");

        libraryUtils.searchForBookByTitle("");
    }

    @Test
    public void testCanSearchForBooksById() {
        Mockito.when(mockPersistenceLayer.searchBooksById(DEFAULT_BOOK.id)).thenReturn(Optional.of(DEFAULT_BOOK));
        libraryUtils.searchForBookById(DEFAULT_BOOK.id);
        Mockito.verify(mockPersistenceLayer, times(1)).searchBooksById(DEFAULT_BOOK.id);
    }

    /**
     * The id of the book must be 1 or greater.  0 isn't allowed, nor anything else below 1.
     */
    @Test
    public void testShouldThrowExceptionWhenSearchingWithLessThanOneAsBookId() {
        thrown.expect(IllegalArgumentException.class);
        thrown.expectMessage("when searching for a book, must include an id of one or greater");

        libraryUtils.searchForBookById(0);
    }

    /**
     * Basic happy path - delete a book that is registered.
     */
    @Test
    public void testCanDeleteBook() {
        Mockito.when(mockPersistenceLayer.searchBooksByTitle(DEFAULT_BOOK.title)).thenReturn(Optional.of(DEFAULT_BOOK));

        final LibraryActionResults result = libraryUtils.deleteBook(DEFAULT_BOOK);

        Mockito.verify(mockPersistenceLayer, times(1)).deleteBook(DEFAULT_BOOK.id);
        Assert.assertEquals(LibraryActionResults.SUCCESS, result);
    }

    /**
     * If a book isn't registered, then obviously we cannot delete it.
     */
    @Test
    public void testCannotDeleteNonRegisteredBook() {
        Mockito.when(mockPersistenceLayer.searchBooksByTitle(DEFAULT_BOOK.title)).thenReturn(Optional.empty());

        final LibraryActionResults result = libraryUtils.deleteBook(DEFAULT_BOOK);

        Mockito.verify(mockPersistenceLayer, times(0)).deleteBook(DEFAULT_BOOK.id);
        Assert.assertEquals(LibraryActionResults.NON_REGISTERED_BOOK_CANNOT_BE_DELETED, result);
    }

    /**
     * Basic happy path - delete a borrower who is registered.
     */
    @Test
    public void testCanDeleteBorrower() {
        Mockito.when(mockPersistenceLayer.searchBorrowerDataByName(DEFAULT_BORROWER.name)).thenReturn(Optional.of(DEFAULT_BORROWER));

        final LibraryActionResults result = libraryUtils.deleteBorrower(DEFAULT_BORROWER);

        Mockito.verify(mockPersistenceLayer, times(1)).deleteBorrower(DEFAULT_BORROWER.id);
        Assert.assertEquals(LibraryActionResults.SUCCESS, result);
    }

    /**
     * If a borrower isn't registered, then obviously we cannot delete them.
     */
    @Test
    public void testCannotDeleteNonRegisteredBorrower() {
        Mockito.when(mockPersistenceLayer.searchBorrowerDataByName(DEFAULT_BORROWER.name)).thenReturn(Optional.empty());

        final LibraryActionResults result = libraryUtils.deleteBorrower(DEFAULT_BORROWER);

        Mockito.verify(mockPersistenceLayer, times(0)).deleteBorrower(DEFAULT_BORROWER.id);
        Assert.assertEquals(LibraryActionResults.NON_REGISTERED_BORROWER_CANNOT_BE_DELETED, result);
    }

    /**
     * A test to cover the action of listing all the books in the database.
     * Perhaps unusual, given how large libraries get, but we're going MVP style - minimum
     * viable product.  At early stages we may develop features that later on become obsolete.
     */
    @Test
    public void testShouldBeAbleToListAllBooks() {
        final List<Book> books = generateListOfBooks(new String[]{"foo", "bar"});
        Mockito.when(mockPersistenceLayer.listAllBooks()).thenReturn(Optional.of(books));

        List<Book> bookList = libraryUtils.listAllBooks();

        Assert.assertEquals(books, bookList);
    }

    /**
     * A test to cover the action of listing all the borrowers in the database.
     * Perhaps unusual, given how large libraries get, but we're going MVP style - minimum
     * viable product.  At early stages we may develop features that later on become obsolete.
     */
    @Test
    public void testShouldBeAbleToListAllBorrowers() {
        final List<Borrower> borrowers = generateListOfBorrowers(new String[]{"foo", "bar"});
        Mockito.when(mockPersistenceLayer.listAllBorrowers()).thenReturn(Optional.of(borrowers));
        List<Borrower> borrowerList = libraryUtils.listAllBorrowers();
        Assert.assertEquals(borrowers, borrowerList);
    }

    @Test
    public void testShouldListAvailableBooks() {
        libraryUtils.listAvailableBooks();
        Mockito.verify(mockPersistenceLayer).listAvailableBooks();
    }

    /**
     * A helper function to generate a list of books, given a list of titles.
     */
    public static List<Book> generateListOfBooks(String[] bookTitles) {
        ArrayList<Book> bookList = new ArrayList<>();
        int id = 1;
        for(String s : bookTitles) {
            bookList.add(new Book(id, s));
            id++;
        }
        return bookList;
    }


    /**
     * A helper function to generate a list of borrowers, given a list of names.
     */
    public static List<Borrower> generateListOfBorrowers(String[] names) {
        ArrayList<Borrower> borrowerList = new ArrayList<>();
        int id = 1;
        for(String s : names) {
            borrowerList.add(new Borrower(id, s));
            id++;
        }
        return borrowerList;
    }


}