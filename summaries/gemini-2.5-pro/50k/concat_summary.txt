=== summary_chunk_1.txt ===

This document provides a comprehensive architectural summary of the provided codebase chunk, focusing on details relevant to microservice decomposition analysis.

### 1. Overall Architecture Overview

The codebase consists of a monolithic application composed of two main, independent components: a Java-based web application and a Java Swing desktop application. The project serves as a demonstration of software development best practices, particularly in testing and CI/CD.

*   **Technology Stack**:
    *   **Backend**: Java 11+, Java Servlets, JSP
    *   **Build & Dependency Management**: Gradle, Pipenv (for Python test dependencies)
    *   **Database**: H2 (in-memory and file-based) with Flyway for schema migrations.
    *   **Web Server**: Embedded Tomcat (managed by the Gretty Gradle plugin).
    *   **Desktop UI**: Java Swing.
*   **Architectural Style**: The web application is a classic N-tier monolith with server-side rendering. The domains (Authentication, Library, Math) are logically separated by package structure but are deployed as a single unit. The desktop application is a standalone thick client.
*   **Key Principles**: The architecture emphasizes immutability, avoidance of nulls, and a clear separation of concerns between web, business logic, and data access layers.

---

### 2. Web Application Component (`7ep-demo/src`)

This is the primary component, a multi-domain web application.

#### 2.1. Component Responsibilities & Business Domains

The web application provides functionalities across several distinct business domains, making it a prime candidate for decomposition.

*   **Authentication**: Manages user registration and login.
*   **Library**: A simple library management system for registering books, borrowers, and processing loans.
*   **Mathematics**: Exposes endpoints for simple arithmetic, Fibonacci sequence, and Ackermann function calculations.
*   **Expenses**: Contains logic for a simple expense calculation (calculating alcohol cost from a dinner bill).
*   **Persistence**: A centralized data access layer for all domains.

#### 2.2. API Endpoints and Interfaces

The application exposes its functionality via standard Java Servlets. All endpoints are prefixed with `/demo`.

| Endpoint Path                  | Class                                   | HTTP Method(s) | Responsibility                                      |
| ------------------------------ | --------------------------------------- | -------------- | --------------------------------------------------- |
| `/register`                    | `RegisterServlet.java`                  | POST           | Registers a new user.                               |
| `/login`                       | `LoginServlet.java`                     | POST           | Authenticates a user.                               |
| `/registerbook`                | `LibraryRegisterBookServlet.java`       | POST           | Registers a new book in the library.                |
| `/registerborrower`            | `LibraryRegisterBorrowerServlet.java`   | POST           | Registers a new borrower.                           |
| `/lend`                        | `LibraryLendServlet.java`               | POST           | Creates a loan record for a book and borrower.      |
| `/library-books-available`     | `LibraryBookListAvailableServlet.java`  | GET            | Lists all books not currently on loan.              |
| `/library-books-search`        | `LibraryBookListSearchServlet.java`     | GET            | Searches for books.                                 |
| `/library-borrowers-search`    | `LibraryBorrowerListSearchServlet.java` | GET            | Searches for borrowers.                             |
| `/math`                        | `MathServlet.java`                      | POST           | Performs simple addition.                           |
| `/fibonacci`                   | `FibServlet.java`                       | POST           | Calculates a Fibonacci number.                      |
| `/ackermann`                   | `AckServlet.java`                       | POST           | Calculates an Ackermann number.                     |
| `/flyway`                      | `DbServlet.java`                        | GET            | Resets the database (for testing purposes).         |

#### 2.3. Database Schema and Data Models

The application uses a single H2 database shared by all business domains. Schema is managed by Flyway.

*   **Schema Definition (`V2__Rest_of_tables_for_auth_and_library.sql`)**:
    *   `users`: (id, name, hash) - Stores user credentials. `name` is unique.
    *   `books`: (id, title) - Stores book information.
    *   `borrowers`: (id, name) - Stores borrower information.
    *   `loans`: (id, book, borrower, checkout_date, loan_period_days) - Stores loan records, linking books and borrowers.

*   **Data Models (`domainobjects` packages)**:
    *   `User.java`: Represents a row in the `users` table.
    *   `Book.java`, `Borrower.java`, `Loan.java`: Represent rows in their respective library tables.
    *   Status/Result Enums and objects are used extensively to avoid returning nulls (e.g., `RegistrationResult`, `PasswordResultEnums`, `LibraryActionResults`).

#### 2.4. Service Dependencies and Communication Patterns

*   **Internal Communication**: Follows a strict layered pattern.
    1.  **Web Layer** (`*Servlet.java`): Handles HTTP requests/responses.
    2.  **Business Logic Layer** (`*Utils.java`): Contains the core logic for each domain (e.g., `LibraryUtils`, `RegistrationUtils`).
    3.  **Data Access Layer** (`PersistenceLayer.java`): A single class implementing the `IPersistenceLayer` interface that handles all JDBC interactions with the database. This represents a classic Repository/DAO pattern and is a central point of coupling to the shared database.
*   **External Dependencies**: The application itself does not make calls to external services.

#### 2.5. Key Business Logic and Algorithms

*   **Authentication (`RegistrationUtils`, `LoginUtils`)**:
    *   User registration with checks for existing usernames.
    *   Password validation logic to check for sufficient complexity/entropy.
    *   Authentication via password hash comparison.
*   **Library (`LibraryUtils`)**:
    *   CRUD operations for Books and Borrowers.
    *   Business rules for lending books (e.g., cannot lend a book that is already checked out, cannot lend to an unregistered borrower).
    *   Search and listing functionality for available books.
*   **Mathematics (`Calculator`, `Fibonacci`, `Ackermann`)**:
    *   Contains both iterative and recursive implementations for Fibonacci and Ackermann functions.

---

### 3. Desktop Application Component (`7ep-demo/desktop_app`)

A self-contained Java Swing application for a different business domain.

#### 3.1. Component Responsibilities

Calculates auto insurance premium adjustments based on a driver's age and number of prior claims. It determines premium increase, whether a warning letter should be sent, or if the policy should be canceled.

#### 3.2. API Endpoints and Interfaces

The application exposes a programmatic interface via a custom TCP socket server for test automation purposes.

*   **`AutoInsuranceScriptServer.java`**: Listens on **TCP port 8000**.
*   **Command Protocol**: A simple, text-based request-response protocol.
    *   **SET commands**: `set age <int>`, `set claims <int>`, `set label <string>`
    *   **GET commands**: `get age`, `get claims`, `get label`
    *   **Action commands**: `click calculate`
    *   **Control commands**: `quit`

#### 3.3. Data Models

This component is stateless and has no database.
*   **`AutoInsuranceAction.java`**: The primary domain object representing the outcome of a calculation.
    *   `premiumIncreaseDollars` (int)
    *   `warningLetterEnum` (Enum: `NONE`, `LTR1`, `LTR2`, `LTR3`)
    *   `isPolicyCanceled` (boolean)
*   **`InvalidClaimsException.java`**: Custom exception for invalid input.

#### 3.4. Key Business Logic (`AutoInsuranceProcessor.java`)

Contains a rules engine that maps inputs (`claims`, `age`) to an `AutoInsuranceAction` output.
*   **Rule Example**: If `claims >= 2` and `claims <= 4` and `age >= 16` and `age <= 25`, then `premiumIncrease` is $400 and `warningLetter` is `LTR2`.
*   **Rule Example**: If `claims >= 5`, then `isPolicyCanceled` is `true`.

---

### 4. Configuration, Deployment, and CI/CD

These cross-cutting concerns define how the application is built, tested, and deployed.

#### 4.1. Configuration and Deployment

*   **Build System**: Gradle (`gradlew`). Project properties are defined in `gradle.properties`.
*   **Deployment**: The web application is packaged as a WAR file. The `gradlew apprun` command starts an embedded Tomcat server, making the app available at `http://localhost:8080/demo`.
*   **Test Dependencies**: Python test dependencies are managed via `Pipfile` and `pipenv`.

#### 4.2. CI/CD Pipeline (`jenkins/Jenkinsfile`)

The project includes a sophisticated Jenkins pipeline that automates a comprehensive quality assurance process. This is a critical architectural asset.

*   **Trigger**: Configured to run on Git push via a `post-receive` hook that calls the Jenkins CLI.
*   **Key Stages**:
    1.  **Build**: Compiles code and assembles the WAR file.
    2.  **Unit & DB Tests**: Runs fast, isolated tests and then tests requiring database interaction.
    3.  **BDD Tests**: Executes Cucumber feature tests and generates reports.
    4.  **Static Analysis**: Integrates with SonarQube and enforces a quality gate.
    5.  **Deploy to Test**: Deploys the application to a test environment.
    6.  **End-to-End Testing**: Runs a suite of **API Tests** (Python), **UI BDD Tests** (Behave/Selenium), and other **UI Tests** (Java/Selenium).
    7.  **Security Testing**:
        *   **Dependency Analysis**: Uses OWASP DependencyCheck to scan for vulnerable libraries.
        *   **Dynamic Scanning (DAST)**: Routes all test traffic through an OWASP ZAP proxy (running on port 8888) and generates a security report.
    8.  **Performance Tests**: Executes JMeter tests against the deployed application.
    9.  **Mutation Tests**: Uses Pitest to assess the quality of the test suite.
    10. **Deploy to Prod**: A final, placeholder stage representing production deployment.

=== summary_chunk_2.txt ===

An architectural summary of the provided codebase chunk is detailed below, focusing on information relevant for microservice decomposition analysis.

### 1. Architectural Style and Patterns

*   **Overall Architecture:** The application is a classic **Monolithic Architecture**. All business domains (Authentication, Library Management, Mathematics) are tightly coupled within a single Java web application, deployed as a single unit.
*   **Internal Pattern:** It follows a traditional **3-Tier (Layered) Architecture**:
    *   **Presentation/API Layer:** Implemented using Java Servlets (`javax.servlet.http.HttpServlet`). Each servlet defines a web endpoint.
    *   **Business Logic Layer:** Encapsulated in `*Utils` classes (e.g., `LibraryUtils`, `RegistrationUtils`, `LoginUtils`). This layer contains the core application logic and orchestrates calls to the data access layer.
    *   **Data Access Layer (DAL):** A custom micro-ORM implemented in the `PersistenceLayer` class, which is the sole component responsible for database interactions via JDBC. The `IPersistenceLayer` interface is used, allowing for dependency injection and easier testing.
*   **Database Management:** Database schema evolution is managed using the **Flyway** migration framework. Scripts are executed automatically on application startup.

### 2. Component Breakdown and Responsibilities

The codebase is organized into distinct feature domains, which are strong candidates for decomposition into microservices.

#### A. Authentication Service
This component is responsible for user registration and login.
*   **`LoginServlet`**: Exposes the `/login` endpoint for user authentication.
*   **`RegisterServlet`**: Exposes the `/register` endpoint for new user registration.
*   **`LoginUtils`**: Contains the business logic to verify user credentials against the database.
*   **`RegistrationUtils`**: Contains business logic for the registration process, including username validation and password complexity checks.
*   **Dependencies**:
    *   It depends on the `PersistenceLayer` to store and retrieve user data.
    *   It uses the `me.gosimple.nbvcxz` library for password strength analysis.

#### B. Library Service
This is the most complex domain, handling the management of books, borrowers, and loans.
*   **`LibraryUtils`**: The core business logic class. It manages lending, registering books/borrowers, and searching for library entities.
*   **Servlets (API Endpoints)**:
    *   `LibraryRegisterBookServlet` (`/registerbook`): Adds a new book to the inventory.
    *   `LibraryRegisterBorrowerServlet` (`/registerborrower`): Adds a new borrower.
    *   `LibraryLendServlet` (`/lend`): Creates a loan record for a book and a borrower.
    *   `LibraryBookListSearchServlet` (`/book`): Lists all books or searches by title/ID.
    *   `LibraryBorrowerListSearchServlet` (`/borrower`): Lists all borrowers or searches by name/ID.
    *   `LibraryBookListAvailableServlet` (`/listavailable`): Lists only books that are not currently loaned out.
*   **Dependencies**: It is heavily dependent on the `PersistenceLayer` for all CRUD operations related to books, borrowers, and loans.

#### C. Mathematics Service
This component provides various mathematical calculation endpoints. It is stateless and functionally distinct from the other domains.
*   **Servlets (API Endpoints)**:
    *   `MathServlet` (`/math`): Performs simple addition.
    *   `AckServlet` (`/ackermann`): Calculates Ackermann's function using different algorithms.
    *   `FibServlet` (`/fibonacci`): Calculates Fibonacci numbers using different algorithms.
*   **Business Logic/Algorithms**:
    *   `Calculator`: Simple arithmetic.
    *   `Ackermann`, `AckermannIterative`: Recursive and iterative implementations of the Ackermann function.
    *   `Fibonacci`, `FibonacciIterative`: Recursive and iterative implementations for Fibonacci sequence calculation.
*   **Dependencies**: This component is self-contained and has no dependencies on other business components or the persistence layer.

#### D. Persistence Component (Shared Infrastructure)
This is a cross-cutting concern that serves as the data access layer for all stateful services.
*   **`PersistenceLayer`**: Implements the `IPersistenceLayer` interface. It manages the JDBC `DataSource`, creates and executes prepared SQL statements, and maps `ResultSet` data to domain objects. It is the single gateway to the H2 database.
*   **`DbServlet`**: Exposes the `/flyway` endpoint for manual database management (clean, migrate).

#### E. Incomplete/Placeholder Components
*   **`cartesianproduct`**: Contains a placeholder `CartesianProduct` class with an empty implementation.
*   **`expenses`**: Contains `AlcoholCalculator` and related classes, all of which return empty/default values. These represent potential future features but are not currently functional.

### 3. API Endpoints and Interfaces

| Method | Endpoint               | Servlet Class                        | Parameters                                | Responsibility                                           |
| :----- | :--------------------- | :----------------------------------- | :---------------------------------------- | :------------------------------------------------------- |
| POST   | `/login`               | `LoginServlet`                       | `username`, `password`                    | Authenticate a user.                                     |
| POST   | `/register`            | `RegisterServlet`                    | `username`, `password`                    | Register a new user.                                     |
| POST   | `/registerbook`        | `LibraryRegisterBookServlet`         | `book` (title)                            | Add a new book.                                          |
| POST   | `/registerborrower`    | `LibraryRegisterBorrowerServlet`     | `borrower` (name)                         | Add a new borrower.                                      |
| POST   | `/lend`                | `LibraryLendServlet`                 | `book` (title), `borrower` (name)         | Lend a book to a borrower.                               |
| GET    | `/book`                | `LibraryBookListSearchServlet`       | `id` (optional), `title` (optional)       | List all books or search by ID/title.                    |
| GET    | `/borrower`            | `LibraryBorrowerListSearchServlet`   | `id` (optional), `name` (optional)        | List all borrowers or search by ID/name.                 |
| GET    | `/listavailable`       | `LibraryBookListAvailableServlet`    | (none)                                    | List all available (un-loaned) books.                    |
| POST   | `/math`                | `MathServlet`                        | `item_a`, `item_b`                        | Add two integers.                                        |
| POST   | `/fibonacci`           | `FibServlet`                         | `fib_param_n`, `fib_algorithm_choice`     | Calculate a Fibonacci number.                            |
| POST   | `/ackermann`           | `AckServlet`                         | `ack_param_m`, `ack_param_n`, `ack_algorithm_choice` | Calculate Ackermann's function.                      |
| GET    | `/flyway`              | `DbServlet`                          | `action` (`clean`, `migrate`)             | Manage the database schema state.                        |
| GET/POST| `/console/*`           | `org.h2.server.web.WebServlet`       | (H2 Console specific)                     | Provides a web-based console for the H2 database.        |

### 4. Database Schema and Data Models

*   **Database Engine:** H2 (configured for in-memory use at runtime, file-based for integration tests).
*   **Schemas:** `AUTH`, `LIBRARY`, `ADMINISTRATIVE`.

| Table          | Schema  | Columns                                                                   | Java Domain Object | Description                                                                 |
| :------------- | :------ | :------------------------------------------------------------------------ | :----------------- | :-------------------------------------------------------------------------- |
| `USER`         | `AUTH`  | `id` (SERIAL, PK), `name` (VARCHAR), `password_hash` (VARCHAR)              | `User`             | Stores user credentials. The password is a SHA-256 hash.                  |
| `BOOK`         | `LIBRARY`| `id` (SERIAL, PK), `title` (VARCHAR)                                      | `Book`             | Stores library book inventory.                                              |
| `BORROWER`     | `LIBRARY`| `id` (SERIAL, PK), `name` (VARCHAR)                                       | `Borrower`         | Stores registered library patrons.                                          |
| `LOAN`         | `LIBRARY`| `id` (SERIAL, PK), `book` (INT, FK to BOOK), `borrower` (INT, FK to BORROWER), `borrow_date` (DATE) | `Loan`             | Tracks which book is loaned to which borrower and when. `ON DELETE CASCADE` is enabled for both foreign keys. |
| `flyway_schema_history` | ADMINISTRATIVE | (Flyway standard columns)                               | N/A                | Tracks which database migrations have been applied.                         |

### 5. Key Business Logic and Algorithms

*   **User Registration Password Hashing**: `RegistrationUtils` uses `SHA-256` to hash passwords before they are stored in the database via `PersistenceLayer.updateUserWithPassword`.
*   **Password Strength Check**: `RegistrationUtils.isPasswordGood` uses the `Nbvcxz` library to enforce password complexity rules based on length (10-100 chars) and entropy, preventing weak passwords.
*   **Book Lending Logic**: `LibraryUtils.lendBook` enforces several business rules:
    1.  The book must exist in the system.
    2.  The borrower must be registered.
    3.  The book must not already be on loan (by checking for an existing loan record).
*   **Recursive vs. Iterative Algorithms**: The `mathematics` component provides both naive recursive and more performant iterative/tail-recursive algorithms for Fibonacci and Ackermann functions, selectable via an API parameter.

### 6. Configuration and Deployment

*   **Deployment Unit:** A standard WAR (Web Application Archive) file.
*   **Application Server:** A servlet container like Apache Tomcat is required.
*   **Startup Process:** The `WebAppListener` class is configured via `@WebListener` to execute on startup. Its `contextInitialized` method calls `pl.cleanAndMigrateDatabase()`, which uses Flyway to completely reset and re-apply the database schema every time the application starts. This makes the application stateless between restarts.
*   **Database Connection:** The JDBC connection URL is hardcoded in `PersistenceLayer` for runtime (`jdbc:h2:mem:training`) and in `PersistenceLayerTests` for integration testing (`jdbc:h2:./build/db/training`).
*   **Logging:** Configured via `src/main/resources/log4j2.xml` to log `INFO` level and above to the console.
*   **Web Configuration:** `src/main/webapp/WEB-INF/web.xml` configures the H2 console servlet and disables URL-based sessions in favor of cookies.
*   **UI:** A simple set of HTML/CSS/JS files provides a basic user interface for interacting with the library and database administration endpoints (`library.html`, `endpointcatalog.html`). The JavaScript in `catalog.js` and `library.js` makes asynchronous API calls (`XMLHttpRequest`) to the backend servlets.

=== summary_chunk_3.txt ===

This document provides a comprehensive architectural summary of the codebase chunk (Part 3 of 3), focusing on information critical for microservice decomposition analysis. The chunk consists entirely of unit, integration, and UI tests, from which the architecture of the application components is inferred.

### 1. Overall Architecture

The system is a monolithic Java web application built on the **Java Servlet API**. It follows a classic **3-Tier (Layered) Architecture**:

*   **Presentation/API Layer:** Composed of `HttpServlet` classes that expose API endpoints. They handle HTTP request/response, parse parameters, and delegate to the business logic layer.
*   **Business Logic Layer:** Implemented as "Utils" classes (e.g., `LibraryUtils`, `RegistrationUtils`). These components contain the core business rules and algorithms, orchestrating calls to the persistence layer.
*   **Persistence Layer:** Abstracted by an interface, `IPersistenceLayer`. This layer is responsible for all database interactions. The application uses a database migration tool (inferred to be Flyway from the `/flyway` endpoint) for schema management.

**Deployment & Lifecycle:**
The application runs on a Tomcat server (inferred from `WebAppListener`). A `WebAppListener` is configured to automatically clean and migrate the database on application startup, indicating a "database-as-code" approach suitable for CI/CD environments.

---

### 2. Bounded Contexts & Domain Analysis

The codebase can be clearly divided into four distinct domains, each a strong candidate for a microservice.

#### 2.1. Authentication & User Management Domain

This domain is responsible for user registration and login. It manages user credentials and authentication state.

**Components & Responsibilities:**

*   **`RegisterServlet`**:
    *   **Responsibility**: Exposes the user registration endpoint.
    *   **API Endpoint**: `POST /register` (inferred from UI test `ApiCalls.java`)
    *   **Interface**:
        *   Request Parameters: `username` (String), `password` (String).
        *   Logic: Validates that username and password are not empty. Delegates processing to `RegistrationUtils`. Forwards to `result.jsp` with the registration outcome.
*   **`LoginServlet`**:
    *   **Responsibility**: Exposes the user login endpoint.
    *   **API Endpoint**: `POST /login` (inferred)
    *   **Interface**:
        *   Request Parameters: `username` (String), `password` (String).
        *   Logic: Validates inputs. Delegates credential checking to `LoginUtils`. Forwards to `result.jsp` with the message "access granted" or "access denied".
*   **`RegistrationUtils`**:
    *   **Responsibility**: Contains the core logic for user registration.
    *   **Key Business Logic**:
        1.  **Password Strength Check**: Implements an algorithm `isPasswordGood()` to validate password complexity/entropy (e.g., checks for length).
        2.  **User Existence Check**: Ensures the username is not already taken by calling `isUserInDatabase()`.
        3.  **User Creation**: Persists the new user if validation passes.
    *   **Dependencies**: `IPersistenceLayer`.
*   **`LoginUtils`**:
    *   **Responsibility**: Handles the business logic for user login.
    *   **Key Business Logic**: `isUserRegistered()` method that validates credentials against the persisted data.
    *   **Dependencies**: `IPersistenceLayer`.

**Data Models & Inferred DB Schema:**

*   **`User`**: `(long id, String name)`
*   **`RegistrationResult`**: A domain object representing the outcome of a registration attempt, containing a boolean success flag and a `RegistrationStatusEnums` status.
*   **`PasswordResult`**: A domain object detailing the results of a password strength check.
*   **Inferred Schema**: A `users` table is implied with columns like `id` (PK), `name` (UNIQUE), and a hashed `password`.

#### 2.2. Library Management Domain

This domain handles all library-related operations: managing books, borrowers, and the lending process.

**Components & Responsibilities:**

*   **Servlets (API Layer)**:
    *   **`LibraryRegisterBookServlet`**: `POST /registerbook`. Param: `book` (title).
    *   **`LibraryRegisterBorrowerServlet`**: `POST /registerborrower`. Param: `borrower` (name).
    *   **`LibraryLendServlet`**: `POST /lend`. Params: `book` (title), `borrower` (name).
    *   **`LibraryBookListSearchServlet`**: `GET /listbooks` (inferred). Optional params: `id`, `title`. Returns a JSON array of `Book` objects.
    *   **`LibraryBookListAvailableServlet`**: `GET /listavailablebooks` (inferred). No params. Returns a JSON array of `Book` objects not currently on loan.
    *   **`LibraryBorrowerListSearchServlet`**: `GET /listborrowers` (inferred). Optional params: `id`, `name`. Returns a JSON array of `Borrower` objects.
*   **`LibraryUtils`**:
    *   **Responsibility**: Central component for all library business logic.
    *   **Key Business Logic**:
        *   `registerBook(title)`: Checks if a book exists before saving.
        *   `registerBorrower(name)`: Checks if a borrower exists before saving.
        *   `lendBook(book, borrower, date)`: Main transaction logic. Verifies book and borrower are registered and that the book is not already checked out. Creates a `Loan` record.
        *   Provides search (`searchFor...`), list (`listAll...`), and delete (`delete...`) functionalities.
    *   **Dependencies**: `IPersistenceLayer`.

**Data Models & Inferred DB Schema:**

*   **`Book`**: `(long id, String title)`
*   **`Borrower`**: `(long id, String name)`
*   **`Loan`**: `(long id, Book book, Borrower borrower, Date borrowDate)`
*   **`LibraryActionResults`**: Enum representing the outcome of library operations (e.g., `SUCCESS`, `BOOK_CHECKED_OUT`).
*   **Inferred Schema**:
    *   `books` table: `id` (PK, long), `title` (varchar).
    *   `borrowers` table: `id` (PK, long), `name` (varchar).
    *   `loans` table: `id` (PK, long), `book_id` (FK to books.id), `borrower_id` (FK to borrowers.id), `borrow_date` (date).

#### 2.3. Mathematical Calculations Domain

A stateless domain providing complex mathematical computations. This is a pure function-as-a-service candidate.

**Components & Responsibilities:**

*   **`MathServlet`**: `POST /math` (inferred). Params: `item_a`, `item_b`. Performs simple addition.
*   **`AckServlet`**: `POST /ack` (inferred). Params: `ack_param_m`, `ack_param_n`, `ack_algorithm_choice`.
*   **`FibServlet`**: `POST /fib` (inferred). Params: `fib_param_n`, `fib_algorithm_choice`.
*   **Business Logic Classes**:
    *   `Ackermann`, `AckermannIterative`: Implements recursive and iterative versions of the Ackermann function using `BigInteger` for large results.
    *   `Fibonacci`, `FibonacciIterative`: Implements recursive and two different iterative versions of the Fibonacci sequence, also using `BigInteger`.
*   **Dependencies**: This domain has no dependencies on the persistence layer or other domains.

**Data Models**: No specific data models; input is primitive, and output is a `BigInteger` or numeric result.

#### 2.4. System Administration Domain

This domain provides administrative functions, primarily for managing the database state. It's essential for development and testing but would require strong security in production.

**Components & Responsibilities:**

*   **`DbServlet`**:
    *   **Responsibility**: Exposes an endpoint to manage the database schema.
    *   **API Endpoint**: `GET /flyway` (inferred from UI test setup scripts).
    *   **Interface**:
        *   Request Parameter: `action` (String, optional). Values can be `clean`, `migrate`. The default action is to clean and then migrate.
    *   **Dependencies**: `IPersistenceLayer`.

---

### 3. Persistence Layer Details (Inferred)

The persistence layer is defined by the `IPersistenceLayer` interface, which provides a clean separation of concerns.

**Interface Methods (Inferred from Utils Tests):**
*   **Authentication**: `areCredentialsValid(user, pass)`, `searchForUserByName(name)`, `saveNewUser(...)`
*   **Library**: `searchBooksById(id)`, `searchBooksByTitle(title)`, `searchBorrowerDataByName(name)`, `searchForLoanByBook(book)`, `searchForLoanByBorrower(borrower)`, `saveNewBook(title)`, `saveNewBorrower(name)`, `createLoan(book, borrower, date)`, `deleteBook(id)`, `deleteBorrower(id)`, `listAllBooks()`, `listAllBorrowers()`, `listAvailableBooks()`
*   **Admin**: `cleanDatabase()`, `migrateDatabase()`, `cleanAndMigrateDatabase()`

**SQL Handling:**
The `SqlData` and `ParameterObject` classes suggest a lightweight, custom SQL execution framework where prepared statements are built dynamically and parameters are applied with type safety.

---

### 4. UI & End-to-End Testing Framework

The codebase includes an extensive suite of UI tests that confirm user workflows and system behavior.

*   **Multi-Framework Strategy**: Tests are written in multiple languages and frameworks:
    *   **Python (Behave)**: Behavior-Driven Development (BDD) tests using Gherkin (`.feature` files) to describe user stories. `environment.py` handles WebDriver setup and calls the `/flyway` endpoint for database resets before each scenario.
    *   **Java (Selenium & HtmlUnit)**: Provides both browser-based (Selenium) and headless (HtmlUnit) testing. Critically, it includes an `ApiCalls.java` helper, which performs direct HTTP requests to the backend for test setup (e.g., registering users/books), confirming the API contract.
    *   **JavaScript (Mocha & Selenium)**
    *   **C# (NUnit & Selenium)**
    *   **Python (Pytest & Selenium)**: Includes an implementation of the **Page Object Model (POM)** pattern (`LibraryPageObjectModel`), which provides a structured, reusable abstraction over the UI.

*   **Key Tested Workflows**:
    1.  **User Authentication**: Registering a new user and logging in successfully.
    2.  **Book Lending**: Registering a borrower and a book, then successfully lending the book to the borrower.
    3.  **Mathematical Functions**: Calculating Ackermann and Fibonacci values via the UI.