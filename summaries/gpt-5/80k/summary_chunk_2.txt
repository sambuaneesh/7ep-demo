Architectural summary (chunk 2 of 2)

High-level modules and bounded contexts
- Mathematics (package com.coveros.training.mathematics)
  - Stateless computation utilities and HTTP endpoints for math-related functions.
  - Endpoints: /math (addition), /fibonacci (Fibonacci sequence). The endpoint catalog also references /ackermann (implementation likely in chunk 1).
- Persistence (package com.coveros.training.persistence)
  - Database access abstraction (IPersistenceLayer) and an implementation (PersistenceLayer) with a lightweight “micro ORM”.
  - Endpoint: /flyway for database maintenance (clean, migrate, clean+migrate).
  - Database schema managed by Flyway; in-memory H2 is the configured database.
- Tomcat bootstrap (package com.coveros.training.tomcat)
  - WebAppListener to initialize the database schemas at application startup.
- Web UI and resources (src/main/webapp)
  - JSPs for result rendering, static HTML pages (library.html, endpointcatalog.html), and JavaScript for AJAX and interaction (catalog.js, library.js).
  - H2 web console exposed under /console/* via web.xml.

Key components, classes, and responsibilities

Mathematics
- Calculator
  - add(int, int) and add(double, double) static methods: arithmetic addition.
  - add(Pair<Integer,Integer>, Pair<Integer,Integer>): pairwise addition using Apache Commons Pair.
  - toStringZeroToTen(int): integer 0–10 to English word mapping (“zero”..“ten”; returns “dunno” for out-of-range).
  - calculateAndMore(int a, int b, iFoo foo, iBar bar) [teaching stubs]: calls foo.doComplexThing(a), bar.doOtherComplexThing(c), then returns a+b+c+d.
  - calculateAndMorePart2(int a)/calculateAndMorePart3(int a) [teaching stubs/mocks]: use inner class Baz.doThirdPartyThing.
  - iFoo/iBar interfaces and default inner classes Foo/Bar; inner class Baz returns constant 42 for teaching.
- Fibonacci
  - calculate(long n): naive recursive Fibonacci, returns long (O(φ^n) time).
- FibonacciIterative
  - fibAlgo1(long n): BigInteger, fast doubling method (O(log n)).
  - fibAlgo2(int n): BigInteger, iterative linear algorithm (O(n)).
- TailRecursive
  - tailie: builds tail-recursive-esque computations using Java streams with a stop predicate (used by algorithms like Ackermann elsewhere).
- FunctionalField<F extends Enum<?>>
  - Functional interface to get typed fields from enum-based keys.

HTTP endpoints (Mathematics)
- MathServlet (POST /math)
  - Request params: item_a (int), item_b (int).
  - Behavior: sums two integers via Calculator.add and sets request attribute “result” to the integer; NumberFormatException ⇒ “result” = "Error: only accepts integers".
  - Response forwarding: ServletUtils.forwardToRestfulResult(request, response), which routes to restfulresult.jsp (plain body with ${result}).
  - Logging: SLF4J INFO.
- FibServlet (POST /fibonacci)
  - Request params:
    - fib_param_n (int)
    - fib_algorithm_choice: "default_recursive", "tail_recursive_1", "tail_recursive_2".
  - Behavior:
    - tail_recursive_1 ⇒ FibonacciIterative.fibAlgo1(n) (BigInteger)
    - tail_recursive_2 ⇒ FibonacciIterative.fibAlgo2(n) (BigInteger)
    - Otherwise default ⇒ Fibonacci.calculate(n) (long)
  - Error handling: NumberFormatException ⇒ “result” = "Error: only accepts integers".
  - Response forwarding: ServletUtils.forwardToRestfulResult.
  - Logging: SLF4J INFO, “Fibonacci value is {}”.

Persistence layer
- IPersistenceLayer (database boundary)
  - Library operations:
    - saveNewBorrower(String borrowerName) → long id
    - createLoan(Book book, Borrower borrower, Date borrowDate) → long id
    - saveNewBook(String bookTitle) → long id
    - updateBorrower(long id, String borrowerName)
    - deleteBook(long id), deleteBorrower(long id)
    - getBorrowerName(long id) → Optional<String>
    - searchBorrowerDataByName(String borrowerName) → Optional<Borrower>
    - searchBooksByTitle(String bookTitle) → Optional<Book>
    - searchBooksById(long id) → Optional<Book>
    - searchBorrowersById(long id) → Optional<Borrower>
    - listAllBooks() → Optional<List<Book>>
    - listAvailableBooks() → Optional<List<Book>>
    - searchForLoanByBorrower(Borrower borrower) → Optional<List<Loan>>
    - searchForLoanByBook(Book book) → Optional<Loan>
  - Authentication operations:
    - saveNewUser(String username) → long id
    - updateUserWithPassword(long id, String password) [hashes password]
    - searchForUserByName(String username) → Optional<User>
    - areCredentialsValid(String username, String password) → Optional<Boolean> (true if match)
  - Utility/db maintenance:
    - runBackup(String backupFileName) [H2 SCRIPT TO]
    - runRestore(String backupFileName) [DROP SCHEMA; RUNSCRIPT FROM file]
    - cleanAndMigrateDatabase(), cleanDatabase(), migrateDatabase()
    - isEmpty(): boolean (EmptyDataSource detection)
- PersistenceLayer (implementation)
  - DataSource: H2 in-memory (JdbcConnectionPool) jdbc:h2:mem:training;MODE=PostgreSQL
  - Flyway configuration: schemas ADMINISTRATIVE, LIBRARY, AUTH bound to the single DataSource.
  - SQL execution utilities (micro ORM):
    - executeUpdateTemplate(description, sql, Object...params)
    - executeInsertTemplate(description, sql, Object...params) → long generated id
    - runQuery(SqlData<R>) → Optional<R>
    - prepareStatementWithKeys returns Statement.RETURN_GENERATED_KEYS statements.
    - throwingFunctionWrapper and createExtractor produce extraction lambdas mapping ResultSet to Optional<T>, centralizing error handling.
    - Supported parameter types in SqlData.applyParametersToPreparedStatement: String, Integer, Long, Date.
  - Authentication hashing:
    - Password hashing: SHA-256 of UTF-8 password converted to hex string (bytesToHex).
    - areCredentialsValid: SELECT id FROM auth.user WHERE name = ? AND password_hash = ?; presence ⇒ Optional.of(true), otherwise Optional.empty().
  - “Empty” pattern:
    - createEmpty(): returns PersistenceLayer with EmptyDataSource.
    - isEmpty(): DataSource class equals EmptyDataSource.
- SqlData<R> (micro ORM data holder)
  - Fields: description, preparedStatement (string), params (List<ParameterObject<?>>), extractor (Function<ResultSet, Optional<R>>).
  - Creates typed parameter objects via runtime class of each provided param.
  - toString/logging summarizes description, params, and SQL.
- ParameterObject<T>
  - Wraps one param datum and its type class; includes createEmpty and equality/hashcode.
- SqlRuntimeException
  - Wraps SQL or general exceptions thrown inside ORM templates.
- EmptyDataSource and NotImplementedException
  - Null-object pattern for DataSource; each method throws NotImplementedException.
- DbServlet (GET /flyway)
  - Query param: action=clean|migrate|<other/default>
  - Behavior:
    - clean ⇒ pl.cleanDatabase(); result="cleaned"
    - migrate ⇒ pl.migrateDatabase(); result="migrated"
    - default ⇒ pl.cleanAndMigrateDatabase(); result="cleaned and migrated"
  - Sets request attribute return_page="library.html"
  - Response forwarding: ServletUtils.forwardToResult (non-REST JSP result page, result.jsp).

Tomcat bootstrap and web.xml
- WebAppListener (@WebListener)
  - On contextInitialized: pl.cleanAndMigrateDatabase() to recreate DB schemas at startup.
  - On contextDestroyed: no-op.
- web.xml
  - Maps H2 console: servlet org.h2.server.web.WebServlet under /console/*; webAllowOthers=true.
  - Session tracking: COOKIE only.
  - JSP config: UTF-8 page encoding.
  - No security constraints configured.

Database schema (Flyway migrations)
- V1__Create_person_table.sql
  - create table library.PERSON(id serial PRIMARY KEY, name VARCHAR(100) NOT NULL)
- V2__Rest_of_tables_for_auth_and_library.sql
  - drop table library.person
  - create table library.BORROWER(id serial PRIMARY KEY, name VARCHAR(100) NOT NULL)
  - create table library.BOOK(id serial PRIMARY KEY, title VARCHAR(100) NOT NULL)
  - create table library.LOAN(
      id serial PRIMARY KEY,
      book int NOT NULL REFERENCES library.BOOK(id) ON DELETE CASCADE,
      borrower int NOT NULL REFERENCES library.BORROWER(id) ON DELETE CASCADE,
      borrow_date date NOT NULL
    )
  - create table auth.USER(
      id serial PRIMARY KEY,
      name VARCHAR(100) NOT NULL,
      password_hash VARCHAR(100)
    )
- Notes:
  - PersistenceLayer’s reading logic defensively handles possible null borrow_date by substituting Date.valueOf("0000-01-01") even though migration sets NOT NULL on borrow_date.
  - Flyway configured for schemas ADMINISTRATIVE, LIBRARY, AUTH; migration scripts explicitly use lowercase library and auth schema names (H2 is case-insensitive by default).

Domain/data models referenced
- com.coveros.training.library.domainobjects.Book
  - Fields (from usage): id (long), title (String)
  - Methods referenced: createEmpty(), toOutputString for JSON, equals/hashcode (validated in tests).
- com.coveros.training.library.domainobjects.Borrower
  - Fields: id (long), name (String)
  - Methods referenced: createEmpty(), toOutputString -> {"Name": "...", "Id": "..."}
- com.coveros.training.library.domainobjects.Loan
  - Fields: Book, Borrower, id (long), borrowDate (Date)
  - Methods referenced: createEmpty()
- com.coveros.training.authentication.domainobjects.User
  - Fields: name (String), id (long)
  - Methods referenced: createEmpty()
- Many “createEmpty” methods implement a Null Object pattern to avoid nulls.

UI, static resources, and API expectations
- restfulresult.jsp: outputs only ${result} (plain body).
- result.jsp: simple HTML wrapper around ${result}, with a Return link using request attribute return_page.
- endpointcatalog.html (developer/test catalog)
  - Forms hitting:
    - POST /math (item_a, item_b)
    - POST /fibonacci (fib_param_n, fib_algorithm_choice)
    - POST /ackermann (ack_param_m, ack_param_n, ack_algorithm_choice)
    - GET /book (id, title)
    - GET /borrower (id, name)
- library.html (Library UI)
  - POST endpoints expected:
    - /login, /register (authentication)
    - /lend (book, borrower)
    - /registerbook (book)
    - /registerborrower (borrower)
  - Database maintenance via /flyway buttons (GET).
- catalog.js (AJAX helper)
  - Submits forms via XMLHttpRequest; for GET converts FormData to query string; writes response text into a textarea with class responsearea.
- library.js (UX helper for Library UI)
  - talk(verb, path, data): XHR with application/x-www-form-urlencoded content type.
  - Expects GET /listavailable to return JSON list of available books, and GET /borrower to return JSON list of borrowers; enhances UI:
    - If 0 items ⇒ lock input;
    - 1–9 items ⇒ replace input with a <select> dropdown;
    - 10+ ⇒ add an autocomplete searchbox which filters results as user types.
  - Adds click/keyup handlers, search box creation and teardown.
- dbhelp.html: describes H2 connection URL: jdbc:h2:mem:training;MODE=PostgreSQL;DB_CLOSE_DELAY=-1 (note: DB_CLOSE_DELAY not set in code; here for console).
- main.css: basic styling; library UI layout responsive.

Service dependencies and communication patterns
- Presentation → Business/Algorithm layer: Servlets invoke static utility classes directly (Calculator, Fibonacci/FibonacciIterative). Library-related servlets and utils exist but are in the other chunk; this chunk’s tests reference them.
- Presentation → Persistence: DbServlet and WebAppListener call IPersistenceLayer methods; business-layer code (LibraryUtils, AuthenticationUtils in other chunk) call IPersistenceLayer as well.
- Persistence → DB: JDBC calls against H2 in-memory; Flyway manages schema versions; SQL is embedded strings in PersistenceLayer (no external ORM).
- No inter-service network calls inside the application; all calls are in-process. External communication is only:
  - Browser → Servlets (HTTP),
  - Servlets → H2 DB (JDBC),
  - Development/test utilities (Selenified/Selenium/HtmlUnit/Behave) for E2E tests.

Key business logic and algorithms
- Math operations:
  - Simple addition of ints/doubles and pairwise sums.
  - Number-to-word mapping for 0..10.
- Fibonacci:
  - Naive recursion for small n (FibServlet “default recursive”).
  - Fast doubling (O(log n)) for large n or “tail_recursive_1” (BigInteger).
  - Iterative linear for “tail_recursive_2” (BigInteger).
- Authentication (persistence side):
  - SHA-256 hash of password stored as hex string; credentials validated via username and password_hash match.
- Library persistence:
  - Register books and borrowers; create loans; list/search books/borrowers; detect book availability via left join loan table (listAvailableBooks SQL).
  - Loan lookups by borrower or by book; returns domain objects assembled from DB row data.

Interfaces and data contracts

HTTP APIs implemented here
- POST /math
  - Request: application/x-www-form-urlencoded
    - item_a: integer
    - item_b: integer
  - Response: plain text body with numeric sum or "Error: only accepts integers".
  - Example: 2+3 → 5
- POST /fibonacci
  - Request: application/x-www-form-urlencoded
    - fib_param_n: integer
    - fib_algorithm_choice: default_recursive | tail_recursive_1 | tail_recursive_2
  - Response: plain text body with Fibonacci(n) as integer/BigInteger string; "Error: only accepts integers" on bad input.
- GET /flyway
  - Request: query parameter action = clean | migrate | (omit or other → clean+migrate)
  - Response: navigates to result.jsp; result attribute set to “cleaned”, “migrated”, or “cleaned and migrated”.

Interfaces used but implemented in other parts of the codebase
- /book, /borrower, /listavailable, /lend, /register, /login, /registerbook, /registerborrower, /ackermann (referenced by HTML/JS/tests).
  - Response formats indicated by tests:
    - /borrower GET: returns JSON list like [{"Name":"alice","Id":"1"}]
    - /listavailable GET: returns JSON list like [{"Title":"a book","Id":"1"}]
    - /book GET: returns JSON list or error strings.
    - /lend POST: returns result string like "SUCCESS" or error codes (e.g., NO_BORROWER_PROVIDED).
    - /register, /login: return result strings indicating registration status or access granted/denied.

Internal Java interfaces/classes used by other modules
- IPersistenceLayer: Single entry point to DB for both Library and Authentication bounded contexts; provides CRUD and utility operations.
- Domain objects (Book, Borrower, Loan, User): simple POJOs with equals/hashcode, “createEmpty”, and some JSON-string formatting helpers.

Configuration and deployment details
- Application server: Tomcat (expects javax.servlet API); web.xml sets H2 Console and session tracking to COOKIE.
- Database: H2 in-memory with JDBC URL jdbc:h2:mem:training;MODE=PostgreSQL
  - In PersistenceLayer constructor. For console usage dbhelp suggests adding DB_CLOSE_DELAY=-1 to keep DB alive across connections.
  - Flyway migrations run at startup (WebAppListener) and via GET /flyway.
- Logging: SLF4J + log4j2; log4j2.xml sets root logger to INFO; console appender pattern “%d %p %m%n”.
- Static resources: JSPs (restfulresult.jsp/result.jsp), HTML pages, CSS (main.css, catalog.css), and JS (catalog.js, library.js).
- Annotations used:
  - @WebServlet(name=..., urlPatterns={...}, loadOnStartup = 1)
  - @MultipartConfig for multipart/form-data support via FormData API.
  - @WebListener for startup listener.

Libraries, frameworks, and tooling
- Java EE/Servlet API (javax.servlet.*)
- SLF4J and log4j2 for logging
- Flyway for DB migration
- H2 (in-memory database), org.h2.jdbcx.JdbcConnectionPool
- Apache Commons Lang3 (Pair, EqualsBuilder/HashCodeBuilder/ToStringBuilder)
- JUnit 4, Mockito, TestNG, Selenified, Selenium/WebDriver, HtmlUnit for tests
- UI tests across languages (Java, JS, Python, C#) demonstrating public API expectations

Error handling and validation
- PersistenceLayer methods validate inputs via com.coveros.training.helpers.CheckUtils (StringMustNotBeNullOrEmpty, IntParameterMustBePositive). Invalid inputs result in IllegalArgumentException.
- ORM templates wrap SQLExceptions in SqlRuntimeException.
- Servlets:
  - MathServlet and FibServlet catch NumberFormatException for parameter parsing and set a human-readable error message string into result.
  - DbServlet action fall-through defaults to cleanAndMigrate.

Architectural patterns
- Layered architecture
  - Presentation (Servlets, JSP) → Business/Algorithm utilities → Persistence (micro ORM) → Database.
- Null Object pattern
  - EmptyDataSource, createEmpty() factory methods for domain and utility classes.
- Template method/encapsulation for SQL operations
  - SqlData and PersistenceLayer’s execute*Template methods centralize JDBC boilerplate and parameter binding.
- Functional style for tail-recursive computation
  - TailRecursive.tailie builds iterables with Stream.iterate and predicate-based termination.

Service dependencies and communication
- Intra-application: only in-process Java calls (Servlets → Utils → PersistenceLayer).
- Database: single shared H2 in-memory database for all bounded contexts (Library, Authentication) under shared PersistenceLayer implementation.
- External exposure: browser clients over HTTP; developers can use /console for H2, as enabled in web.xml.

Observations relevant to microservice decomposition
- Clear bounded contexts:
  - Mathematics: stateless computational service; no DB dependency. Could be separated as a compute microservice with REST endpoints for /math, /fibonacci, /ackermann.
  - Library: stateful domain (books, borrowers, loans). API endpoints include /book, /borrower, /lend, /listavailable, /registerbook, /registerborrower.
  - Authentication: stateful domain (users, credentials). API endpoints include /register, /login; password hashing is encapsulated within PersistenceLayer in current design but logically belongs to Auth service.
- Current coupling:
  - Single PersistenceLayer shared by Library and Auth contexts; shared H2 DB and Flyway schema management.
  - UI pages integrate multiple contexts in a single webapp (library.html contains auth and lending forms).
  - ServletUtils/StringUtils/CheckUtils are cross-cutting utilities not shown here but used widely; factor into shared library if decomposed.
- Data schema boundaries:
  - Schemas LIBRARY.* (BOOK, BORROWER, LOAN), AUTH.USER. Clean separation at schema-level is already in place, favorable for service-per-database decomposition.
- API payload formats:
  - Responses are plain strings or JSON-encoded strings placed into “result” and rendered by JSP. For microservices, formalize JSON contracts and content types (application/json), remove JSP coupling.
- Configuration:
  - DataSource is programmatically defined (in-memory H2). For production microservices, configure via environment/DI and isolate DB per service.
- Startup behavior:
  - WebAppListener runs clean+migrate, resetting state. In microservices, such behavior should be controlled per service and disabled in production.

Examples of SQL executed (PersistenceLayer)
- Insert borrower: INSERT INTO library.borrower (name) VALUES (?);
- Insert book: INSERT INTO library.book (title) VALUES (?);
- Create loan: INSERT INTO library.loan (book, borrower, borrow_date) VALUES (?, ?, ?);
- Update borrower: UPDATE library.borrower SET name = ? WHERE id = ?;
- Delete book/borrower: DELETE FROM library.book/borrower WHERE id = ?;
- Queries:
  - Get borrower name by id: SELECT name FROM library.borrower WHERE id = ?;
  - Borrower by name: SELECT id, name FROM library.borrower WHERE name = ?;
  - Book by title: SELECT id FROM library.book WHERE title = ?;
  - Book by id: SELECT id, title FROM library.book WHERE id = ?;
  - All books: SELECT id, title FROM library.book;
  - Available books: SELECT b.id, b.title FROM library.book b LEFT JOIN library.loan l ON b.id = l.book WHERE l.borrow_date IS NULL;
  - All borrowers: SELECT id, name FROM library.borrower;
  - Loans by borrower:
    SELECT loan.id, loan.borrow_date, loan.book, book.title
    FROM library.loan loan
    JOIN library.book book ON book.id = loan.book
    WHERE loan.borrower = ?;
  - Loan by book:
    SELECT loan.id, loan.borrow_date, loan.borrower, bor.name
    FROM library.loan loan
    JOIN library.borrower bor ON bor.id = loan.borrower
    WHERE loan.book = ?;
  - Auth:
    INSERT INTO auth.user (name) VALUES (?);
    SELECT id FROM auth.user WHERE name = ?;
    SELECT id FROM auth.user WHERE name = ? AND password_hash = ?;
    UPDATE auth.user SET password_hash = ? WHERE id = ?;

Non-functional concerns
- Logging: INFO level console logging configured.
- Error handling: basic; no centralized exception mappers; DbServlet always forwards to result.jsp.
- Security: no transport security (HTTP only), no auth on H2 console; login/register endpoints exist but not in this chunk; passwords hashed with SHA-256 only (no salt/iterations).
- State: in-memory DB implies non-persistent state; startup listener wipes and migrates schemas.

Testing support (for understanding API behavior)
- Extensive unit and integration tests across JUnit, Mockito, Selenified, Selenium, HtmlUnit, Python Behave, JS Mocha, and C# NUnit.
- Tests assert response strings, JSON formats (for book/borrower listings), and endpoint availability (/flyway, /library.html flows).

Summary for decomposition
- Candidate microservices:
  - Math service (expose /math, /fibonacci, /ackermann; no DB).
  - Library service (book/borrower CRUD, loans; LIBRARY schema database).
  - Auth service (user registration/login; AUTH schema database).
  - DB migration/admin service or admin endpoints co-located with each service (replace centralized /flyway).
- Interface stabilization needed:
  - Replace JSP forwarding with JSON responses (application/json) and explicit response schemas.
  - Decouple ServletUtils/StringUtils/CheckUtils into shared libraries or per-service utilities.
  - Externalize DataSource config and Flyway execution per service.
- Data separation already partially present via schemas; persistence APIs are already well-factored behind IPersistenceLayer but currently shared.